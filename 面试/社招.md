前端知识总结-社招版
1. 资料
https://github.com/mqyqingfeng/Blog?tab=readme-ov-file
https://github.com/huixisheng/FE-weekly
https://bigfrontend.dev/
https://blog-ssg.touchczy.top/zh-cn/
https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93
https://sunny-117.github.io/blog/front-end-engineering/performance.html
https://github.com/ascoders/weekly
https://www.yuque.com/cuggz

2. 面试题
社招题目
1. 简单的自我介绍。
面试官，你好。我叫xxx，2022年7月毕业于xxxx大学的计算机科学与技术专业。
作为一名校招生，一直在58同城业务部门的中台前端组工作。
•主要是 用 react 或者 vue 开发一些 pc端项目，其中投入精力比较多就是 我简历上提到的数据罗盘和运营平台。
•node方面，主要是搭建了 数据罗盘这个项目 的 BFF 层 ，参与过一些 AI 项目的开发，比如最近的ComfyUI 生图、CR 机器人、批量生成宣传图等功能。
•h5 方面，主要是开发在运营平台上配置的活动页、专门给一些C端应用开发的组件库。
•在 小程序 方面，主要是开发 小程序的taro组件库。  

2. 你做过最困难的项目或者任务是什么？
最困难的项目，按我理解就是最耗时的。用了一年半的时间，在完成业务需求的同时，显著提升了罗盘的用户体验、开发体验。
前端
设计模式
•从前端代码的角度来说，原项目的最大问题是以发布订阅模式为核心的交互体系，数据流走向相当混乱。
•eventBus的滥用 +订阅者过多，导致 页面不能做到完全的并发请求。
•当多个相互间有联动的图表组件出现在同一页面时，某个组件的请求加载速度会影响到其他组件的加载。
•我的方案是改为观察者模式，将需要观察的数据都放入Vuex中，图表组件间的复杂联动通过 监控watch Vuex里的数据 去实现，这样页面的图表组件各自的网络请求就不会相互阻塞。

localStorage 缓存
•建立间各个图表组件间联系的数据，通常是某个页面的 相关配置信息【默认查询的指标key、趋势图的查询范围选项、顶部表单的值、过期时间(5分钟)、配置版本号】作为JSON数据存储到localStorage里。
•最初获取页面信息的接口：确保当 指标配置版本号变化 或者 达到过期时间 后，用户界面能立即请求最新数据去更新界面。

减少重绘重排
•为了减少整个页面的重绘重排，我用了合适大小的骨架屏去占好了固定位置。
•各个图表组件渲染时就在各自的BFC里独立渲染，不会因为位置大小的频繁变化导致页面的回流重绘。

后端
•没有利用Node.js 的 高并发特性 和 fork进程 去合理利用多核CPU, 单进程去执行复杂SQL，速度较为缓慢。
•循环中的异步操作的滥用，尤其是出现 在for循环中串行访问数据库的离谱操作。
•利用 rpc 框架 将 复杂SQL 的执行交给 Java处理，Node.js 转为 BFF 层。

项目工程配置
•js-conditional-compile-loader【条件编译，实现新老系统代码的共存】
￮思路：老代码的页面过多，完整打包怎么优化都是慢。利用 条件编译 + 多入口打包，实现新老系统代码的共存，这样在开发新系统时，能明显提高热更新效率。同时，跟着需求节奏，不断迁移重构老系统的代码。
•cache-loader 的应用，缓存本地打包的产物。

微前端总结
•本身代码不多，主要对 webpack配置、 样式代码 有一些改动。
￮本地与线上环境区分：
▪ publicPath 前缀不同，url不同，便于区分。
￮部署方式的变化：
▪上线的方式 从 资源打包后挂载在服务端的静态资源路径下 改为服务端只拿 页面对应的 index.html 和 计算 cdn 链接，然后前端从平台更新cdn资源即可。
￮入口html变化：
▪为了更好的调试 和 mock数据，每个拆出来的微前端子应用，本地和生产环境各有一个html文件，根据环境区分打包时的入口文件。
￮独立运行：
▪怎么样确保 每个微前端子应用 只能在本地开发时能独立运行，在线上只能从主应用的菜单里选择具体运行哪个子应用？
•与权限相关的数据，只能从主应用里完成单点登录后请求获取，一些关键信息会存储到localStorage里，但不会在线上用。只有本地的子应用在运行时，会获取 localStorage里的权限数据。
•线上的子应用：只能通过 与主应用间的通信 获取权限数据，没有权限则会直接跳转根目录。
￮有明确的微前端边界划分原则
▪不是单纯从路由角度去拆分业务。
▪自定义图表配置、罗盘指标配置等功能相对独立的页面，拆成单个工程去维护。
▪埋点验证系统、数据监控系统、SQL配置平台等项目，以 微前端子应用 或 iframe 方式接入。
￮public-path.js，修改运行时的 publicPath ，确保子应用的资源路径是全路径，避免因为使用相对路径出现资源路径错误。
￮主、子应用的样式隔离问题。
￮子应用设置的路由需要严格与activeRule对应上。
▪如果子应用的某些路由没有匹配到有效的 activeRule，控制台会有警告，还可能出现路由noFound与子应用突然存在的尴尬情况。
▪为了避免上述问题，为所有子应用加统一前缀。
￮同源策略，不同域名间请求的跨域问题。
▪主要是一些后端服务还部署在老的域名下。

3. 简历上的这个项目未来要做哪些事？你觉得还可以怎么进一步优化？
数据罗盘
•复杂页面性能问题：
￮实现 页面图表组件级别的虚拟滚动。
￮有个延迟加载效果，优先渲染首页。
￮确保页面首屏加载速度，不会受制于页面组件个数的影响。
•移动端适配：
￮有个瀑布流布局的展示效果

宣传图
•代码处理：宣传语可能对 AI生成的图片主体 有遮挡效果，目前是通过调整 opacity 透明度 简单处理下。
•行为处理：带有宣传文字的模版，尽可能避免中间区域。生成的AI类目图，主体尽可能在中间区域
•未来计划：主体位置 和 宣传语位置 有个各自画个矩形和相应对比，计算重叠区域大小。

CR机器人
•文件级别的CR还是不够，需要建立联系。
•各个项目的知识库配置 和 CR 提示词 能支持单独配置似乎效果更好。
•确实不能做到严格保证代码安全性

运营平台
•前端
￮当搭建比较复杂、涉及很多基础组件的h5页面时，页面整体的网络请求也可能变多，浏览器自带的并发请求限制一般是6-8个，各个组件本身都认为自己是第一优先级加载的，这可能导致出现在首页的组件请求不能第一时间去发起网络请求。
▪沿用之前的思路：
•优化 JSON 的 数据渲染策略，利用数据罗盘项目想到的idea，将骨架屏占位的操作提前，减少浏览器的回流重绘操作。
•影响页面完整加载的埋点上报：延迟上报时间或者改变上报时间。主要应用策略：通过 IntersectionObserver api 去延迟发送展现埋点。
JavaScript
/**
 * @description: 监测视图可见元素并发送展现埋点
 * @param {Array<HTMLElement>} nodes 要监听的DOM节点数组
 * @param {Function} sendShowLog 单个node发送展现埋点方法
 * @return {void}
 不一定立即执行函数，这取决于元素在页面中的初始位置以及是否已经与视口相交。
 IntersectionObserver 的工作原理是在绑定后首次检查元素是否与视口相交，
 如果元素在绑定观察器的那一刻已经至少部分出现在视口内（即 intersectionRatio > 0），
 那么会立即触发回调函数，执行相应的操作。
但是，如果元素在初始时完全不在视口内，
那么IntersectionObserver不会立即触发回调函数。
它会等待直到元素进入视口并与视口产生交集时，才会执行回调函数。
 */
export const observeNodesShowLog = (nodes, sendShowLog) => {
    const IntersectionObserver = window.IntersectionObserver;
    if (!IntersectionObserver) {
        console.warn('当前不支持IntersectionObserver');
        return;
    }

    const intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.intersectionRatio > 0) {
                const { target } = entry;
                // 判断一下dom上是不是已经埋过了，埋过了就不发了
                const isHaveTrack = target.getAttribute('compset-itemtrack-done');
                if (isHaveTrack) {
                    intersectionObserver.unobserve(entry.target);
                    return;
                }
                sendShowLog(target);
                // 添加发送参数
                target.setAttribute('compset-itemtrack-done', '1');
                // 如果只发一次则取消监听
                intersectionObserver.unobserve(entry.target);
            } else {
                console.log('hide');
            }
        });
    });

    // 遍历节点添加observe
    nodes.forEach((node) => {
        intersectionObserver.observe(node);
    });
};
•微前端拆分项目，明显提升热更新效率
▪新思路1：虚拟滚动，只加载部分页面的组件，剩余的组件随着页面组件的滚动再去加载。
▪新思路2：搞一个请求带有的优先级的异步并发控制器，在每个组件配置信息里加入网络请求优先级的概念，尤其针对 头组件的下拉框数据，滑动组件的算法推荐接口。在运营平台的pc端系统上提供配置入口，从而确定当涉及较多的网络请求时 请求的先后顺序。

•客户端配合
￮离线包技术、接口预请求、预渲染、预请求、预加载 

•服务端配合
￮服务端渲染 ssr：一直想尝试，感觉目前状态很接近 
￮CDN缓存，缓存更多静态资源，减少服务端的压力
￮在活动页面改版的过程中进行，与后端一起抽离原有的业务代码逻辑。
￮对于不涉及用户登录态、推荐算法、分流策略的数据接口，让后端都加上浏览器缓存。

4. React 15、React 16、React 17 、React 18 、React 19 的重大改动点是什么？对 React 16 Fiber架构 和 Scheduler(调度器)的理解？React 老架构的劣势是什么？为什么 Fiber架构 可以随时中断渲染呢？React hook 的实现原理是什么？useState的setState的原理是什么？React 源码你是如何学习的？你最了解哪一块内容？说说 React 的 事件委托机制？各个版本的相关改动点。
React15 
•语法：推荐ES6的class语法，React.createClass被劝阻。
•细节：diff算法的优化，事件委托机制的改进
•缺点：同步的递归渲染虚拟dom，大型项目diff时间过长，造成渲染不及时、交互卡顿的现象。

React16
Fiber架构
￮原有的 React组件 是对 真实dom 的抽象。
￮react16 是重大迭代，采用了全新的Fiber架构。
￮Fiber节点 是 React组件 的轻量级抽象，代表的是 虚拟DOM树中的一个节点。
•迭代而非递归：
￮Fiber使用迭代而不是递归来遍历这个链表结构
▪原有的递归方式类似于树的dfs深度优先搜索遍历，需要一个调用栈保存中间状态，当遍历到叶子节点，逐层回退。
JavaScript
function depthFirstSearch(node) {
  if (node) {
    console.log(node); // 处理当前节点
    for (let i = 0; i < node.children.length; i++) {
      depthFirstSearch(node.children[i]); // 递归处理子节点
    }
  }
}
function depthFirstSearchIterative(rootNode) {
  const stack = [rootNode];
  while (stack.length > 0) {
    const currentNode = stack.pop();
    console.log(currentNode); // 处理当前节点
    // 将子节点逆序推入栈中，以保证深度遍历
    for (let i = currentNode.children.length - 1; i >= 0; i--) {
      stack.push(currentNode.children[i]);
    }
  }
}
•双向链表结构：Fiber引入了一种改良的链表结构，每个Fiber节点除了包含自身的状态信息外，还明确定义了return(父节点)、child(第一个子节点)、sibling(下一个兄弟节点)指针，形成了一个双向链表。
•保存当前工作状态：双向链表结构，使得React可以在遍历过程中随时“记住”当前位置，无需像递归那样依赖调用栈来跟踪状态。下次恢复时直接从这个节点继续遍历，无需回溯。
•细粒度控制：Fiber节点是最小的工作单元，对页面渲染任务进有非常细粒度的控制，这不仅意味着可以高效地中断和恢复，也为优先级调度提供了基础。当需要检查是否应中断时（比如通过检查是否达到某个时间阈值或是否有更高优先级的任务），React可以直接停止当前循环，每一次循环迭代都是一个独立过程（即处理一个Fiber节点）。

引入 Scheduler 调度器
•基于 Fiber 的 双向链表结构，通过循环迭代的方式创建 Fiber Tree，是实现细粒度控制渲染任务的基础。
•Fiber节点是最小的工作单元，对页面渲染任务可以细粒度地控制，可以随时保存当前工作状态、渲染任务随时中断恢复，这为 Scheduler [死给酒辣] 调度器实现任务调度提供了基础。
•为了进一步解决交互事件迟迟得不到更新的问题，提出了任务优先级的概念。
￮lane模型：负责 react的优先级排序的。
▪过期任务或者同步任务，同步优先级
▪用户交互，高优先级
▪网络请求产生的更新，一般优先级
▪Suspense组件，低优先级
▪自定义优先级：useTransition、useDeferredValue hook。

React hook 原理 
React Hooks 的实现必须依赖 Fiber 么? - 掘金 ---不需要。
•具体实现就是保存在 fiber节点的 memorizedState 链表上，用 next 指针串联，n个hook就是n个next指针。
•通过保存状态和其他信息的链表节点，实现了在函数组件中存储和更新状态的能力。
•每次重渲染时都会遍历这条hook链表，基于它们的调用顺序来存储相应的状态值。
•所以，必须确保hook只能写顶部，不能在循环和if条件下调用，确保了hook链表顺序的唯一性。
•其中 useCallback 、useMemo、useRef 主要是在链表上值的缓存。useState和useEffect 则还会触发调度策略。

setState流程
1.创建Update对象, 挂在当前组件的Fiber的更新队列上(Fiber.upodateQueue)。
2.执行scheduler的调度逻辑,确定当前任务的优先级, 是延迟更新还是立即触发更新。
3.协调器 reconciler阶段，首先把 vdom 转成 fiber，之后再渲染 fiber。
4.触发更新时从应用的根组件开始,在内存中生成一颗新的Fiber树。
5.遍历到当前组件Fiber时, 会遍历 updateQueue中 当前任务优先级的 update对象 , 计算出最新的state。
6.state的变化，产生与上次更新不同的JSX对象 , 通过Diff算法打上DOM更新的标记。
7.在commit阶段，一次性提交并应用此次更新的所有DOM操作。
8.当 Fiber树 更新完成后，指针发生切换。
9.解析新的Fiber树，完成页面渲染。



React17
一文解读 React 17 与 React 18 的更新变化 - 掘金

原有的 React 事件委托机制
￮React 的事件都是合成事件，抹平了浏览器的事件差异，利用原生事件会冒泡到根节点实现的。
￮原生事件：首先，原生的DOM事件会在实际的DOM元素上触发并开始冒泡。如果事件监听器直接绑定在DOM元素或document上，这些原生事件会按照标准的事件流（先捕获后冒泡）进行。
￮React合成事件：React通过在document级别监听所有类型的事件，当事件冒泡到document时，React会根据事件的目标元素和React组件的结构，创建并分发一个合成事件给相关的React组件处理。
￮React的事件处理逻辑发生在原生事件冒泡到document之后。所以对于直接绑定在document上的原生的document事件，在React的合成事件处理之前执行。
￮React应用中使用了e.stopPropagation()来阻止React合成事件的进一步冒泡，但原生绑定在document上的事件监听器依然能够接收到事件并执行。

•去除事件池：之前是在事件池统一管理合成事件对象，这意味着合成事件对象可以被复用。当所有事件处理函数被调用之后，其所有属性都会被回收释放置空，所以在异步事件中打印 e.target会发现事件已被销毁。之前需要先用e.persist()保持事件的引用。

•事件委托改为根dom：react17前，React 将事件委托到 document 上。在react17中，则是委托到在document下的根节点。
￮解决了之前 e.stopPropagation()方法阻止不了，事件冒泡到绑在document上的原生事件，因为它的事件源跟document是同级关系。
￮React v17之前，document原生事件执行后，才会执行你绑定的事件。
￮改为 root节点后，事件冒泡流程会在document下级的根节点结束。
￮解决了不同版本的 React 组件嵌套使用时，e.stopPropagation()无法正常工作的问题。
￮所有的事件委托对象都是各自react组件的根节点，而不是都绑定在document上，之前混搭可能会有冲突。

用 jsx() 函数替换 React.createElement()，不用引入react 了。

React 副作用清理时机
￮v17 将在运行任何新的副作用，之前执行所有副作用的清理函数（针对所有组件），v16 只对组件内的副作用保证这种顺序。
￮副作用清理函数之前是同步的，可能会减缓屏幕过渡的速度。
￮React v17后，副作用清理函数是异步执行的，如果要卸载组件，则清理会在屏幕更新后运行，这时组件的ref对象可能为空。
￮useLayoutEffect 可以保证回调函数同步执行，它发生在dom渲染前。

React 的 onFocus 和 onBlur 事件切换
￮已在底层切换为原生的 focusin 和 focusout 事件。它们更接近 React 现有行为，有时还会提供额外的信息。onScroll 事件不再冒泡。增加捕获事件（例如，onClickCapture）现在使用的是实际浏览器中的捕获监听器。

启发式更新算法
•React16的expirationTimes模型只能区分是否>=expirationTimes决定节点是否更新。React17的lanes模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。

React18
批处理和并发模式变化
v16：虽然引入了Fiber架构，但主要聚焦于解决组件更新过程中的效率问题，比如实现增量渲染，即只重新渲染发生改变的部分，而不是整个组件树。并没有完全发挥出Fiber架构的并发能力，大部分更新仍然是同步进行的。
v17 可以通过一些试验性的API开启并发模式，而v18则全面开启并发模式。
v18 的重大区别就是：完全开启异步可中断更新。
•v18中，并发更新是默认启用的。
•高级并发特性，如 useDeferredValue和 useTransition，需要开发者显式地在代码中使用才能生效。
•v18 使用 ReactDOM.createRoot() 创建一个新的根元素进行渲染，使用该 API，会自动启用并发模式。用ReactDOM.createRoot()代替ReactDOM.render()。
•批处理是指 React 将多个状态更新，聚合到一次 render 中执行，以提升性能。
￮v17：批处理只会在事件处理函数中实现，在Promise链、异步代码、原生事件处理函数中失效。
￮v18：所有的更新都会自动进行批处理。flushSync在函数作用域内退出批处理。

Suspense 支持 SSR
SSR 一次页面渲染的流程：
1.服务器获取页面所需数据
2.将组件渲染成 HTML 形式作为响应返回
3.客户端加载资源
4.（hydrate）执行 JS，并生成页面最终内容
上述流程是串行执行的，v18前的 SSR 有一个问题就是它不允许组件"等待数据"，必须收集好所有的数据，才能开始向客户端发送HTML。如果其中有一步比较慢，都会影响整体的渲染速度。v18 中使用并发渲染特性扩展了Suspense的功能，使其支持流式 SSR，将 React 组件分解成更小的块，允许服务端一点一点返回页面，尽早发送 HTML和选择性的 hydrate， 从而可以使SSR更快的加载页面。

React 17及以前的Suspense
在React 17及更早的版本中，Suspense主要用于处理异步组件加载和数据加载时的优雅降级。Suspense组件可以包裹那些可能会异步加载的组件，例如使用React.lazy()导入的组件，或者是那些在加载数据时可能会“挂起”（即等待数据加载完成）的组件。
SSR中的限制
在SSR中，Suspense在React 17及以前的版本中并不支持流式渲染。这意味着当服务器渲染一个包含Suspense边界的组件时，如果该组件正在等待数据加载，整个渲染过程会被阻塞，直到数据加载完成。这导致了SSR性能的瓶颈，因为服务器必须等待所有的数据加载完毕才能开始渲染HTML，然后才能发送给客户端。
JavaScript
// MyAsyncComponent.js
import React, { lazy, Suspense } from 'react';

const MyAsyncComponent = lazy(() => import('./MyComponent'));

function MyApp() {
  return (
    <div>
      <h1>Welcome to MyApp</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <MyAsyncComponent />
      </Suspense>
    </div>
  );
}

export default MyApp;
React 18及以后的Suspense
在React 18中，Suspense的SSR支持得到了增强，引入了流式渲染的能力。这意味着服务器可以开始渲染并流式传输已经准备好的HTML，即使某些部分还在等待数据。这样做的好处是，用户可以更快地看到页面的初步内容，而不需要等待所有数据加载完成。
流式渲染
在React 18中，你可以使用ReactDOMServer.renderToPipeableStream()方法来开始一个流式渲染的过程。这允许服务器在等待某些组件数据的同时，继续渲染和发送已经就绪的部分。这极大地提升了SSR的性能和用户体验，因为用户可以立即看到部分内容，而剩余部分随着数据加载完成逐渐填充。
更细粒度的控制
React 18中的Suspense还允许开发者更细粒度地控制哪些部分应该等待数据加载，哪些部分可以提前渲染。这使得开发者可以优化SSR流程，根据数据的优先级决定渲染顺序。
总结来说，React 18之前的Suspense在SSR中主要是阻塞性的，而React 18及以后的Suspense支持流式渲染，提供了更好的性能和用户体验。

并发模式 hook 的出现与应用
开发者主动告诉 React 它们可以被中断执行。
比如 useTransition 当有过渡任务（非紧急更新）时，我们可能需要告诉用户什么时候当前处于 pending（过渡） 状态，因此v18提供了一个带有isPending标志的 Hook useTransition来跟踪 transition 状态，用于过渡期。

React 19
•自动记忆化：React 19 引入了革命性的自动记忆化功能。以前，开发人员必须手动使用 useMemo、useCallback 和 memo 等 API 来优化组件的渲染性能。现在，借助全新的编译器技术，React 19 可以自动检测组件的状态变化，并智能地决定是否需要重新渲染。这意味着开发人员无需手动优化，就可以获得最佳的渲染性能。自动记忆化还可以确保组件在状态变化时只渲染必要的部分，进一步提高了应用程序的性能和响应速度。
•Actions：这是前后端数据交互的新姿态。传统上，我们需要手动管理表单数据的提交、验证和处理，这增加了开发的复杂度。然而，React 19 引入了革命性的 Actions 特性，允许开发者将一个函数直接传递给 DOM 元素，如 <form />。当用户与表单交互时，React 会自动调用该函数，并为开发者管理整个数据提交的生命周期。这大大简化了前后端数据交互的开发过程，提高了开发效率和代码质量。
•指令：use client 与 use server：随着全栈框架的兴起，前端开发已经不再局限于构建单纯的客户端应用程序。React 19 引入了 use client 和 use server 两个全新的指令，旨在帮助开发人员更好地管理客户端和服务端代码。有趣的是，这两个指令允许开发者在同一个文件中编写客户端和服务端代码，极大地简化了全栈开发的工作流程。
•Hooks 增强工具包：虽然 React 19 中没有引入新的核心钩子，但对现有的核心钩子进行了改进。useMemo 和 useCallback 现在提供增强的细粒度记忆功能，减少不必要的重新渲染。此外，useEffect 可以更好地控制效果何时运行，从而实现更清晰、更高效的副作用管理。

总结
React v16 总结
•Fiber节点的诞生
•React Hook的诞生
•Error Boundaries：引入了错误边界概念，允许React组件捕获其子组件树的JavaScript错误，并优雅地降级，而不是让整个应用崩溃。
•Portals：允许将子节点渲染到DOM树中的不同位置。
•Fragment：引入了<React.Fragment>（或简写为<>），使得可以返回多个元素而不需要额外的包装元素。
•移除React.PropTypes：将其移到了一个单独的包prop-types中。

React v17 总结
￮批处理会在事件处理函数中实现，一个周期内更新多次setState 只渲染一次。
￮事件池移除
￮事件委托 从 document 改为根dom
￮jsx() 函数替换 React.createElement()，不用引入react
￮React 副作用清理时机
￮底层事件的变动：onFocus 和 onBlur 事件已在底层切换为原生的 focusin 和 focusout 事件。onScroll 事件不再冒泡。

React v18 总结
￮Fiber架构的并发特性，被默认启用，在不影响用户体验的前提下，效地管理渲染任务，通过分片执行、优先级调度、中断恢复机制，有效避免了长时间阻塞主线程的问题。
￮批处理支持更多场景，比如 promise、原生事件、异步代码等
￮之前不支持Suspense的SSR流式渲染，服务器必须等待所有的数据加载完毕才能开始渲染HTML。
￮较多的并发模式 hook。

5. React 升级新版本需要考虑的点？可能会遇到的问题？具体的收益有哪些？
v17 问题点
•基于不同版本开发的 react组件 混搭问题？
•去除事件池后，现在在异步事件是可以获取到e.target的。之前在事件池中的合成事件是可复用并统一管理的，所以在事件处理函数同步执行后，便立即被释放内存了。
•react17 事件不再绑定document上，事件冒泡之前阻塞不了绑在document的原生事件，现在可以了。
•useEffect的清除函数是异步的了，通过 ref 获取对象可能为null了，因为已被销毁。
•useEffect新一轮副作用会等待所有组件的副作用清除函数全部执行后，现在针对所有组件，之前只针对单个组件。
v18 问题点
•批处理支持更多的场景，渲染次数会减少，会不会引发新的问题？
•升级到 v18，主要还是收益多吧
￮避免长时间阻塞主线程。
￮流式渲染ssr
￮并发hook
￮更多场景的批处理更新。

6.  React框架本身性能优化需要注意的点。
类式组件
•shouldComponentUpdate 生命周期：自行判断 props 和state 变化，尤其关注引用数据类型，确定是否需要更新。
•pureComponent 会对 state和 props 进行一个浅比较，所以引用数据类型地址未变，检测不出来内部数据变化。
￮普通组件：每当setState被调用，不论状态改变与否，组件都会重新执行render方法，从而可能重新渲染整个组件及其子组件。
￮pureComponent：只会对 state 和 props 发生变化的子组件 进行dom更新，而不会重新渲染整个组件。
￮针对 state里的引用数据类型，更新时记得用类似扩展运算符的方式，这样才能改变引用数据类型的指针。
 {...this.state, c : {...this.state.c, ...newobj } }
•immerjs 不可变数据类型的应用

函数组件
useCallback 是为了避免函数的重复声明，useMemo 是为了避免函数值的重复计算
React.memo包裹组件 与 pureComponent 类似的原理。
•没有用 useCallback包裹的函数，最多影响传入该方法的子组件的渲染，而不是直接影响组件本身的整体渲染。
￮没有涉及到state的，重复的函数声明，并不会影响到组件的渲染。
￮如果涉及到state，则最好用useCallback包裹。因为 state 的存在会使得函数的指针，在每次的渲染过程中一直变化，这样即使 state 的值本身没有变化，传入该方法的子组件，也会一直重复渲染。
￮最好不要在组件上写箭头函数，因为这样会每次声明一个新函数，函数指针的变化会让子组件的渲染变成一个必然行为，那么父组件 React.memo的效果岂不是会大打折扣呢？
•浅比较本身没有问题，因为深比较的性能损耗可能会大于默认重复渲染。

7. React 和 vue 的 diff算法 你知道多少？有什么区别？为什么要有key值，作用是什么？
1.三个原则：只处理同级节点，使用key值，节点类型不同需删除后新建，时间复杂度已经降到(n）。
都优先处理简单的场景【节点不需要移动的场景，dom节点变动的场景也确实是相对较少】
react是从左到右，找到第一个key不同的节点。
Vue2是双端diff算法，新老首尾共四次比较，其中两次是首部比首部，尾部比尾部，对应的是只更新节点内容的情况。
Vue3是快速diff算法，首先比较的是首尾两部分，只是不再考虑双端diff中比较新老节点首部与尾部的情况。
针对复杂的场景【需要节点移动的场景】
React 是用map实现根据key快速获取老节点，遍历新节点，如果 key值对应的老节点位置索引不是递增的，则给节点标记为placement。如果找不到对应 key 则为新建节点。
Vue2 是两者如果匹配就移动两边指针，如果是首尾部分匹配，则还需要移动节点，如果都不能匹配，则遍历老节点去找到key对应的节点，找不到则创建节点，最后都放到 旧前指针 的位置。当 新 / 老 节点两头的指针都已会合，与之相反的 新/ 老 节点 可能出现 首指针 > 尾指针 的情况，如果是新节点提前遍历结束，说明有多余的老节点要删除，反之就是需要新建更多的新节点。
Vue3的快速diff算法是根据新节点的位置索引，给老节点做标记，然后使用最长递增子序列算法计算出新节点中哪些节点是不需要移动的。最后，从后往前遍历新节点，在对应位置创建或者复用节点。
key值的关键作用
1.唯一标识元素
key为每个虚拟DOM节点提供了一个唯一标识，使得框架能够准确地区分列表中不同元素的身份，即使dom节点的位置发生改变。
2.优化Diff算法，避免了不必要的渲染，尽可能复用dom节点
在diff算法执行期间，框架利用key快速定位到哪些元素发生了移动、添加或删除，而不是盲目地比较所有节点。这大大减少了比较的复杂度，提高了更新DOM的效率。
3.节点不同则需删除后新建
key值相同 + 节点类型相同，就认为是可复用节点。如果节点类型不同，需删除后新建。主要是因为在DOM操作层面，不同类型的节点意味着它们代表了完全不同的元素结构，比如从<div>变为<span>，或是从静态文本变为一个组件，代码上难以理解，diff算法也会变的更复杂。这种变化无法通过简单的属性修改来完成，而是需要实际移除原有的DOM元素并插入一个新的元素来替代，以确保正确的HTML结构和预期的渲染效果。
8. 什么是虚拟DOM? 为什么都用虚拟DOM ? 虚拟DOM的操作起来比真实DOM更好吗？采用虚拟DOM相对于直接操作DOM有什么劣势呢？
虚拟DOM是什么？
•是一种编程抽象，用JavaScript对象树来模拟真实DOM结构。
•每个对象代表一个DOM元素，并包含该元素的属性、子元素等信息。
•提供了一种更高效的方式来处理dom的更新，减少了更新dom的成本。
为什么使用虚拟DOM？
1.性能优化：直接操作真实DOM会导致浏览器频繁地进行布局和绘制，这是很消耗资源的。虚拟DOM通过对比新旧状态生成的两棵虚拟DOM树，找出差异（diffing），然后只对实际DOM进行必要的最小化更新，减少了重排和重绘，从而提高了性能。
2.简化开发：开发者不需要关心底层DOM操作的复杂细节，可以更专注于描述UI应该呈现的样子，而不是如何一步一步修改DOM来达到这个样子，这使得代码更加可读和易于维护。
3.跨平台能力：因为虚拟DOM是基于JavaScript对象的抽象，它可以被用在任何支持JavaScript的平台上，促进了诸如React Native这样的跨平台开发框架的发展，让同一套代码可以在Web、iOS、Android等多个平台上运行。
虚拟DOM操作是否比真实DOM更好？
在多数情况下，是的。
•虚拟DOM允许框架批量处理DOM更改，减少不必要的操作，从而提升了性能。
•开发模式更简化，提声明式编程，让代码逻辑更清晰。
•提供了同套代码跨平台的能力。
虚拟DOM的劣势：
1.首次渲染成本：构建和比较虚拟DOM树会引入一定的开销，尤其是在初次渲染大量DOM节点时，可能比直接操作DOM要慢。
2.无法进行极致的优化：在某些特定场景下，比如性能要求极高的应用（如图形编辑器、大型数据表格等），手动优化DOM操作可能会带来更好的性能表现。虚拟DOM由于其通用性和抽象性，可能无法针对特定情况下做出最优的处理。
3.内存占用：维护虚拟DOM树会占用额外的内存空间。在特定高性能需求或对内存敏感的场景下，可能需要权衡潜在的开销。
9. React 类组件 和 函数组件的区别？各自的优劣势是什么？尤其是函数组件的劣势你是如何看待的。
函数组件
最大的优势
•组件逻辑复用更简单
•淡化生命周期的概念
•没有this指针的顾虑。
•更注重业务逻辑的复用与组合，适用于常见的前端业务开发。
•不适用组件库、定制化表格组件、注重生命周期的场景的开发。
对应的劣势
•hook useState控制状态还是不够优雅。
•只能在顶部声明，不能if语句和循环条件里声明hook
•useEffect需要手动填写依赖变量
•useCallback和 useMemo等性能优化也要考虑。
类组件
优点
适合需要基于类的特性、面向对象编程的业务场景，用setState处理状态还是更方便些。
例如，一个可扩展的基础表格组件，其他特定表格组件可以通过继承它并覆盖部分方法或属性来实现定制化。
适合生命周期使用较多的业务场景，生命周期函数更加完整，用起来也更直观一些。
•getDerivedStateFromProps() -> 无直接对应Hook，但可以使用 useEffect(() => { /* 更新衍生状态 */ }, [props]) 来根据props变化更新状态。
•shouldComponentUpdate() -> 通过比较新旧props和state来决定是否执行更新逻辑，可使用自定义的比较逻辑配合 useEffect 的依赖数组来模拟。
•getSnapshotBeforeUpdate() -> 无直接对应Hook，但可以在 useEffect 的清理函数中获取信息，或者在渲染逻辑中直接计算需要的快照数据。getSnapshotBeforeUpdate() 生命周期方法主要用于在DOM更新之前捕获一些信息，比如滚动位置或是表单输入的值，以便在更新后恢复这些状态。
•然而，useEffect 的执行时机确实是在 DOM 已经更新之后，因此直接在 useEffect 的清理函数或执行函数中尝试获取快照信息可能不是最佳实践。
a.使用Ref来存储快照信息：可以在渲染函数中使用 useRef 来保存需要的快照数据。由于 useRef 创建的引用值会在组件的整个生命周期内保持不变，你可以在渲染逻辑中直接更新这个引用的 .current 值来存储快照信息。这样，在下一个渲染周期开始之前，你就可以访问到上一次渲染时的快照数据。
b.自定义Hook：设计一个自定义Hook，它在渲染期间收集信息并在下一个useEffect执行前提供这些信息。这需要更复杂的管理，确保在适当的时机读取和传递快照数据。
c.使用Layout Effects：React 提供了 useLayoutEffect Hook，它的行为类似于 componentDidMount 和 componentDidUpdate，但它会在所有DOM变更完成后，但在浏览器绘制新界面之前同步执行。这意味着你可以在这个Hook中获取到最新的DOM布局信息，实现类似于 getSnapshotBeforeUpdate 的功能。
JavaScript
useLayoutEffect(() => {
  const scrollPosition = document.getElementById('someElement').scrollLeft;
  // 存储或使用 scrollPosition，它反映了更新前的DOM状态
  return () => {
    // 可以在此处执行DOM更新后的操作，但注意避免引起无限循环
  };
}, [/* 依赖项数组 */]);
处理错误的生命周期：getDerivedStateFromError 和 componentDidCatch 
缺点
考虑this指针问题
组件继承，难以复用业务逻辑。
高阶组件HOC和render props都不符合 React 的 组合理念
10. 列举一下你封装过或者抽离过 哪些 React hook？或者 vue3 拆过哪些组件？
总结
•Hook、组合式API 本质都是拆分代码 + 逻辑复用，提升代码的模块化、复用性，使得代码结构更加清晰，维护成本更低。
•合理地设计和封装Hook，可以大大减少重复代码，提高开发效率和代码质量，有利于工程代码的日常维护。
第一类：通用工具型Hook
这类Hook适用于多种场景，几乎可以在任何项目中找到其用武之地
•useOnce（只生效一次）
•useUpdateEffect（首次渲染时也就是挂载那一次不生效）。
•useDebounce: 延迟执行函数，常用于输入框的实时搜索功能。
•useThrottle: 限制函数调用频率，适合处理高频触发的事件如滚动事件。
•useLocalStorage: 简化本地存储操作，提供一种便捷的state管理方式。
•useResizeObserver: 监听DOM元素尺寸变化，用于响应式设计。
•useIntersectionObserver: 判断元素是否在视口内，常用于懒加载图片或动态加载内容。
第二类：业务场景Hook
这些Hook针对特定业务场景进行封装，旨在简化复杂逻辑，提高开发效率。
•usePagination: 封装分页逻辑，支持前端分页和后端分页。
•useForm: 针对表单操作，提供验证、提交、重置等功能。
•useModal: 管理模态框的状态和生命周期。
•useAuth: 处理用户认证和授权流程。
•useWebSocket: 封装WebSocket通信，方便实时数据交互。
•useAntdTable: 针对antd组件库的form和table组件封装，加入常用的loading效果、表格分页功能、首次加载时自动请求数据，返回 对应的tableProps 和 更新表格数据源 的方法，这样业务代码就简单很多，填写入参即可。【入参：请求方法，表格依赖数据项，tableProps】
•usePasteExcel：paste事件，对于 md、word、excel等样式 event.clipboardData?getData("text/html")，浏览器端都是拿到对应的html字符串, 可以用 new DOMParser().parseFromString('<div>123</div>','text/html') 转化成dom节点转化成二维数组。
•DynamicInnerHeightList：虚拟滚动的hook。
￮入参： rowRender渲染函数，total：数据总数，userHeight用户视野高度，estimateRowHeight： 每个item估测的行高，bufferSize：缓冲区个数，noDataContent: 无数据时展示内容。
￮实现原理：后面有
第三类：库封装型Hook
这类Hook是对第三方库的封装，旨在提供更友好、更一致的使用接口。
•比如我见过用 react query 作为请求方案，搭建整个项目的请求层，兼容v1 v2 BFF类型场景的接口。
￮一方面，可以简化请求数据的代码，将数据请求甚至数据处理的代码从业务代码里抽离出来。
￮另一方面，可以单独拎出来维护请求层，通过修改配置文件或打包时切换环境变量的方式去适配接口变化。
￮最后，react query自带的请求数据缓存策略，本质就是利用在浏览器内存缓存数据，挂载时立即请求，离线缓存，错误控制，重试机制等功能，也可以根据场景去统一配置或者单独配置。
•useAxios: 对axios的封装，提供统一的请求拦截器、响应拦截器和错误处理。
•useReactRouter: 封装React Router，简化路由相关操作。
•useSWR: 用于实现服务端渲染和客户端缓存的优化，提升首屏加载速度。
•useLodash: 提供lodash库的常用函数，如_.get, _.set, _.debounce等，以Hook形式使用。

usePasteExcel
JavaScript
import React, { useEffect, useState } from "react";

export type ExcelData = Array<Array<string>>;

/**
 * 获取剪贴板上已复制的excel内容，解析后返回一个二维数组的数据
 * @returns ExcelData
 */

const usePasteExcel = () => {
  const [excelData, setExcelData] = useState<ExcelData>([]);
  useEffect(() => {
    // 监听剪贴板【粘贴】事件
    const handler = (event: ClipboardEvent) => {
      event.preventDefault();
      // excel、word、md等的一些带样式格式的内容复制，在浏览器端统一是用html字符串的格式来表示的
      // https://developer.mozilla.org/zh-CN/docs/Web/API/ClipboardEvent/clipboardData
      // 支持 Chrome 58 以上
      const html = event?.clipboardData?.getData("text/html");

      if (!html) {
        return;
      }
      // 拿到带格式的excel内容,开始解析，这里使用DOMParser来解析html为DOM，方便后续的dom查找，这里也可直接正则匹配标签，不过稍显麻烦
      const domTree = new DOMParser().parseFromString(html, "text/html");

      // 在剪切板里excel的格式是使用html5的table标签来表示的
      const trNodes = domTree.querySelectorAll("table tr");

      // 将table的内容用二维数组收集起来
      const data = Array.from(trNodes).map((tr) => {
        return Array.from(tr.querySelectorAll("td")).map((td) => {
          return td.textContent || "";
        });
      });
      setExcelData(data);
    };

    document.addEventListener("paste", handler);
    return () => {
      document.removeEventListener("paste", handler);
    };
  }, []);
  return {
    excelData,
  };
};

export default usePasteExcel;

防抖 hook
JavaScript
import { useState, useCallback, useEffect, useRef } from 'react';
export default function useDebounce(fn, delay = 1000, dep = []) {
    const { current } = useRef({ fn, timer: null });
    useEffect(function () {
        current.fn = fn;
    }, [fn]);

    useEffect(() => {
        return () => {
            clearTimeout(current.timer);
        } 
    }, [])
    
    return useCallback(function (...args) {
        if (current.timer) {
            clearTimeout(current.timer);
        }
        current.timer = setTimeout(() => {
            current.fn.call(this, ...args);
        }, delay);
    }, dep)
}

节流 hook
JavaScript
import { useState, useCallback, useEffect, useRef } from 'react';

export default function useThrottle(fn, delay = 1000, dep = []) {
    const { current } = useRef({ fn, timer: null });
    useEffect(function () {
        current.fn = fn;
    }, [fn]);

    useEffect(() => {
        return () => {
            clearTimeout(current.timer);
        }
    }, [])

    return useCallback(function f(...args) {
        if (!current.timer) {
            current.timer = setTimeout(() => {
                current.fn.call(this, ...args);
                delete current.timer;
            }, delay);
        }
    }, dep);
}

export default function useThrottle(fn, delay = 1000, dep = []) {
    const { current } = useRef({ lastTime: 0, fn });
    useEffect(function () {
        current.fn = fn;
        current.lastTime = 0;
    }, [fn]);

    useEffect(() => {
        return () => {
            clearTimeout(current.timer);
        }
    }, [])

    return useCallback(function f(...args) {
        let curTime = Date.now();
        if (curTime - lastTime >= delay) {
            lastTime = Date.now();
            current.fn.apply(this,args)
        }
    }, dep);
}
 useOnce
JavaScript
import { useRef } from 'react';

export default function useOnce(fn: Function) {
    const isExecuted = useRef(false);
    if (!isExecuted.current) {
        isExecuted.current = true;
        fn();
    }
}

useUpdateEffect
JavaScript
import React, { useEffect, useRef } from "react";
/**
 * 只在更新时运行的effect  实现来自官方推荐思路:
 https://react.docschina.org/docs/hooks-faq.html#can-i-run-an-effect-only-on-updates
 * @param effectFn
 * @param deps
 */
export default function useUpdateEffect(
  effectFn: React.EffectCallback,
  deps: any[] = []
) {
  
  const isMounted = useRef(true);

  useEffect(() => {
    if (isMounted.current) {
      isMounted.current = false;
    } else {
      return effectFn();
    }
  }, deps);
}

useAntdTable
JavaScript
/* eslint-disable react-hooks/exhaustive-deps */
import { useState, useEffect, useRef } from 'react';
import { TableProps } from 'antd';
import useUpdateEffect from './useUpdateEffect';
export interface PageParams {
  pageNum: number;
  pageSize: number;
}

export type RequestHandler<RecordType> = (
  pageParams: PageParams
) => Promise<{ data: Array<RecordType>; total: number }>; // 请求数据的方法

type Options = {
  isInit?: boolean; // 是否在初始化时候默认触发一次请求 默认为true
};

export interface Result<RecordType> {
  tableProps: TableProps<RecordType>; // 表格属性
  resetTable: () => void; // 手动重置表格 页码会重置为第一页
  reloadTable: () => void; // 手动刷新当前页的表格数据
}
/**
 * @description 方便使用antd表格，提供了分页自动处理功能
 * @param request 请求方法。 需返回一个结果包含总页数及列表数据的Promise实例
 * @param deps 表格重置的依赖项。 任意依赖项发生变化，重置页码为1，自动调用request方法，灵感来源于react的useEffect，区别是react是依赖变化运行副作用，这里是重置表格数据。
 * @param tableProps antd表格props，内部会去自动合并
 * @param Options 自定义选项 {isInit:true;} 是否在初始化时候默认触发一次请求 默认为true
 * @returns Result<T>
 */

export default function useAntdTable<T = object>(
    request: RequestHandler<T>,
    deps: any[] = [],
    tableProps: TableProps<T> = {},
    options?: Options,
): Result<T> {
    const [dataList, setDataList] = useState([]); // 列表数据
    const defaultPageSize = (tableProps?.pagination && tableProps?.pagination.defaultPageSize) || 10;
    const [pageParams, setPageParams] = useState({
        pageNum: 1,
        pageSize: defaultPageSize,
    }); // 当前页码及每页条数

    const [total, setTotal] = useState(0); // 数据总条数
    const [isFetching, setIsFetching] = useState(false); // 是否处于请求中
    const isMounted = useRef(true); // 标示下是否是首次初始化渲染

    const { isInit = true } = options || {};

    const fetchData = async () => {
        try {
            setIsFetching(true);
            // eslint-disable-next-line no-shadow
            const { data, total } = (await request(pageParams)) || {};

            setDataList(data || []);
            setTotal(total || 0);
        } catch (error) {
            setDataList([]);
            throw Error(error)
        }

        isMounted.current = false;
        setIsFetching(false);
    };

    const stopInitReq = useRef(isInit === false);

    // 分页请求
    useEffect(() => {
        if (stopInitReq.current) { // isInit选项为true,禁止初始化时候去请求列表
            stopInitReq.current = false;

            return;
        }

        fetchData();
    }, [pageParams]);

    // 依赖项变化，重置分页 (只在更新场景才调用)
    useUpdateEffect(()=>{
        setPageParams({
            ...pageParams,
            pageNum: 1,
        });
    },deps)

    const onChange = ({ current, pageSize }) => {
        setPageParams({
            pageNum: pageSize === pageParams.pageSize ? current : 1,
            pageSize,
        });
    };

    return {
        tableProps: {
            ...tableProps,
            loading: isFetching,
            onChange,
            dataSource: dataList,
            pagination: tableProps.pagination !== false && {
                ...tableProps.pagination,
                current: pageParams.pageNum,
                pageSize: pageParams.pageSize,
                total,
            },
        },
        resetTable() {
            setPageParams({
                ...pageParams,
                pageNum: 1,
            });
            setTotal(0);
            setDataList([]);
        },
        reloadTable() {
            fetchData();
            setTotal(0);
            setDataList([]);
        },
    };
}

11. react 与 vue 的区别，框架应该如何选择? vue3 的 组合式 api 与 react 的主要区别是什么？
日常开发
React
•语法：
￮jsx语法，是JS 编程的能力延伸
￮将用户界面抽象成可复用的组件，通过组件的嵌套和组合来构建完整的应用程序
￮自由度比较高
•编程思想
￮函数式编程（Functional Programming）
▪将组件的渲染过程，视为函数的执行过程。将逻辑分解为一系列的函数。
•推荐 - Hook ：尽可能分开，管理各自状态，组合到一起。
•不推荐-类组件：因为组件继承不符合函数式编程的思想，复用逻辑也比较复杂。
•全局状态：mobx、redux、zustand、dva等集中式状态管理。
￮单向数据流
▪数据自上而下传递，子组件通过 props 接收数据，通过回调函数向上传递事件。
Vue:
•语法：
￮用 类似html的模版语法和 设计好的一些指令方式去定义组件行为和结构。
•编程思想：
￮响应式编程（Reactive Programming）是一种面向数据流和变化传播的编程范式。
￮声明式开发
▪只需要描述数据和计算之间的关系。
▪vue内部实现一套数据响应式系统，自动跟踪依赖，数据变化时自动更新视图，简化了事件处理、数据管理和异步编程等代码。
￮组合式 API： 提供了创建和管理响应式数据的api，可以实现复杂的自定义响应式逻辑，逻辑组合复用起来也简单。
￮v-model 的双向绑定：这使得表单处理和双向数据交互更加便捷。
￮vuex、pinia等集中式状态管理

源码实现
React
•一个构建用户界面的js库，是运行时框架。源码不涉及编译的部分，只是把 jsx 编译的结果抽象成 Fiber节点。所以 React 的性能优化都是更偏向运行时优化。
￮React 的 Fiber 架构提供了细粒度的任务调度和中断机制，使得 React 可以在更细粒度的级别上控制渲染工作。
￮Fiber 将渲染工作拆分为多个单元，并通过时间切片（time slicing）机制在多个帧之间分配渲染任务，避免长时间阻塞主线程。
￮Fiber 允许 React 中断和恢复工作，以便在需要的时候优先处理高优先级的更新（如用户输入），提供更流畅的用户体验。

Vue
•渐进式框架、编译时框架。
•Vue3 偏向编译时优化。
￮按着vue的模版语法写，性能优化就是自动挡，vue编译器自会处理。
￮模板编译、静态节点的提升【在编译阶段优化静态部分，减少运行时的开销】，提高渲染的效率。
￮响应式系统：通过依赖追踪和调度器在数据变化时自动触发视图更新。
￮批量更新机制：例如，使用 nextTick 和 Promise 微任务来调度更新，并在同一事件循环内合并多次数据变化，减少不必要的渲染次数。


为什么 React 需要 Fiber 架构？vue 不需要？
总结：
React 需要 Fiber 架构来解决复杂应用中的性能瓶颈和扩展性问题。
Vue 通过其高效的响应式系统和编译时优化，在大多数场景下已经能提供良好性能。

Fiber 架构通过以下几个方面来改进 React 的性能：
1.时间切片（Time Slicing）：Fiber 允许 React 将渲染工作分成小块，并将这些小块的工作分散在多个帧中执行。这种方法有助于保持界面的流畅性，避免长时间的阻塞渲染导致用户界面卡顿。
2.可中断的渲染（Interruptible Rendering）：Fiber 使得 React 的渲染过程可以在必要时被中断，优先处理更紧急的任务。这对于处理高优先级任务（如响应用户输入）非常重要。
3.更好的错误处理（Better Error Handling）：Fiber 结构使得 React 能够在渲染过程中捕获并处理错误，而不会导致整个应用崩溃。
4.灵活的更新机制（Flexible Update Mechanism）：Fiber 提供了一种灵活的机制来协调不同类型的更新（例如，低优先级的后台数据更新和高优先级的用户输入响应），从而提高应用的响应速度和性能。
Vue 不需要 Fiber 架构的原因主要有以下几点：
1.更新机制的不同
￮Vue 使用的是基于响应式系统的更新机制，当数据变化时，通过依赖追踪和依赖收集来自动计算和更新需要变化的部分。
￮Vue 的这种响应式系统天然地减少了不必要的渲染和更新，从而提升性能。
￮使用 nextTick 和 Promise 微任务来调度更新，并在同一事件循环内合并多次数据变化，减少不必要的渲染次数。
2.虚拟 DOM 的不同实现
￮Vue 的虚拟 DOM 实现相对较轻量，且 Vue 3 引入了编译时优化（compile-time optimization），可以在编译阶段优化静态部分，从而减少运行时的开销。
3.渐进式框架的设计
￮Vue 是一个渐进式框架，可以根据项目的需要逐步引入不同的特性和功能。
￮可以避免在简单项目中引入不必要的复杂性和开销。
4.生态系统和使用场景
￮Vue 的设计理念更倾向于简单易用，并且多用于中小型项目或单页应用。
￮React 被设计成可以处理大型复杂应用，在需要处理复杂场景时，React 需要一个更强大、更灵活的架构。


diff算法
React 、Vue2、Vue3 的 diff算法 是基于前端业务场景做的优化，所以有很多相似之处。
1.只处理同级节点，用 key值 作为 新老节点 的 标识符，节点类型不同需删除后新建，时间复杂度已经降到(n）。
2.优先处理简单的场景，也就是节点不需要移动的场景，dom节点变动的场景也确实是相对较少。
react是从左到右，找到第一个key不同的节点。
Vue2是双端diff算法，新老首尾共四次比较，其中两次是首部比首部，尾部比尾部，对应的是只更新节点内容的情况，不涉及节点移动。
Vue3是快速diff算法，首先比较的是首尾两部分，只是不再考虑双端diff中比较新老节点首部与尾部的情况。

React diff算法
第一轮遍历：是为了找出可复用的节点。
当 key相同，type不同 时，会将老的Fiber节点标记为DELETION，但不会结束遍历。
当出现 key不同、新 Fiber 结点遍历完、老 Fiber 结点遍历完 时，第一轮遍历宣告结束。
此时会出现4种情况。
第二轮遍历：是为了处理剩下的节点。
React 将 还未处理的 oldFiber 节点存入了 以 “自身节点的key 为 key，oldFiber本身 为 value” 的 Map中。
lastPlacedIndex: 最后一个 可复用的oldFiber 的位置索引。
•oldFiber.index:  以 key值作为索引，对应的 oldFiber节点的位置索引，通过 map 快速获取。
•当 oldFiber.index >= lastPlacedIndex 时，说明 当前遍历的 newFiber 节点 是 可复用的 oldFiber 节点，并且
在 oldFiber 链表的 相对位置是靠后的，所以不需要移动位置，此时 lastPlacedIndex 需要 更新 为 oldFiber.index。
•当 oldFiber.index <  lastPlacedIndex 时，说明 对应的 oldFiber 节点 在 oldFiber 链表的相对位置是靠前的，
需要标记为 Placement，表明此节点发生过移动，此时 lastPlacedIndex 无需更新。
•如果 map 里 找不到 newFiber 的 key 值，则直接创建新增节点。
举例：【1,2,3,4】->【1,4,2,3】
第一轮：lastPlacedIndex：最小值，oldFiber.index：1，lastPlacedIndex = 1，靠后，不需要移动
第二轮：lastPlacedIndex：1，oldFiber.index：4，lastPlacedIndex =4 ，靠后，不需要移动
第三轮：lastPlacedIndex：4，oldFiber.index：2， lastPlacedIndex不变，节点靠前，标记下移动位置
第四轮：lastPlacedIndex：4，oldFiber.index：2， lastPlacedIndex不变，节点靠前，标记下移动位置

针对复杂的场景，需要节点移动的场景。
React 
•用map实现根据key快速获取老节点，遍历新节点。
•如果 key值对应的老节点位置索引不是递增的，则给节点标记为placement。
•否则就更新【最后一个可复用的oldFiber 的位置索引】这个需要比较的变量。
•如果找不到对应 key 则为新建节点。
•比如，1、2、3、4变成了 1、4、2、3、5 ，1 和 4 就是可以复用的，2 和 3是需要移动的，5是新增的。

Vue2 是两者如果匹配就移动两边指针。
•如果是首尾部分匹配，则还需要移动节点，如果都不能匹配，则遍历老节点去找到key对应的节点，找不到则创建节点，最后都放到 旧前指针 的位置。
•当 新 / 老 节点两头的指针都已会合，与之相反的 新/ 老 节点 可能出现 首指针 > 尾指针 的情况。
•如果是新节点提前遍历结束，说明有多余的老节点要删除，反之就是需要新建更多的新节点。

Vue3的快速diff算法
•根据新节点的位置索引，给老节点做标记。
•用最长递增子序列算法计算出新节点中哪些节点是不需要移动的。
•最后，从后往前遍历新节点，在对应位置创建或者复用节点。

React 为什么不优化diff算法
react 团队 受制于 Fiber 架构 没有反向指针的困扰，要想实现双端diff 需要复制整个节点，并且觉得需要双端diff优化的情况也不是经常的，所以暂时采用 adding everything to a Map 这种方法。

框架生态

12. vue2 与 vue3 的主要区别是什么？
•响应式实现：
￮Vue3 
▪响应式系统基于 ES6 的 Proxy 和 Reflect API 实现的。
▪拦截对象的任何操作，提供了更强大和灵活的响应式系统。
▪Reactive API 被设计为独立于 Vue 核心的，使用更加灵活。开发者可以在 Vue 之外的环境中使用 Vue 的响应式系统。
￮Vue2 
▪响应式系统是通过 Object.defineProperty 实现的。
▪无法检测到对象属性的添加或删除。
•开发思想
￮组合式 API，这是一种新的代码组织方式。与 Vue2 的选项式 API 相比，组合式 API 提供了更好的逻辑复用和代码组织
•源码实现结果
￮Vue3 ：源码的架构改进和性能优化，模块化的组织方式，更高效的运行性能，更小的打包体积。
￮Tree-shaking 特性得以实现，进一步优化了打包体积，只将用到的特性打包进最终的代码中。
•TypeScript 支持
￮Vue3 在源码级别对 TypeScript 提供了更好的支持。这使得开发者可以在编写 Vue 应用时更好地利用 TypeScript 的静态类型检查，提高代码的可维护性和可读性。
•其他新特性
￮引入了许多新特性，如 Fragments、Teleport 等。
￮ Teleport 组件：提供了一种将组件模板的一部分“传送”到存在于该组件 DOM 层次结构之外的 DOM 节点的能力。假设我们想在用户点击按钮时在子组件上显示通知。我们可以在 Vue 应用程序的根 #app 元素之外的完全不同的 DOM 树中渲染此警报（将采用模态的形式。

13. 说说 vue 和 react 的完整生命周期？如果包含子组件，对应的生命周期是什么顺序？
Vue 3 生命周期
1.setup():  是在组件实例创建之前被调用的，在这里定义响应式数据、计算属性、Effect Hooks等，这时访问不到相应dom，替代 vue2 的 beforeCreated 和 created。
a.子组件的 setup()被调用。
2.onBeforeMount(): 组件挂载到DOM之前调用。此时可以访问到DOM，但DOM尚未被实际插入到页面。
a.子组件挂载到DOM之前调用 onBeforeMount()
b.子组件挂载完成，onMounted()
3.onMounted(): 组件挂载到DOM后调用。此时DOM已插入页面，可以进行DOM操作或访问实际的DOM元素。
4.onBeforeUpdate(): 组件数据变化导致的更新发生之前调用。可以用来比较新旧props或state。
a.子组件更新前：onBeforeUpdate()
b.子组件更新完成：onUpdated()
5.onUpdated(): 组件数据变化导致的DOM更新完成后调用。此时可以访问更新后的DOM。
6.onBeforeUnmount(): 组件即将被卸载之前调用。适合做清理工作，如取消定时器、移除事件监听器。
a.子组件卸载前：onBeforeUnmount()
b.子组件卸载完成：onUnmounted()
7.onUnmounted(): 组件已经被卸载后调用。所有解绑和清理工作都应该在此时完成。
实际上，从父组件的角度直接描述子组件的生命周期钩子调用并不准确，因为父子组件的生命周期是独立的，每个组件维护自己的状态。
正确的理解应该是：当父组件经历特定生命周期阶段时，如果涉及到子组件（比如挂载或更新），那么相应的子组件也会执行它们的生命周期钩子，但这些是并行的概念，而非直接的父子调用关系。

8.router相关的生命周期
a.全局前置守卫 (router.beforeEach 或 router.beforeResolve)：在路由切换前执行，适合做权限验证、路由拦截等操作。
b.全局解析守卫 (router.afterEach)：在每次路由导航完成（无论是成功还是失败）后触发，适合做页面标题修改、滚动行为管理或错误处理。
c.组件内的守卫：如 beforeRouteEnter, beforeRouteUpdate, 和 beforeRouteLeave，这些可以直接在组件内部定义，用来处理特定路由的进入、更新或离开逻辑。
9.onActivated、onDeactivated ：适用于 <keep-alive> 包裹的组件。当组件被缓存并重新激活时（比如，用户从其他页面导航回来），onActivated 钩子会被调用。这个钩子可以用于执行一些组件恢复时需要的初始化操作，比如恢复组件的滚动位置、重新启动定时器等，而不必在每次组件创建时都执行这些操作。
10.onErrorCaptured ：错误捕获
JavaScript
  <ErrorBoundary @error="handleError">
17    <button @click="throwError">Throw Error</button>
18    <!-- 其他可能抛错的子组件 -->
19  </ErrorBoundary>
11.全局绑定 window
JavaScript
// 注册全局错误处理器
app.config.errorHandler = function(err, vm, info) {
8  // err 是错误对象
9  // vm 是当前Vue实例
10  // info 是 Vue 特定的错误信息，比如生命周期钩子或事件处理器的名字
11  console.error('Global Error:', err, info);
12  // 这里可以发送错误报告到服务器，或者执行其他必要的错误处理逻辑
13};
14

React 18 生命周期
1. 挂载阶段 (Mounting)
•constructor(): 当一个新的React类组件实例被创建时，构造函数会被调用。这是设置初始state和绑定this的好时机。
•getDerivedStateFromProps(): 在组件实例被渲染之前和更新时被调用，允许你基于props来计算state。但这个方法在现代React中不常推荐使用。
•render(): 渲染函数被调用以生成React元素，描述应该出现在DOM中的什么。如果这个过程中包含了子组件，那么子组件也将开始它们的生命周期，从各自的constructor()、getDerivedStateFromProps()（如果存在）、直至render()。
•componentDidMount(): 在组件已经渲染到DOM后立即调用。这时可以执行副作用操作，如设置定时器、发起网络请求、添加事件监听器等。同样，如果父组件的render()方法中渲染了子组件，子组件的componentDidMount()也会在此之后执行，完成它们自己的DOM操作需求。
2. 更新阶段 (Updating)
•getDerivedStateFromProps(): 在组件接收新的props或state更新之前再次被调用，允许基于新的props重置state。
•shouldComponentUpdate(): 决定组件是否需要重新渲染。返回true则继续更新流程，false则跳过后续的更新过程，两个入参是下一次渲染时的props和state。
•render(): 如果组件确定需要更新，将再次调用render方法来生成新的React元素。
•getSnapshotBeforeUpdate(): （可选）在DOM更新之前被调用，可以获取一些信息（如滚动位置），这些信息可以在componentDidUpdate中使用。
•componentDidUpdate(): 在组件完成更新并重新渲染到DOM之后调用。适合进行DOM操作或网络请求的后续处理。如果子组件因props变更而更新，它们也将经历自己的更新周期流程。
3. 卸载阶段 (Unmounting)
•componentWillUnmount(): 在组件将要卸载和销毁之前立刻被调用。适合进行清理工作，例如清除计时器、取消网络请求或移除事件监听器。当父组件卸载时，其所有的直接子组件也会依次执行自己的componentWillUnmount()，确保资源得到妥善清理。
4. 兜底阶段：
•getDerivedStateFromError渲染备用UI
•使用componentDidCatch打印错误信息。

14. react 、vue 的 所有组件通信方式？回答尽可能多。
react
基本通信方式
•props、state、回调函数
•兄弟通信，状态提升
•ref调用子组件方法
•context跨层级传输数据
•redux全局状态管理
•事件总线的包
•props.children属性，插槽
•React.Portal
•localStorage、sessionStorage、cookie、indexDB

1.Props（属性）：父组件可以通过将数据和函数作为属性传递给子组件来实现通信。子组件可以通过 this.props 来访问这些属性。这是 React 中最常见的一种通信方式。
2.State（状态）：组件内部可以通过 state 来管理自己的状态。父组件可以通过 props 将状态传递给子组件，以便子组件更新自身的状态。
3.回调函数：父组件可以将回调函数作为属性传递给子组件，子组件可以调用这些函数来通知父组件发生了某些事件或行为。
4.状态提升：通常是兄弟组件间，将子组件所需状态提升到父组件管理，通过父组件间接完成兄弟组件的通信。
5.Ref ：ref 是用于访问 DOM 元素，调用子组件实例方法。【forwardRef是一种用于向子组件传递 ref 的技术 ,useImperativeHandle、forwardRef结合获取函数组件的子方法】
6.Context（上下文）：Context 提供了一种在组件树中共享数据的方法，避免了通过多层嵌套传递 props 的麻烦。父组件可以在 Context 中设置数据，子组件可以在需要时从 Context 中获取数据。
7.Redux ：使用状态管理库可以将共享的状态集中管理，不管组件层级如何，都可以轻松访问和更新状态。
6.Event Bus（事件总线）：可以创建一个全局的事件总线，允许组件通过触发和监听自定义事件来进行通信。
7.Children 属性：父组件可以通过 props.children 访问这些内容，类似于vue的插槽，并决定如何在自己的渲染逻辑中展示这些子元素。
8.Portal：使用 Portal 可以将组件渲染到 DOM 树中的任何位置，不受组件嵌套层级的限制。
9.浏览器支持：localStorage、sessionStorage、cookie、indexDB

逻辑复用方式
1.自定义 Hooks：可以创建自定义的 React Hooks 来共享逻辑和状态，然后在多个组件中使用这些 Hooks。
2.HOC ：高阶组件是一个函数，接受一个组件并返回一个新的增强过的组件。它可以用来封装一些通用的逻辑，从而实现组件的复用。
3.render props ：这个函数负责“渲染”某些内容或者决定如何渲染。这种方法使得组件能够将内部状态或行为作为参数传递给父组件定义的函数，从而实现组件的高度可复用性和逻辑抽象。

Vue
Vue通信方式
1.Props（属性）：
类似于React，Vue中父组件可以向子组件传递数据通过Props。子组件通过props选项声明它预期接收的数据。
2.自定义事件（emit）：
子组件可以通过 $emit 触发事件，父组件则可以在模板中使用 v-on 或 @ 监听这些事件，实现从子到父的通信。
3.Vuex：
Vuex 是Vue的官方状态管理模式，用于管理应用程序中多个组件共享的状态。类似于Redux在React中的作用，Vuex提供了一个集中的存储来保存应用状态，并允许组件通过一系列可预测的方式改变和访问状态。
4.Provide / Inject：
这对选项主要用于祖先组件向后代组件注入数据，适用于不确定层次关系的组件间通信，类似于React中的Context API，但更适用于祖先到后代的单向数据流。
5.Slots：
Vue的插槽（Slot）机制允许你在一个组件内部定义内容分发的占位符，父组件可以插入任意内容到这些占位符中，常用于实现内容的定制化和组件的复用性，也是一种通信形式，尽管它更多关注结构而非数据。
6.Event Bus：
虽然不是Vue官方推荐的做法，但在Vue社区中，创建一个全局的Event Bus（事件总线）来传递事件是常见的非父子组件间通信手段。通过Vue实例作为事件中心，发布-订阅模式进行通信。
Vue逻辑复用方式
1.Mixins：
Mixins 是Vue中实现代码复用的一种方式，可以包含组件数据、计算属性、方法等，然后在其他组件中混入这些功能。
2.Composition API（Vue 3）：
Vue 3 引入的Composition API通过组合函数来组织和复用逻辑，允许开发者更灵活地管理和复用组件的逻辑和状态，替代或补充Options API。
3.Custom Directives：
自定义指令可以让你在DOM元素上注册自定义行为，虽然主要是操作DOM，但在某些场景下也可以实现特定的逻辑复用。

15. React 和 Vue 在组件销毁后，如何确保不会存在内存泄漏问题 或者清除相关的事件操作？
确保在组件卸载时清理所有副作用是防止内存泄漏的关键。
•定时器清除
•不需要的内存置为null
•清除闭包函数
•解除订阅的事件
•清除绑定的监听事件。
16. 有用过迭代器吗？它的作用是什么？说说生成器函数
迭代器
在JavaScript中，迭代器是一种提供了next()方法的对象，这个方法返回一个形如{value: ..., done: ...}的对象，用于遍历集合。
JavaScript
const myObject = {
    data: [1, 2, 3, 4],
    [Symbol.iterator]: function() {
        let index = 0;
        const data = this.data;
        return {
            next: function() {
                if (index < data.length) {
                    return { value: data[index++], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
};
// 使用自定义迭代器遍历对象
for (const value of myObject) {
    console.log(value); // 输出 1 2 3 4
}

JavaScript
const myIterator = {
    data: [1, 2, 3, 4],
    index: 0,
    next() {
        if (this.index < this.data.length) {
            return { value: this.data[this.index++], done: false };
        } else {
            return { value: undefined, done: true };
        }
    }
};
let result = myIterator.next();
while (!result.done) {
    console.log(result.value); // 输出 1 2 3 4
    result = myIterator.next();
}

生成器
生成器是创建迭代器的便捷方式。
JavaScript
function* myGenerator() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}
const iterator = myGenerator();
let result = iterator.next();
while (!result.done) {
    console.log(result.value); // 输出 1 2 3 4
    result = iterator.next();
}

生成器示例解读
JavaScript

异步操作实现
JavaScript
function fetchData(url) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`Data from ${url}`);
        }, 1000); // 模拟异步操作
    });
}

function* asyncGenerator() {
    const data1 = yield fetchData('url1');
    console.log(data1); // 输出：Data from url1
    const data2 = yield fetchData('url2');
    console.log(data2); // 输出：Data from url2
    const data3 = yield fetchData('url3');
    console.log(data3); // 输出：Data from url3
}

// 执行生成器的异步操作
function run(generator) {
    const iterator = generator();
    function process(result) {
        if (result.done) return;
        result.value.then(data => {
            process(iterator.next(data));
        });
    }
    process(iterator.next());
}
run(asyncGenerator);

17. axios的底层原理是什么？axios、fetch、xhr有什么区别？还有哪些可以发送请求的方式？
axios
￮Axios是一个基于Promise封装的HTTP客户端。
￮XHR是浏览器提供的用于在客户端与服务器进行异步通信的API，用于实现AJAX技术。
￮在浏览器环境中，axios会使用XMLHttpRequest（XHR）对象来发送HTTP请求。
￮在Node.js环境中，axios则会使用Node.js内置的http模块来发送HTTP请求。
Fetch 与 xhr 区别
￮XHR 是使用传统的事件监听方式，但 axios 库进行一系列的封装。使得它可以支持 promise写法，有请求拦截器、响应拦截器、取消请求、全局错误处理、onDownloadProgress、onUploadProgress事件等功能的支持。
￮Fetch是浏览器原生提供，基于Promise的现代化API，使异步请求的处理更加直观。处理HTTP请求，虽然浏览器兼容性没有更早的xhr好，但也还行。
￮fetch的同源请求，默认不携带cookie。
￮返回响应结果，需要自己转化为json()，还是text()，图片是blob()。
￮针对服务器状态码 404、502这种类型的错误，会认为是正确的，只有发生网络异常等错误才会报错。
￮axios：对于基于xhr 的 progress 事件 实现上传和下载进度条。
￮fetch：可以支持流式传输，通过ReadableStream接口处理响应体。用ReadableStream和Response对象来监视下载进度，但是监视上传进度并不直接支持。
JavaScript
fetch('/download')
  .then(response => {
    const totalSize = +response.headers.get('content-length');
    let downloaded = 0;

    const reader = response.body.getReader();

    return new ReadableStream({
      start(controller) {
        function pump() {
          reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            downloaded += value.byteLength;
            const progress = Math.round((downloaded / totalSize) * 100);
            console.log(`Download Progress: ${progress}%`);
            pump();
          });
        }
        pump();
      }
    });
  })
  .then(stream => new Response(stream))
  .then(response => response.text())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

其他方式
jsonp、react query、websocket、sse、webrtc
•JSONP：JSONP（JSON with Padding）是一种跨域请求数据的技术。通过动态创建<script>标签，将请求数据包装在回调函数中返回，从而实现跨域数据请求。
•React Query：React Query是一个React库，用于管理应用程序中的数据，并处理数据的获取、缓存、更新等。它提供了一种声明式的方式来发起数据请求，并处理数据的缓存和状态管理。
•GraphQL：GraphQL是一种用于API的查询语言，可以用于客户端向服务器发送数据查询请求。与传统的RESTful API相比，GraphQL可以更精确地指定所需的数据，并且可以一次性获取多个资源的数据。
•WebSocket：WebSocket是一种在单个TCP连接上进行全双工通信的协议。它可以实现客户端和服务器之间的实时数据传输，适用于需要实时性的应用场景，如聊天应用、实时游戏等。
•Server-Sent Events (SSE)：Server-Sent Events是一种在客户端和服务器之间单向发送事件的技术。它允许服务器端推送数据到客户端，适用于需要实时推送数据的应用场景，如实时通知、实时更新等。
•WebRTC：WebRTC（Web Real-Time Communication）是一种浏览器原生支持的实时通信技术，可以在浏览器之间直接传输音频、视频和数据。它适用于实时音视频通话、视频会议等应用场景。

18. vue 的 nextTick 是什么？如何实现的？react如何平替这一功能？
nextTick实现原理
在Vue.js中，nextTick是一个异步执行函数，用于在DOM更新完成后执行特定的回调函数。
主要作用：是在当前数据变化已经完成，并且DOM已经更新后执行一些操作，例如访问更新后的DOM元素或执行一些操作依赖于DOM状态的逻辑。
实现nextTick的原理：是利用JavaScript的事件循环机制，将回调函数放入下一个事件循环中执行，用微任务（microtask）实现，确保在DOM更新完成后执行。
React 实现类似效果
React 平替 nextTick 的功能可以通过 setState 方法的回调函数来实现。当 setState 被调用后，React 会在组件状态更新后立即执行回调函数。
这样就可以确保在DOM更新后执行特定的操作，类似于Vue.js中nextTick。
用useLayoutEffect钩子函数，dom更新后触发。

19. React class 组件的 this.setState 是同步的，还是异步的？获取不到最新的值怎么办？react 类组件和函数组件的setState内部流程，多次setState之后render几次？
一文搞懂React 的 setState 机制 - 掘金
•setState这个方法在调用的时候是同步的，但是引起React的状态更新时的表现可能是异步的 。
￮【你不用写await或.then】
￮【setState第一个参数是一个对象或一个函数，而第二个参数是一个回调函数，类似于vue的nextTick，class的this.setState提供第二个参数，就是用来监听state里面数据的更改，当数据更改完成，调用回调函数，获取到更新后的数据】
•因为setState是一个异步的过程，所以执行setState之后不能立刻更改state里面的值。
•setState设计为异步，可以显著的提升性能。
￮如果每次调用setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的。
￮最好是获取到多个更新后，进行批量更新，对应的 就是 react v18版本的全面开启批更新机制。
￮在 react v18版本之前。
▪在 react组件生命周期、合成事件之外的操作，比如 promise、DOM原生事件、setTimeout定时器操作，react的状态更新也表现为同步的操作。
▪对应的结果是，它不仅能立即拿到更新后的值，而且不会有覆盖现象。
源码原理
•React 的 setState 方法允许更新组件的状态后自动触发渲染，但setState 的行为会根据其被调用的上下文而变化。
•具体来说，React 会根据一个内部变量 isBatchingUpdates 来决定是立即更新 this.state ，还是将更新操作放入一个队列中，稍后再进行。
•默认情况下，isBatchingUpdates 是 false，这意味着 setState 会同步更新 this.state。
￮在 React 调用事件处理函数和生命周期函数之前会调用 batchedUpdates 函数时，isBatchingUpdates 会被设置为 true。
￮因此，由 React 控制的事件处理过程中的 setState 不会同步更新 this.state。
•相反，它会将需要更新的组件添加到 dirtyComponents 数组中，稍后再进行更新。这就是所谓的 “异步更新”。
•只有当 isBatchingUpdates 为 false 时，也就是不处于批量更新模式时。React 才会对所有队列中的更新执行 batchedUpdates 方法，这被称为 “同步更新”。
•在 React 18 中，所有的更新都会自动进行批处理，无论它们来自何处。也就是说发生在 promise、setTimeout、原生事件处理函数中，React 都会将多次更新合并成一次更新。最小化不必要的渲染，降低了渲染次数，代表提高了性能。
使用原则
•如果新状态不依赖于原状态【使用对象方式】
•如果新状态依赖于原状态 【使用函数方式】
•如果需要在setState()执行后，获取最新的状态数据，可以在第二个callback函数中读取到异步更新的最新值
•在组件生命周期或React合成事件中，setState是异步；
•this.state是否异步，关键是看是否命中 batchUpdata 机制，命中就异步，未命中就同步。
•setState 中的 preState 参数，总是能拿到即时更新（同步）的值。
•在setTimeout或者原生dom事件中，setState是同步；
•不要直接修改state中的引用数据
JavaScript
class Example extends React.Component{
    constructor(){
    super(...arguments)
        this.state = {
            count: 0
        };
    }
    componentDidMount(){
       // a
      this.setState({count: this.state.count + 1});
      console.log('1:' + this.state.count)
      // b
      this.setState({count: this.state.count + 1});
      console.log('2:' + this.state.count)
      setTimeout(() => {
        // c
        this.setState({count: this.state.count + 1});
        console.log('3:' + this.state.count)
      }, 0)
      // d
      this.setState(preState => ({ count: preState.count + 1 }), () => {
        console.log('4:' + this.state.count)
      })
      console.log('5:' + this.state.count)
      // e
      this.setState(preState => ({ count: preState.count + 1 }))
      console.log('6:' + this.state.count)
    }
}

1:0
2:0
5:0
6:0
4:3
3:4

20. 说说浏览器的事件循环机制？宏任务是什么？微任务是什么？
事件循环机制的背景
•JS是一门单线程的语言，主要原因是为了使DOM操作简单化，避免处理多线程下复杂的竞态问题。
•浏览器中的任务是多种多样的，也就是说浏览器本身是多线程的。
￮一个浏览器Tab下，至少会有一个主线程，JS代码就是在主线程上调用v8来执行的。除了执行JS代码等同步任务，还需要处理网络请求、用户事件等异步任务，还有一些其他的辅助线程，比如渲染线程、事件线程、网络I0线程等处理各种各样的任务，那么就需要一个统一的机制来调度多任务的执行。
•单线程以阻塞方式执行异步任务的效率太低，所以必须设计一个非阻塞的模型。
具体实现
•在主线程上有一个while(true)的循环，不断的去检测任务队列里是否需要执行的任务。
•遇到多个异步任务会遇到并发的问题，所以事件循环机制需要规定了队列的读取顺序。
•浏览器中的任务可以分为微任务、宏任务，两者维护在各自的队列里。
•执行任务的顺序是，先取一个宏任务出来执行，过程中可能会添加一些微任务进到微任务队列里，
•在这次宏任务结束后，统一清空一下微任务队列。
•再去取下一个宏任务...如此循环，所以称为事件循环。
微任务队列: 存放 Promise回调【async await】、process.nextTick、MutationObserver 允许监视 DOM 变化，并在变化发生时触发微任务。
JavaScript
//允许监视 DOM 变化，并在变化发生时触发微任务。
const observer = new MutationObserver(() => {
  console.log("DOM mutation observed (microtask).");
});

observer.observe(someElement, { attributes: true });

宏任务队列:  读取文件请求、开启定时器、事件监听等宏任务，大部分都是一些需要其他线程来辅助的任务。
例如 IO事件、setTimeout、MessageChannel、setImmediate【node有、浏览器不规范api】
注意事项
•Node中的事件循环机制在node11版本之前,与浏览器的实现有所不同。
•有多个宏任务可执行时，会同时取多个一块执行，之后统一清空一次微任务。
•node11版本之后，和浏览器保持了一致，一次最多只取一个宏任务执行，清空其中的微任务之后，才去取下一个宏任务。

21. sleep函数 100ms 如何实现？浏览器的定时任务精准吗？为什么不精准？有延迟怎么办？
1. 直接循环法
JavaScript
console.time("while法");
const sleepTime = (wait = 100) => {
  let now = Date.now();
  while (Date.now() - now <= wait) {}
  console.timeEnd("while法");
};
sleepTime();
2. 使用Promise和setTimeout模拟sleep
JavaScript
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function demo() {
  console.log("Start sleeping for 100ms");
  await sleep(100);
  console.log("Done sleeping");
}

demo();
3. 递归setTimeout以减少累积误差
这种方法用于需要更精确控制延时的场景，通过计算剩余时间来调用下一个setTimeout。
JavaScript
function accurateSleep(ms, callback) {
  let start = Date.now();
  let remaining = ms;
  const loop = () => {
    remaining = ms - (Date.now() - start);
    if (remaining <= 0) {
      callback();
    } else {
      setTimeout(loop, Math.min(remaining, 10));
    }
  };
  loop();
}

accurateSleep(100, () => console.log("Accurate sleep done"));
4. 使用requestAnimationFrame进行UI相关的定时
适合于动画或与页面重绘相关的定时需求。
JavaScript
function sleepForAnimationFrame(ms) {
  const start = performance.now();
  const end = start + ms;
  const loop = (currentTime) => {
    if (currentTime < end) {
      requestAnimationFrame(loop);
    } else {
      console.timeEnd("requestAnimationFrame");
    }
  };
  requestAnimationFrame(loop);
}
console.time("requestAnimationFrame");
sleepForAnimationFrame(100);
5. 利用Web Workers进行后台计算（非直接实现sleep）
虽然Web Workers不能直接帮助实现精确的sleep，但它们可以避免阻塞主线程，间接提高整体响应性。这里仅展示如何创建和使用Worker的基本示例。
6. postmessage
差4ms,postmessage实现(), 执行 postmessage会产生一个宏任务。
JavaScript
  var timeouts = [];
  var messageName = 'zero-timeout-message';

  function setZeroTimeout(fn) {
    timeouts.push(fn);
    window.postMessage(messageName, '*');
  }
 
  function handleMessage(event) {
    if (event.source == window && event.data == messageName) {
      event.stopPropagation();
      if (timeouts.length > 0) {
        var fn = timeouts.shift();
        fn();
      }
    }
  }
 
  window.addEventListener('message', handleMessage, true);
 
  window.setZeroTimeout = setZeroTimeout;

22. 说说浏览器的垃圾回收机制？v8的垃圾回收机制？
分代垃圾回收机制
1.分代垃圾回收:
￮V8 是 Chrome 浏览器中使用的 JavaScript 引擎。
￮V8 使用分代垃圾回收机制用于管理内存，将内存分为两代：新生代（young generation）和老生代（old generation）。
￮大部分对象最初分配在新生代，经过多次回收后，仍然存活的对象会晋升到老生代。
￮在V8中，标记-清除算法是主要的垃圾回收机制，用于管理老生代的内存。
￮V8 使用增量式垃圾回收，允许将垃圾回收过程分成多个小步骤，以减小对应用程序的影响，降低停顿时间。
￮V8 提供了内存泄漏检测工具，可帮助开发人员识别和解决内存泄漏问题。

2.新生代垃圾回收:
￮新生代包含大多数短寿命对象，使用 Scavenger 算法来回收内存。
￮Scavenger 将新生代分为两个空间：From 空间【使用区】和 To 空间【空闲区】。对象首先分配到 From 空间，
￮当 From 空间满时，存活的对象会被复制到 To 空间，然后 From 空间被清空，此时 原有的 To空间 就成了下一次的 Form空间。
￮这个过程被称为一次垃圾回收周期（garbage collection cycle）。
￮经过多次回收后，存活的对象会被晋升到老生代。
3.老生代垃圾回收
￮老生代包含长寿命对象，使用标记-清除算法和标记-整理算法来回收内存。
￮垃圾回收器首先标记所有可达对象，然后清除不可达对象。
￮接着，标记-整理算法将存活的对象向一端移动，以便在一端留下连续的空闲空间。
标记-清除算法（Mark and Sweep）:
▪标记-清除是V8垃圾回收的一部分，主要用于老生代的内存管理。
▪它的工作原理是首先标记所有从根对象（通常是全局对象）可达的对象，将它们标记为“活动”（或“存活”），然后扫描整个堆，清除未被标记的对象。
▪清除操作会释放未被引用的内存，使其可供后续使用。
引用计数算法（Reference Counting）:
▪引用计数算法是一种不太常见的垃圾回收算法，它主要用于跟踪对象的引用计数。
▪每个对象都有一个引用计数，当有一个引用指向对象时，计数加一，当引用被移除时，计数减一。当引用计数为零时，对象被认为是垃圾，可以被回收。
▪引用计数的主要问题是无法解决循环引用的情况，即使有循环引用的对象互相引用，它们的引用计数也不会变为零，导致内存泄漏。

23. web Worker 的 常见应用场景是什么？
•是一种在后台线程中运行脚本的方法，不会阻塞主线程，
•类似于 requestAnimationFrame方法在浏览器渲染的空余时间处理。
•常用于需要进行大量计算或处理长时间任务的场景。
常见应用场景
1.计算密集型任务：
￮图像处理、视频处理、数据分析等需要大量计算的任务。
￮例如，图像的滤镜效果、视频的编码/解码、大数据的统计分析等。
2.处理大文件：
￮解析和处理大文件，例如 CSV、JSON 数据等。
￮读取大文件并进行解析和处理，避免阻塞主线程。
3.实时数据处理：
￮WebSockets 或 Server-Sent Events（SSE）接收到的数据处理。
￮实时股票行情、聊天信息等需要快速处理和显示的数据。
4.复杂算法：
￮路径规划算法（如 A*）、加密解密算法、排序和搜索等复杂算法。
￮例如，路径规划、密码破解、机器学习模型的训练等。
5.游戏开发：
￮复杂的游戏逻辑、物理引擎计算等。
￮例如，游戏中的物理模拟、AI 行为计算等。
解释
1.主线程代码：
￮创建一个 Web Worker 实例，并指定要运行的脚本 worker.js。
￮监听 Web Worker 的消息事件，通过 onmessage 函数接收计算结果。
￮使用 postMessage 方法向 Web Worker 发送数据。
2.Web Worker 代码：
￮监听主线程发送的消息，通过 onmessage 函数接收数据。
￮执行计算任务（例如，计算从 0 到 input * 1e6 的累加和）。
￮使用 postMessage 方法将计算结果发送回主线程。

24. 防抖节流的区别是什么？手写代码，手写 react hook，常见的应用场景有哪些？
•防抖 (Debounce)：一段时间内连续触发，只执行最后一次。
￮搜索框实时搜索：用户在搜索框中输入关键词时，每次输入都会触发搜索事件。通过防抖技术，只有在用户停止输入一段时间（如300毫秒）后才真正发起搜索请求，避免频繁向服务器发送无效或相似的搜索请求。
￮窗口大小调整（window.resize事件）：当用户快速调整浏览器窗口大小时，resize事件可能会非常密集地触发。使用防抖函数可以在用户完成窗口大小调整后才执行相应的布局重计算或图片懒加载等操作。
￮按钮提交：对于表单提交或者异步操作按钮，防抖可以防止用户快速连续点击导致的多次提交问题。
￮滚动到顶部/底部自动加载更多：虽然通常这里更适合使用节流，但在某些情况下，也可以用防抖来确保用户滚动动作完全停止后才加载更多数据。
•节流 (Throttle)：限制回调函数在单位时间内至多执行一次，维持一定的执行频率。
￮页面滚动事件监听（window.scroll事件）：在无限滚动加载的网页中，节流可以确保滚动事件在用户滚动过程中每隔一定时间（例如每100毫秒）只触发一次，从而控制数据加载速度，避免一次性加载过多数据影响性能。
￮地图拖拽缩放：地图组件在用户拖拽或缩放操作时，连续的动作可能引发大量渲染更新，使用节流可以保证在连续操作期间仍然有合适的帧率进行地图更新。
￮游戏或动画帧率控制：需要控制函数执行频率保持在稳定的速率，例如在每一帧动画之间加入节流，使得即使用户的操作很频繁，也只按照固定帧率执行。
￮高性能图表绘制：在大量数据动态更新并刷新图表时，节流有助于避免因数据更新过快而导致的过度渲染，保证视觉效果平滑的同时降低CPU占用。
25. localStorage、sessionStorage、cookie、状态管理工具、indexDB的区别和使用场景?
Cookie
用于记录用户状态的一种方式，由服务器设置【setCookie】，在客户端存储。
发起同源请求时，发给服务器端。
cookie 最多能存储 4 k 数据。
它的生存时间由 expires 属性指定。
并且 cookie 只能被同源的页面访问共享。
	
￮setCookie: passport_app_access_token=1213; Path=/; Max-Age=43200; HttpOnly; Secure; SameSite=None
￮Name = Value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌。
￮Path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test/*路径下的页面可以读取此cookie。
￮Secure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
￮Domain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。
▪当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。
▪因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
￮httpOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。
在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。
该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。
￮Expires/Max-Age ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。
￮SameSite: strict： 只支持同站请求携带cookie。之前默认为None，跨站都允许，现在为Lax。
预测最近面试会考 Cookie 的 SameSite 属性 - 掘金
sessionStorage： 
￮html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。
￮它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。

状态管理工具：
•例如 mobx、vuex等状态管理工具，它的最大特点就是集中状态数据管理，可以从任何组件里获取数据，并且这个数据的有效期只存在当前页面，也就是刷新后会失效。

localStorage：
￮ html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。
￮它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，
￮并且 localStorage 也只能被同源页面所访问共享。
￮值得一提的是，你可以设置个JSON存在value里，包含加密后的过期时间字段。

•IndexedDB 
￮https://www.ruanyifeng.com/blog/2018/07/indexeddb.html
▪键值对存储，key值唯一
▪异步操作，适合大量数据读写，不会阻碍用户操作
▪字符串、二进制数据都能存储
▪支持事务、类似于数据库
▪同源策略不能，不能跨域
▪一般来说不少于 250MB，没有上限
￮键值对储存：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
￮异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
￮支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
￮同源限制： IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
￮储存空间大：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
￮支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。

26. 不影响页面的点击操作事件，同时保证页面数据更新，但是这个更新过程的计算速度比较慢，提供你的方案。
•Web worker的使用，不影响浏览器主线程。
•requestAnimationFrame，在浏览器空闲时间操作。
•IndexedDB 的异步设计，防止大量数据的读写，拖慢网页的表现。
•异步并发控制器：去设计一个带有优先级的任务队列执行器，让优先级高的任务推送到任务队列的队头，避免阻塞页面的点击操作事件的回调函数。
•虚拟滚动、防抖节流：减少必要的计算次数。
•复杂的计算，最好还是交给后端处理，然后轮询请求。
•如果较为频繁，让后端对结果设置redis缓存，未尝不可。
27. node的fork多进程 ，要求进程崩溃后自动重启？如何保证重启后不会遗漏之前的待处理操作？
在Node.js中，使用child_process.fork()创建多进程时，确保进程崩溃后能自动重启并且不丢失之前待处理的任务。
1.使用进程管理器: 如pm2，它能自动管理你的Node.js应用，包括自动重启崩溃的进程。虽然这不是直接通过代码实现的，但对于生产环境来说是一个非常实用的解决方案。
2.重启逻辑封装: 在应用代码中封装一个重启逻辑，当检测到异常时，先将当前待处理任务存储（如数据库、文件系统或消息队列），然后重启进程，并在重启后从存储中恢复这些任务继续处理。

•在子进程中处理任务失败时记录任务到文件，然后重启进程。
•主进程监听子进程退出事件并重新启动子进程。
•需要更复杂的错误处理和日志记录机制。

当worker.js中的任务处理失败时，它会将未完成的任务写入文件，然后通过process.exit(1)模拟进程崩溃。主进程index.js监听子进程的退出事件，并在子进程非正常退出时自动重启子进程。
JavaScript
// worker.js
const fs = require('fs');
function processTask(task) {
    // 假设任务处理失败
    if (task === 'fail') {
        // 将未完成的任务写入文件
        fs.writeFile('failed_tasks.txt', task + '\n', { flag: 'a' }, err => {
            if (err) console.error(err);
        });
        
        // 模拟进程崩溃
        process.exit(1);
    }
}
// 读取任务，这里为了简单起见，直接硬编码一个任务
const task = 'fail';
processTask(task);

JavaScript
// index.js
const { spawn } = require('child_process');

let workerProcess;

function startWorker() {
    workerProcess = spawn('node', ['worker.js']);
    
    workerProcess.stdout.on('data', data => {
        console.log(`Worker stdout: ${data.toString()}`);
    });

    workerProcess.stderr.on('data', data => {
        console.error(`Worker stderr: ${data.toString()}`);
    });

    workerProcess.on('exit', (code, signal) => {
        if (code !== 0) {
            console.error('Worker process exited with code:', code);
            // 自动重启子进程
            startWorker();
        } else {
            console.log('Worker process exited gracefully');
        }
    });
}

startWorker();
对于更复杂的需求，如任务队列的持久化、任务去重、以及更健壮的错误处理，你可能需要引入额外的库或服务，如Redis、RabbitMQ等。

28. 浏览器有哪些进程？进程之间通信方式有哪些？
浏览器多进程模型
浏览器进程：
浏览器本身是一个大进程，负责界面显示、用户交互、子进程管理、存储等功能。
•渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
•GPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
•网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
•插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。
如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。
 进程和线程的区别
•进程可以看做独立应用，线程不能。
•资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
•通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。
•调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
•系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。
浏览器渲染进程
（1）GUI渲染线程 
负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
（2）JS引擎线程 
JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；
注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。
（3）时间触发线程：
属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；
注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；
（4）定时器触发进程
即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。
（5）异步http请求线程
•XMLHttpRequest连接后通过浏览器新开一个线程请求；
•检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；
29. qiankun 的基本实现原理？如何手写一个微前端框架？
•选定好不同前端应用的CSS、JS、DOM操作隔离方案。
•思考用如何管理子应用的加载和卸载。
•如何加载微应用对应的资源。
•网络请求的隔离
￮重写网络请求，实现不同子应用的网络请求相互隔离。
￮fetch 预加载：同源请求：不会默认携带cookie，造成子应用重复登录的问题。
•CSS的样式隔离
￮默认实现单应用的样式隔离，shadow dom、scoped 都有点问题。
•JS隔离
￮基于 qiankun 的3种沙箱原理 ，自动切换执行代码中的上下文。
￮学习wujie的方案，JS 放 iframe 里运行，DOM 放 webComponent 渲染。
•DOM操作:
￮类似qiankun的JS沙箱操作DOM的性能问题。
￮DOM 渲染无法突破 iframe 边界？
￮DOM操作影响全局？等问题。
JavaScript
class MicroFrontend {
  constructor() {
    this.apps = {};
  }

  registerApp(name, entry) {
    this.apps[name] = { entry };
  }

  loadApp(name) {
    const app = this.apps[name];
    if (!app) {
      throw new Error(`App ${name} is not registered`);
    }

    return fetch(app.entry)
      .then(response => response.text())
      .then(html => {
        const div = document.createElement('div');
        div.innerHTML = html;
        document.body.appendChild(div);
      });
  }
}

const microFrontend = new MicroFrontend();
microFrontend.registerApp('app1', 'http://localhost:3001');
microFrontend.loadApp('app1');

30. 为什么要用微前端，收益是什么？
微前端是一种前端架构模式。
•旨在将大型前端应用拆分成更小、更独立的部分，类似于 iframe 的效果。
•消除技术栈差异性。
•减少单体应用的复杂性、加载时间，性能提升。
•独立开发、部署、维护子项目。
•维护、扩展更方便，利于增强团队合作。
31. 考虑过其他微前端框架吗？有什么区别？为什么选择qiankun？
 选择的原因 ｜ qiankun的优势
•基于国外的 single-spa 二次封装
•更加开箱即用的 API，比如支持直接以 HTML 地址作为加载子应用的入口。
•开源、知名度高、有先发优势、应用较广、npm周下载量高。
•pc 端前端应用拆分的项目已经有很多成功案例。
•有现成的插件 @umijs/plugin-qiankun ，vite-plugin-qiankun，帮助降低子应用接入成本。
qiankun 的劣势
•子应用 接入成本 其实还是有点高。
•对 vite 支持性较差，代理沙箱实现的关键是需要将子应用的 window “替换”为 fakeWindow，在这一步 qiankun 是通过函数 window 同名参数 + with 作用域绑定的方式，更改子应用 window 指向为 fakeWindow，最终使用 eval(...) 解析运行子应用的代码。因为官方目前推荐的解决方法是关闭沙箱。vite 生态里有一款专门兼容此问题的vite-plugin-qiankun 插件【eval 虽然没办法执行静态 import 语法，但它可以执行动态 import(...) 语法】。
•JS 沙箱方案存在性能问题，比如 操作dom节点性能下降严重。


其他3种方案
直接 iframe
优势
1.隔离性： 使用 "iframe" 可以实现较高的隔离性，每个子应用运行在独立的环境中，减少了应用之间的相互影响。
2.技术无关性： 由于子应用是独立的 HTML 文件，因此子应用可以使用不同的技术栈来开发，包括不同的前端框架和库。
3.独立部署： 每个子应用可以独立部署，这使得团队可以更灵活地更新和维护子应用。
4.稳定性：iframe问题相对来说都是明面上的，不会有什么隐藏问题。
劣势 ｜ 为什么不用 iframe
1.性能开销和代码复杂性： 使用 "iframe" 可能会导致一些性能开销。因为每次子应用进入都需要重新加载资源，而且加载 "frame 需要额外的网络请求，而且 "iframe" 中的子应用与主应用之间的通信也可能引入一些延迟，特别是在涉及跨子应用共享状态和数据时。
2.样式污染： 每个应用里的样式会互相影响，可能造成样式污染。
3.隔离性过强：iframe 提供了浏览器原生的硬隔离方案，可以完美解决样式隔离和 JavaScript 隔离等问题。然而，这也导致了应用间上下文无法共享，无法实现无缝衔接。具体问题包括：
￮URL 不同步：刷新 iframe 中的 URL 会导致状态丢失，前进和后退按钮无法正常使用。
状态丢失：当你在 iframe 中加载一个新的 URL 时，iframe 内部的状态（例如表单输入、JavaScript 变量等）会被重置。这是因为每个 URL 都有自己的浏览上下文，它不会保留之前的状态。
前进和后退按钮无法正常使用：由于 iframe 中的 URL 和主页面的 URL 不同步，浏览器的前进和后退按钮将无法正确导航到 iframe 中的历史记录。如果用户在 iframe 中浏览了几个页面，然后点击浏览器的后退按钮，实际上会导致整个页面刷新，而不是返回到 iframe 中的上一个页面。
￮DOM 渲染无法突破 iframe 边界？UI 不同步，DOM 结构不共享
UI 不同步：在 iframe 中打开的弹框与主页面之间的 UI 同步是一个挑战。例如，如果你在 iframe 中打开一个带有遮罩层的弹框，要求它在浏览器中居中显示，同时在浏览器调整大小时也自动居中，以下问题可能会出现：
•坐标计算：由于 iframe 和主页面之间的上下文隔离，计算弹框的位置变得复杂。你需要考虑 iframe 的位置、大小、滚动等因素，以确保弹框正确居中。
•尺寸同步：当主页面调整大小时，你需要监听窗口大小变化事件，并相应地调整 iframe 中弹框的尺寸和位置。这需要一些复杂的 JavaScript 逻辑。
DOM 结构不共享：iframe 内外的 DOM 结构是完全隔离的，这意味着你无法直接访问 iframe 中的元素或修改其样式。例如，如果你想在弹框中添加一个遮罩层，你需要在 iframe 内部创建该元素，然后通过一些通信机制（如 postMessage）将信息传递给主页面，以便主页面在遮罩层上添加样式。
￮全局上下文完全隔离，内存变量不共享：iframe 内外系统之间的通信和数据同步需求，以及主应用的 cookie 传递到根域名不同的子应用中的免登效果，都受到影响。

wujie 无界
腾讯出品的一款微前端框架。改良派的代表： iframe 虽然问题很多，但仅把它作为一个 js 沙箱去用，表现还是很稳定的。
相关问题
•DOM 渲染无法突破 iframe 边界？(弹框不居中问题)
那 DOM 就不放 iframe 里渲染了，而是单独提取到一个 webComponent 里渲染，顺便用 shadowDOM 解决样式隔离的问题。简单说，无界的方案就是：JS 放 iframe 里运行，DOM 放 webComponent 渲染。
•用 JS 操作 DOM 时，两者如何联系起来呢？毕竟 JS 默认操作的总是全局的 DOM。
代理子应用中所有的 DOM 操作，比如将 document 下的 getElementById、querySelector、querySelectorAll、head、body 等查询类 api 全部代理到 webComponent。
•刷新页面会导致子应用路由状态丢失？
通过重写 iframe 实例的 history.pushState 和 history.replaceState，将子应用的 path 记录到主应用地址栏的 query 参数上，当刷新浏览器初始化 iframe 时，从地址栏读到子应用的 path 并使用 iframe 的 history.replaceState 进行同步。
优点
•Iframe 沙箱性能更好
•没有qiankun的vite问题，兼容性更好
•接入成本来说也较低，当成组件渲染就行。
缺点
•iframe 加载主应用 host 以及资源问题【无解】。因为 子应用需要一个 空白的、同域的、浏览器前进后退可以生效的 iframe 作为沙箱。无界采用直接加载 iframe src 等于主应用 host 的地址，然后等 window.location 初始化成主应用域名后(为了子应用路由window.history.pushState 可以正常工作)后立即停止iframe的加载，此时子应用跳转路由后点击浏览器后退也可以生效到子应用。但是在等待 location origin 初始化的过程中有可能加载了主应用 host 地址的 html，然后运行了这个地址内的部分代码，在safari 浏览器中尤其明显。
•iframe 到 webComponent 的代理机制，对于富文本项目里的判断逻辑通常会有影响。
•用于 js 沙箱的 iframe 是隐藏在主应用的 body 下面的，相当于是常驻内存，这可能会带来额外的内存开销。
JavaScript
// 弹窗组件类
class PopupModal extends HTMLElement {
  constructor() {
    super();

    // 创建Shadow DOM
    const shadow = this.attachShadow({ mode: 'open' });

    // 创建弹窗的HTML结构
    const template = document.createElement('template');
    template.innerHTML = `
      <style>
        /* 弹窗的样式 */
        :host {
          display: block;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          z-index: 999;
          display: none;
        }
        .modal {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: #fff;
          padding: 20px;
        }
      </style>
      <div class="modal">
        <slot></slot> <!-- 这里插入弹窗内容 -->
        <button id="closeBtn">关闭</button>
      </div>
    `;

    // 克隆并插入模板内容
    const templateContent = document.importNode(template.content, true);
    shadow.appendChild(templateContent);

    // 获取关闭按钮并添加事件处理程序
    const closeButton = shadow.getElementById('closeBtn');
    closeButton.addEventListener('click', () => {
      this.close();
    });
  }

  // 自定义方法：打开弹窗
  open() {
    this.style.display = 'block';
  }

  // 自定义方法：关闭弹窗
  close() {
    this.style.display = 'none';
  }
}

// 定义自定义元素
customElements.define('popup-modal', PopupModal);


<popup-modal id="myModal">
  <h2>这是一个弹窗</h2>
  <p>这是弹窗的内容。</p>
</popup-modal>

<button onclick="openModal()">打开弹窗</button>

<script>
  function openModal() {
    const modal = document.getElementById('myModal');
    modal.open();
  }
</script>
MicroApp
京东的大前端团队出品。样式隔离方案与 qiankun 的实验方案类似，也是在运行时给子应用中所有的样式规则增加一个特殊标识来限定 css 作用范围。
子应用路由同步方案与 wujie 类似，也是通过劫持路由跳转方法，同步记录到 url 的 query 中，刷新时读取并恢复。
组件化的使用方式与 wujie 方案类似，这也是 micro-app 主打的宣传点。
最有意思的是它的JS沙箱方案，内置了两种沙箱
1.类 qiankun 的 with 代理沙箱，据说相比 qiankun 性能高点，但目前微前端框架界并没有一个权威的基准性能测试依据，所以并无有效依据支撑。
2.类 wujie 的 iframe 沙箱，用于兼容 vite 场景。
优点
功能丰富、文档较全、接入成本低
MicroApp采用的是和qiankun一样的proxy+with的沙箱方案，这也是目前js沙箱的主流方案 。
•with语句：with语句可以创建一个新的作用域，这个作用域的上下文对象是指定的对象。在这个作用域中，可以直接访问对象的属性，而无需通过对象名。这样可以防止微应用直接访问全局对象，从而实现隔离。
•Proxy对象：Proxy对象用于创建一个对象的代理，可以拦截并定义基本操作的行为，如属性查找、赋值、枚举、函数调用等。在微前端中，Proxy用于代理window对象，拦截对全局变量的访问和修改，从而实现隔离。

with沙箱的功能非常完善，但是性能损耗却非常明显，在社区中也不乏对with沙箱性能问题的讨论，但一直没有特别完美的解决方案，这是由于with改变了js的作用域链，从而产生大量的重复请求。
问题的根源是with，但又不全是with的问题，准确的说是with和proxy两者叠加造成的，with和proxy本质上的性能都不高，需要一种方案避免对这两个方法的频繁读取操作，MicroApp采用的解决方案是变量前置和异步防抖。
•变量前置：是指使用Object.defineProperty定义全局变量，通过get和set设置响应数据，一是为了避免在proxy的get中进行多余的操作，二是defineProperty的性能比proxy更优秀 。
•异步防抖：是指在子应用运行时对promise进行标记，确保在上一个promise执行完成之后才会进入下一个，避免并行触发，防止promise被频繁触发会造成性能损失。

缺点
•issue不多，长期维护性一般
•静态资源补全是基于父应用的，而非子应用这需要开发者自己手动解决。

微前端未来方向
qiankun方向
性能更好的 with+proxy 沙箱
wujie的方向
webComponent ：原生提供的组件复用能力是最大的亮点。
Web组件（Web Components）是一种用于创建可重用的自定义HTML元素的Web开发技术。它们提供了一种将代码封装、重用和组织的方法，使开发者能够构建独立于框架的组件，这些组件可以在不同项目和环境中使用。
三个主要技术规范：
1.Custom Elements（自定义元素）：Custom Elements API 允许你创建自定义HTML元素，这些元素的行为和样式可以完全自定义。你可以定义自己的元素，例如 <my-element>，然后通过JavaScript为其添加行为和属性。
2.Shadow DOM（影子DOM）：Shadow DOM 提供了一种封装元素的方法，使得元素内部的HTML、CSS和JavaScript不会与外部文档发生冲突。这有助于隔离组件的样式和行为，以防止外部样式和脚本影响它。
3.HTML Templates（HTML模板）：HTML Templates 允许你定义可复用的HTML结构片段，但不会在页面加载时立即呈现。你可以在需要的时候克隆这些模板并将其插入文档中。
缺点：虽然有前端框架的组件化，但在开发体验上缺少了状态驱动的框架思想。

32. 微前端拆分时的基本步骤是什么？遇到过什么困难？
接入实践
1.主应用项目
registerMicroApps 注册子应用，start 启动。
2.子应用项目
在子应用中，还可以通过 bootstrap、mount 和 unmount 函数来定义子应用的生命周期钩子，
以便在不同阶段执行相应的操作，比如初始化、挂载和卸载。
踩坑记录
•【重点】要求不同的微应用之间有明确的服务边界划分，而不是单纯从路由角度去拆分业务。
•【public-path.js】修改运行时的 publicPath ，确保子应用的资源路径是全路径，避免因为使用相对路径出现资源路径错误。
•子应用设置的路由需要严格与activeRule对应上，如果子应用的某些路由没有匹配到有效的 activeRule，控制台会有警告，还可能出现路由noFound与子应用突然存在的尴尬情况。为了避免上述问题，为所有子应用加统一前缀。
•浏览器的同源策略，引起不同应用间请求的跨域问题，需要注意。
•【重点】主、子应用的样式隔离问题
Qiankun 可以开启样式隔离，但会有些其他问题：https://juejin.cn/post/7184419253087535165
推荐css-module方案、保证CSS前缀使用的覆盖率、解决body等通用元素的样式冲突
•提前配置好charles代理，便于在开发环境时调试不同场景。
￮主应用不动，用 map remote 映射到本地子应用，然后就可以在线上查看和调试本地的子应用了。
￮子应用单独也能打开，不需要打开主应用，配置后端跨域即可。
￮主应用和子应用都在本地，rewrite规则，子应用的远程地址代理到本地即可。
•子应用可能出现重复登录问题，fetch跨域请求默认不会携带cookie。可在 start 函数 或者 子应用里重新定义qiankun的fetch方法。
•子应用在微前端环境下，原有的全局作用域变成了局部的，所以全局对象一般绑定window上 或者 qiankun的initGlobalState方法来实现。
•子应用打开太缓慢问题，记得配置 qiankun的 prefetch 进行预请求。
•vite接入qiankun，因为vite的原理是利用浏览器自身支持es module语法，通过script标签上加type = module实现。
而 qiankun 为了实现js的隔离，利用eval去执行子应用的代码，两者就出现冲突。
调研后，我们使用vite-plugin-qiankun去做，它的原理就是忽略了qiankun 全局沙箱隔离功能，
然后去 动态 import语法 去代替 es module 静态 import 导入其他模块的方法，
这样就能在eval函数里跑起来。
JavaScript
import { initGlobalState, MicroAppStateActions } from 'qiankun';

// 初始化 state
const actions: MicroAppStateActions = initGlobalState({
    busId: '', // 默认测试分组
});

export default actions;


JavaScript
start(
{
    fetch: (url) => {
        // 在这里可以进行请求代理
        return fetch(url);
    }
})



JavaScript
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

window.__POWERED_BY_QIANKUN__ 是一个由乾坤框架注入到全局环境中的标志，用于标识当前应用是否是在乾坤的微前端环境中运行。

__webpack_public_path__ 是 Webpack 提供的一个全局变量，它决定了动态加载的模块的基础路径。
在子应用的代码中，如果没有正确设置这个路径，那么在加载子应用的模块时可能会出现资源路径错误的问题。

window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ 是乾坤框架注入的当前子应用的公共路径。
在乾坤环境中，子应用的资源路径需要根据当前运行的子应用动态设置，以确保资源能够正确加载。

因此，这段代码的作用就是，当子应用在乾坤环境中运行时，它会读取注入的公共路径，
然后通过设置 __webpack_public_path__，确保子应用内部的资源加载路径正确。
这样即使子应用被嵌套在主应用中，它的静态资源路径也会被正确地配置和加载。


JavaScript
const inter = setInterval(() => {
    if (store.state.urls.length > 0) {
        registerMicroApps(
            [
                {
                    name: 'resourceBit',
                    entry: `${window.location.protocol}//unionhy.58corp.com/${seperator}/resourceBit.html`,
                    container: '#root',
                    activeRule: '/path',
                },
                  
            ]
        );
        start({
            prefetch: 'all',
            sandbox: {
                experimentalStyleIsolation: true, // 隔离主应用和微应用的样式
            },
        });
        clearInterval(inter);
    }
}, 100);

// 子应用暴露的生命周期钩子
export async function bootstrap() {
  console.log("Sub App is bootstrapped");
}

export async function mount(props) {
  console.log("Sub App is mounted", props);
}

export async function unmount() {
  console.log("Sub App is unmounted");
}
33. 微前端的JS沙箱隔离原理、样式隔离原理？你项目是如何做的？
https://www.yuque.com/kuitos/gky7yw/nwgk5a
https://juejin.cn/post/7184419253087535165
https://juejin.cn/post/7148075486403362846#heading-6
https://juejin.cn/post/6920110573418086413#heading-7
原理汇总
Qiankun 是一个微前端框架，用于构建大规模、复杂的前端应用，它可以将多个独立的前端子应用整合到一个主应用中。
1.基于 Single-SPA 实现： Qiankun 使用了 Single-SPA 作为其核心实现。Single-SPA 是一个用于构建微前端应用的框架，它允许不同的前端应用在同一个页面中共存，而不会相互干扰。Qiankun 利用 Single-SPA 提供的能力来管理多个前端子应用，实现了子应用的加载、挂载、卸载等操作。
2.JS 沙箱的原理： 为了确保每个前端子应用的代码隔离和安全性，Qiankun 使用了 JavaScript 沙箱机制。每个前端子应用都在独立的 JavaScript 沙箱中运行，这意味着它们的全局变量和函数不会相互干扰。这通过使用一些技术来实现，例如 iframes 或者 JavaScript Proxy。
3.Fetch 请求： 在微前端架构中，每个前端子应用都有自己独立的网络请求。Qiankun 会截获这些网络请求，并确保它们不会干扰其他子应用或主应用。这是通过在沙箱中重写全局的 fetch 函数来实现的，从而能够拦截和控制所有的网络请求。
4.CSS 样式问题： 微前端架构中一个常见的问题是 CSS 样式冲突。不同子应用可能使用相同的类名或者样式，导致页面样式混乱。Qiankun 通过 CSS 沙箱来解决这个问题，它会为每个子应用创建一个独立的 CSS 作用域，确保样式不会相互干扰。这通常是通过 CSS Modules、Shadow DOM 或其他类似技术来实现的。
5.eval 函数： 在 Qiankun 中，eval 函数一般不建议使用，因为它可以执行任意的 JavaScript 代码，可能会破坏沙箱的隔离性。如果前端子应用中使用了 eval 函数，可能会导致不可预测的问题，特别是在沙箱环境中。因此，Qiankun 通常会限制或禁止对 eval 函数的使用，以确保安全性和稳定性。
总结
1.Qiankun 基于 Single-SPA 这个框架来管理前端子应用的生命周期和路由，控制子应用的加载。
2.使用沙箱机制来隔离子应用的代码和资源，以确保它们可以在同一个页面中共存而不相互干扰。
3.拦截并重写网络请求，实现不同的微应用之间网络请求的隔离。
4.针对 CSS 样式冲突，提供了 webcomponet 中的shadow dom 和 类似于 vue 中的 scoped 标签功能 两种样式隔离方案，其实都不推荐。

import-html-entry 隔离JS原理
把要执行 JS 代码放在一个立即执行函数中，且函数入参有 window, self, globalThis
给这个函数绑定上下文 window.proxy
执行这个函数，并把上面提到的沙箱对象 window.proxy 作为入参分别传入。
那么此时，window.a 的 window 就不是全局 window 而是 fn 的入参 window 了。又因为我们把 window.proxy 作为入参传入，所以 window.a 实际上为 window.proxy.a = 1。
JS 隔离逻辑需要沙箱结合起来使用，qiankun 会把要执行的 JS 包裹在立即执行函数中，通过绑定上下文和传参的方式来改变 this 和 window 的值，让它们指向 window.proxy 沙箱对象，最后再用 eval 来执行这个函数。
qiankun现在也不用with沙箱，避免潜在问题。
JS沙箱原理
Qiankun 框架提供了三种不同场景下使用的沙箱，分别是 snapshotSandbox、proxySandbox 和 legacySandbox。它们可以用于不同的前端子应用隔离需求。
1.SnapshotSandbox：记录 window 对象，每次 unmount 都要和微应用的环境进行 Diff
2.LegacySandbox：在微应用修改 window.xxx 时直接记录 Diff，将其用于环境恢复
3.ProxySandbox：为每个微应用分配一个 fakeWindow，当微应用操作 window 时，其实是在 fakeWindow 上操作

snapshotSandbox（快照沙箱）
特点：
一定程度上隔离全局变量和 DOM，但可能污染window对象，但兼容性更好，因为没有用es6的proxy对象。
原理：
激活沙箱时
•先把上一次记录的变更 modifyPropsMap 应用到微应用的全局 window，没有则跳过。
•浅复制主应用的 window key-value ，存入到快照windowSnapshot，用于下次恢复全局环境
退出沙箱时
•将当前微应用 window 的 key-value 和 快照 的 key-value 进行 Diff，Diff 出来的结果用于下次恢复微应用环境的依据
•将上次快照windowSnapshot的 key-value 拷贝到主应用的 window 上，以此恢复环境
JavaScript
// 运营平台使用
start({
    prefetch: 'all',
    sandbox: {
        experimentalStyleIsolation: true, // 隔离主应用和微应用的样式
    },
});

JavaScript
  import { initGlobalState, registerMicroApps, start } from 'qiankun';

   const sandbox = { experimentalStyleIsolation: true };

   registerMicroApps([
     {
       name: 'app1',
       entry: 'http://localhost:8081',
       container: '#app1',
       sandbox,
     },
   ]);

 

JavaScript
const iter = (window, callback) => {
  for (const prop in window) {
    if(window.hasOwnProperty(prop)) {
      callback(prop);
    }
  }
}
class SnapshotSandbox {
  constructor() {
    this.proxy = window;
    this.modifyPropsMap = {};
  }
  // 激活沙箱
  active() {
    // 缓存active状态的window
    this.windowSnapshot = {};
    iter(window, (prop) => {
      this.windowSnapshot[prop] = window[prop];
    });
    Object.keys(this.modifyPropsMap).forEach(p => {
      window[p] = this.modifyPropsMap[p];
    })
  }
  // 退出沙箱
  inactive(){
    iter(window, (prop) => {
      if(this.windowSnapshot[prop] !== window[prop]) {
        // 记录变更
        this.modifyPropsMap[prop] = window[prop];
        // 还原window
        window[prop] = this.windowSnapshot[prop];
      }
    })
  }
}

legacySandbox（单例代理沙箱）
qiankun基于es6的Proxy实现了两种应用场景不同的沙箱，一种是legacySandbox(单例)，一种是proxySandbox(多例)。因为都是基于Proxy实现的，所以都称为代理沙箱。
•  legacySandbox 是一种传统的沙箱模式，通常用于兼容老的前端子应用，对隔离要求较低。
LegacySandbox 的想法则是 通过监听对 window 的修改来直接记录 Diff 内容，因为只要对 window 属性进行设置，那么就会有两种情况：如果是新增属性，那么存到 addedMap 里。如果是更新属性，那么把原来的键值存到 prevMap，把新的键值存到 newMap。这三个变量就能反推出微应用以及原来环境的变化。
JavaScript
class Legacy {
  constructor() {
    // 沙箱期间新增的全局变量
    this.addedPropsMapInSandbox = {};
    // 沙箱期间更新的全局变量
    this.modifiedPropsOriginalValueMapInSandbox = {};
    // 持续记录更新的(新增和修改的)全局变量的 map，用于在任意时刻做 snapshot
    this.currentUpdatedPropsValueMap = {};
    const rawWindow = window;
    const fakeWindow = Object.create(null);
    this.sandboxRunning = true;
    const proxy = new Proxy(fakeWindow, {
      set: (target, prop, value) => {
        // 如果是激活状态
        if(this.sandboxRunning) {
          // 判断当前window上存不存在该属性
          if(!rawWindow.hasOwnProperty(prop)) {
            // 记录新增值
            this.addedPropsMapInSandbox[prop] = value;
          } else if(!this.modifiedPropsOriginalValueMapInSandbox[prop]) {
            // 记录更新值的初始值
            const originValue = rawWindow[prop]
            this.modifiedPropsOriginalValueMapInSandbox[prop] = originValue;
          }
          // 纪录此次修改的属性
          this.currentUpdatedPropsValueMap[prop] = value;
          // 将设置的属性和值赋给了当前window，还是污染了全局window变量
          rawWindow[prop] = value;
          return true;
        }
        return true;
      },
      get: (target, prop) => {
        return rawWindow[prop];
      }
    })
    this.proxy = proxy;
  }
  active() {
    if (!this.sandboxRunning) {
      // 还原上次修改的值
      for(const key in this.currentUpdatedPropsValueMap) {
        window[key] = this.currentUpdatedPropsValueMap[key];
      }
    }

    this.sandboxRunning = true;
  }
  inactive() {
    // 将更新值的初始值还原给window
    for(const key in this.modifiedPropsOriginalValueMapInSandbox) {
      window[key] = this.modifiedPropsOriginalValueMapInSandbox[key];
    }
    // 将新增的值删掉
    for(const key in this.addedPropsMapInSandbox) {
      delete window[key];
    }

    this.sandboxRunning = false;
  }
}

proxySandbox（多例代理沙箱）
• proxySandbox 提供了更强大的隔离，可以防止一些全局变量和 DOM 节点的污染。
把当前 window 的一些原生属性（如document, location等）拷贝出来，单独放在一个对象上，这个对象也称为 fakeWindow。之后对每个微应用分配一个 fakeWindow。当微应用修改全局变量时：如果是原生属性，则修改全局的 window。如果不是原生属性，则修改 fakeWindow 里的内容。微应用获取全局变量时：如果是原生属性，则从window 里拿，如果不是原生属性，则优先从 fakeWindow 里获取。
JavaScript
  class ProxySandbox {
    active() {
      this.sandboxRunning = true;
    }
    inactive() {
      this.sandboxRunning = false;
    }
    constructor() {
      const rawWindow = window;
      const fakeWindow = {};
      const proxy = new Proxy(fakeWindow, {
        set: (target, prop, value) => {
          if(this.sandboxRunning) {
            target[prop] = value;
            return true;
          }
        },
        get: (target, prop) => {
          // 如果fakeWindow里面有，就从fakeWindow里面取，否则，就从外部的window里面取
          let value = prop in target ? target[prop] : rawWindow[prop];
          return value
        }
      })
      this.proxy = proxy;
    }
  }

css样式隔离原理
1.默认实现了单应用的样式隔离，只有一个子应用处于激活状态。【运营平台就是这样】
2.qiankun实现了2种高级的样式隔离方案【不推荐】，现在的 vue、react 项目基本都做了组件样式隔离了，有点全局样式也是可控的，真没必要用 qiankun 的那个。
Shadow dom
•shadow dom 是 web components 技术的一部分，其实就一个 attachShadow 的 api。
•qiankun 要在加载子应用的时候指定 strictStyleIsolation 才会开启这种样式隔离。
•明显的缺点是shadow dom 样式影响不了外界，外界样式也影响不了 shadow dom 内的元素。
￮与世隔绝的感觉，主应用无法给子应用统一加样式。
￮比较常见的问题就是放在body下的弹窗组件，因为不在shadow dom 下，所以样式不生效了。
Scoped
￮scoped css 是 vue loader 实现的组件级样式隔离方案，用起来只要给单文件组件的 style 加一个 scoped 属性。
￮借鉴了 scoped css 的思路。也就是对所有样式加了一层 data-qiankun=“应用名” 的选择器来隔离，可以避免
常见类名冲突的问题。
￮缺点：子应用的样式还是影响不了父应用，qiankun 并没有实现 global 样式。如果要在 qiankun 里实现全部的 scoped css 功能，那为啥不直接用 scoped css 或者类似的 css modules 呢？

34. common js 与 ES module 规范的区别？common js的实现原理？
CommonJS与ES Modules（简称ESM）是两种主要的JavaScript模块化规范，它们在设计目标、使用场景、语法特性等方面存在显著差异。下面分别介绍这两种规范及其区别，并简要说明CommonJS的实现原理。
CommonJS
特点与使用场景:
•动态加载: CommonJS 规范主要用于Node.js等服务器端环境，它的模块加载机制是同步的。这意味着模块在运行时被加载，允许在代码中的任何时刻调用require()来加载模块。
•单线程: 由于Node.js环境是单线程的，同步加载不会导致阻塞问题。
•导出与导入: 使用module.exports或exports导出模块，使用require()函数导入模块。导出的是值的拷贝（如果是原始类型）或引用（如果是复杂类型如对象、数组）。
实现原理:
•当Node.js遇到require()调用时，它会查找并读取指定模块的文件。
•加载模块文件，执行其中的代码。模块中的module.exports或exports对象用于导出功能或数据。
•执行完毕后，require()返回导出的对象，这个过程是同步完成的。
ES Modules (ESM)
特点与使用场景:
•静态加载: ESM是ECMAScript 2015（ES6）引入的标准模块系统，适用于浏览器和现代服务器端环境（如支持ESM的Node.js版本）。模块的导入导出在编译阶段完成，是静态的。
•异步加载: ESM采用异步加载机制，有助于避免加载时的性能问题，特别是在浏览器环境中。
•导入与导出语法: 使用export关键字导出模块成员，使用import语句导入。ESM支持按需导入特定的导出项，以及命名空间导入和默认导入。
•模块作用域: 每个ESM模块都运行在自己的私有作用域中，自动采用严格模式。
基本类型的导入值在其导入的模块中是不可以被修改的，这既是因为基本类型的不可变性，也是ESM规范中对导入基本类型值的处理方式。如果需要可修改的数据，应该考虑使用引用类型（如对象或数组）并修改它们的属性。
与基本类型不同，引用类型在JavaScript中是通过引用（类似于指针）来存储的。当你修改引用类型的属性时，所有指向该相同内存地址的引用都会看到这一变化。
在这个例子中，bar.js修改了从foo.js导入的person对象的name属性，而这个修改对于同样导入了person的baz.js来说也是可见的，因为它们共享同一个对象实例。这就是引用类型在ES模块之间共享和修改的特性。
JavaScript

// foo.js
export const person = { name: "Alice" };

// bar.js
import { person } from './foo.js';
person.name = "Bob"; // 修改导入的对象的属性

// baz.js
import { person } from './foo.js';
console.log(person.name); // 输出 "Bob"，显示了在bar.js中所做的修改

区别总结:
1.加载时机: CommonJS是运行时加载，而ESM是编译（解析）时加载。
2.语法: ESM使用import和export关键字，而CommonJS使用require()和module.exports。
3.作用域与执行环境: ESM模块有独立的作用域，且默认启用严格模式；CommonJS模块共享全局作用域。
4.模块循环依赖处理: ESM有更明确的规则处理循环依赖，而CommonJS可能需要特别注意循环引用的问题。
5.适用平台: 历史上，CommonJS多用于Node.js服务端，ESM原生支持于现代浏览器和更新的Node.js版本。
总的来说，ES Modules提供了更现代、更符合模块化编程原则的解决方案，而CommonJS则在Node.js早期生态中奠定了基础。随着技术的发展，Node.js等环境也逐渐兼容并推荐使用ESM。

模块循环依赖处理
ESM处理循环依赖的方式
ESM在设计上更加严格，它通过静态分析在编译阶段确定模块间的依赖关系，这使得处理循环依赖有了更明确的规则。当两个ESM模块相互引用时，它们的顶层import和export会在编译阶段被解析，但实际的代码执行仍保持异步。在循环依赖的情况下，每个模块首次被导入时，其导出会被初始化为undefined或者是一个未完成的承诺（pending promise），直到模块执行完毕，导出的值才会被填充。因此，尽管存在循环依赖，每个模块至少能够导出一个未定义的值或待解决的引用，避免了某些情况下可能的死锁问题。
CommonJS处理循环依赖的方式
相比之下，CommonJS的模块加载是运行时发生的，且是同步的。这导致循环依赖可能导致未定义的行为或必须手动处理以避免问题。在Node.js中，当两个CommonJS模块互相require对方时，Node.js会先初始化这两个模块的exports对象为一个空对象，然后依次执行模块代码。如果一个模块在执行过程中尝试访问另一个模块的导出内容，而此时那个模块还没有完成执行并导出实际值，就可能遇到初始的空对象或未完成的状态。因此，开发者需要小心管理模块内部的逻辑，确保在访问依赖模块的导出之前，这些导出已经完成初始化。

Node.js：require函数的实现原理
Node.js中的require函数背后有一套复杂的模块加载机制，大致步骤如下：
1.路径解析: 首先，Node.js会对传递给require的模块路径进行解析，将其转换为绝对路径。这包括处理相对路径、核心模块查找、以及从node_modules目录中搜索模块。
2.模块缓存检查: 解析后的路径会检查Node.js的模块缓存。为了提高性能，Node.js会缓存已经加载过的模块，如果模块已经被加载过，直接从缓存中返回模块的exports对象。
3.模块加载: 如果模块不在缓存中，Node.js会根据文件扩展名（.js, .json, 或者原生模块）来决定如何加载模块。对于.js文件，Node.js会创建一个新的模块对象，该对象具有exports、require、module、__filename和__dirname属性。
4.模块代码执行: Node.js将模块的源代码包裹在一个函数中执行，这个函数接收exports、require、module、__filename和__dirname作为参数。这样做可以保证模块间不会污染全局作用域。
5.模块导出: 模块代码执行后，通过修改module.exports或exports对象来导出模块的方法或变量。执行完成后，require函数返回module.exports对象。

模块包装器在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：
(function(exports, require, module, __filename, __dirname) {     
   // 模块的代码实际上在这里
});
通过这样做，Node.js 实现了以下几点：
1.它保持了顶层的变量（用 var、const 或 let 定义）作用在模块范围内，而不是全局对象。 
(其实就是用闭包，使模块里定义的变量或函数有自己的作用域，避免全局作用域污染。而且模块里面的变量，函数，类都是私有的，对外不可见，需要对外公开的接口，可以赋值给module.exports属性或exprots变量)
2.它有助于提供一些看似全局的但实际上是模块特定的变量，例如：实现者可以使用 module 和 exports 对象从模块中导出值，快捷变量 filename 和 dirname 包含模块的绝对文件名和目录路径。

Webpack：require函数的模拟
一个打包工具，它在构建过程中模拟了CommonJS的require行为，
以便能够在浏览器环境中使用模块化代码。
Webpack通过以下方式实现：
•静态分析: Webpack对项目中的所有文件进行静态分析，识别出模块依赖关系。
•编译转换: 将ESM或CommonJS模块转换为浏览器可理解的格式，比如通过打包成一个或多个捆绑文件（bundle）。
•chunk加载: Webpack支持代码分割（code splitting），这意味着它可以按需加载模块（chunks），模拟类似异步加载的效果。
•runtime注入: Webpack在最终的输出文件中注入了一个小型的运行时（runtime），负责模块的动态加载和解析。当浏览器执行代码时，这个runtime会根据需要异步加载模块。

35. Webpack 和 vite 打包原理？主要有什么区别？Webpack 迁移 vite 的具体好处有哪些？
webpack打包
1.读取配置内容，初始化Compiler对象，加载配置的插件plugin，然后运行run方法开始编译流程。
2.根据 entry属性，确定项目入口，对入口文件进行模块分析。
3.根据源代码，得到抽象语法树ast，收集模块依赖，最后将ast转化为可执行模块代码，一般采用降级处理，可以将ES6及以上的代码转化为兼容ES5的代码。
4.同理，通过递归处理每个模块的依赖文件，最后形成一张包含了所有模块代码的依赖图。
5.对于其他格式的文件，会有相应的loader去处理，最后都会转化为浏览器可执行的文件。
6.当编译流程完成后，webpack会将所有的模块组成多个chunk，每个chunk就是由多个模块组成的代码块。
7.最后，这些chunk会根据配置的输出路径和文件名，转化为一个或者多个文件，也就是bundle。
8.在webpack打包的过程中，会有很多的生命周期事件。插件(plugin)可以监听这些事件，改变构建结果，比如压缩代码、降级处理、去除console.log、定义全局变量 等功能插件，进一步扩展了webpack的功能，
Vite 打包原理
1.Vite 利用浏览器原生支持的 ES module 特性，在<script type="module">中，浏览器遇到内部的import引用时，会自动发起http请求，去加载对应的模块。
2.Vite 在开发环境下不需要像webpack一样对项目整体打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行按需编译，然后返回给浏览器。
Vite 优劣势
3.用 import 语法 可以静态分析模块依赖，实现动态加载、按需打包、减少热更新时间。 
4.vite 用 ESBuild 进行预构建，实现一些第三方库的打包和转译，打包性能极好。
5.Vite 预构建具有缓存【.vite文件】，已构建的依赖请求会先走浏览器强缓存，两者都不命中才会重新编译依赖。
6.Vite 充分利用了http2 并发请求的优势，因为拆分成多个小模块去加载，通常会造成首次加载时，并发请求过多。
7.vite 可能会带来开发环境与生产环境打包结果不一致的问题
a.开发环境：预构建与按需编译esbuild
b.生产环境: 用 rollup 打包，生态上的考虑。
Vite 打包的常见优化策略


36. Webpack 迁移 vite 可能会遇到哪些问题？
es生态
Vite 使用了一种基于原生 ES 模块的加载机制，因此不支持一些 Webpack 加载器和预处理器。
Vite 鼓励使用 ES 模块作为默认模块系统，而不同于 Webpack 的 CommonJS。
因此，在迁移过程中，你可能需要将代码从 CommonJS 转换为 ES 模块。

插件生态
提前调研 vite 是否有相应功能的插件

首页加载可能变慢
Vite 开发时，进入首页可能会发送较多的网络请求 。
路由懒加载，尝试更先进的代码分割策略【条件编译，实现新老入口分开打包】

esbuild和webpack内部的babel 转化 jsx语法的区别
比如：转化ts的装饰器语法，esbuild根据tsconfig设置，babel根据插件的遗产模式设置，
可能需要 对mobx等：使用不同装饰器版本进行调研和升级。

vite 可能会带来开发环境与生产环境打包结果不一致的问题
1.开发环境：预构建与按需编译esbuild
2.生产环境: 用 rollup 打包，生态上的考虑。

配置项的差异
•webpack通过 definePlugin定义 env，vite 用 import.meta.env
•Vite 使用了更现代化的 CSS 处理方式，例如原生支持 CSS Modules 和 CSS 预处理器。
•如果用了特定的 CSS 插件或加载器（如 PostCSS），需要确认 Vite 是否有相应的替代方案或兼容插件。 
•配置别名的方式

37. 说说https的完整流程？http与https的区别是什么？数字证书是什么？客户端怎么验证的？
概念
超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
TLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。
这三类算法的作用如下：
•基于散列函数验证信息的完整性
常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

•对称加密算法采用协商的秘钥对数据加密
对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

•非对称加密实现身份认证和秘钥协商
非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。



SSL/TLS 协议基本流程
•客户端向服务器索要并验证服务器的公钥。
•双方协商生产「会话秘钥」。
•双方采用「会话秘钥」进行加密通信。
前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。
TLS 的「握手阶段」涉及四次通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，
现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法 (opens new window)。
HTTPS通信（握手）过程
基于 RSA 算法的TLS 协议建立的详细流程
1.ClientHello
首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。
在这一步，客户端主要向服务器发送以下信息：
（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。
（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。
（3）客户端支持的密码套件列表，如 RSA 加密算法。
2.SeverHello
服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：
（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。
（3）确认的密码套件列表，如 RSA 加密算法。
（4）服务器的数字证书。
3.客户端回应
客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。
服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。
3.服务器的最后回应
服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。
然后，向客户端发送最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。
至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

总结
https：三次握手 + 四次TLS协议握手 +普通的 HTTP 协议【对称加密】
不过，基于 RSA 算法的 HTTPS 存在「前向安全」的问题：
如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。
为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。

https加密证书怎么做的？客户端（浏览器）具体是怎么验证服务器的数字证书的？
步骤
•生成密钥对：首先，服务器需要生成一对公钥和私钥。公钥用于加密数据，私钥用于解密数据。
•申请数字证书：服务器将公钥和一些身份信息发送给证书认证机构（CA）。CA会验证这些信息，并用CA的私钥对这些信息进行签名，生成数字证书2。
•安装数字证书：服务器将数字证书安装在服务器上。当客户端（如浏览器）请求HTTPS连接时，服务器会发送其数字证书。
客户端（浏览器）验证服务器的数字证书的过程主要包括以下步骤：
•获取证书：当客户端向服务器发出HTTPS请求时，服务器会返回其数字证书。
•检查证书颁发机构：客户端会检查证书是否由可信任的证书认证机构（CA）颁发。这是通过检查操作系统或浏览器内置的受信任CA列表来完成的。
•验证证书签名：客户端会使用CA的公钥（从内置的CA证书中获取）来验证服务器证书的签名。
•检查证书有效期：客户端会检查证书的有效期，确保证书没有过期。
•验证证书中的域名：客户端会验证证书中的域名与正在访问的网站域名是否一致。
简述
•前提服务器注册公钥到数字证书验证机构CA，CA用自己的私钥将服务器的公钥数字加密成数字证书，客户端内置CA的公钥。
•当https发送服务器的数字证书后，客户端利用CA的公钥验证数字证书的有效期、真实性、域名是否一致。
•最后得到服务器的公钥，用它加密报文发送给服务器。
中间人攻击
混合加密的方式实现信息的机密性，解决了窃听的风险。
摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
将服务器公钥放入到数字证书中，解决了冒充的风险。
结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，
然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。
此时⼜带来⼀个问题，
中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。
所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。
证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。
但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。
数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。
HTTPS 一定安全可靠吗？
具体过程
•客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；
•在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。
•在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。
•后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。
从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。
但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。
中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器。
为什么抓包工具能截取 HTTPS 数据？
很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。
对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:
1.中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2.中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；
中间人要拿到私钥只能通过如下方式：
1.去网站服务端拿到私钥；
2.去CA处拿域名签发私钥；
3.自己签发证书，切要被浏览器信任；
不用解释，抓包工具只能使用第三种方式取得中间人的身份。
使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。
抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。
如何避免被中间人抓取数据？
我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。
当然，我们还可以通过 HTTPS 双向认证来避免这种问题。
一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。

38. 如何防御网络攻击？说说常见的网络攻击形式。
xss 攻击
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。
攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，最后盗取用户的信息。
•获取页面的数据，如DOM、cookie、localStorage
•DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器
•破坏页面结构
•流量劫持（将链接指向某网站）

xss 分类
•存储型：指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
•反射型：指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
•DOM 型：指的通过修改页面的 DOM 节点形成的 XSS。DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。

xss 防御
•可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
•使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
1.CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
2.通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 
•对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。
•可以使用验证码，避免脚本伪装成用户执行一些操作。
csrf攻击
CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
本质
CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
这是因为浏览器会自动带上与请求目标站点相关的 cookie，即使这个请求是在另一个站点上发起的。
然而，这并不意味着 CSRF 攻击只能在同源请求中发生。实际上，CSRF 攻击通常发生在跨站请求中。攻击者会在他们控制的站点上创建一个请求，这个请求指向目标站点并在一些情况下会触发一些操作（例如，更改邮箱地址，转账等）。当受害者访问攻击者的站点时，这个请求会被发送到目标站点，而浏览器会自动带上与目标站点相关的 cookie。由于这个请求看起来就像是由受害者自己发起的，所以目标站点就会执行这个请求所触发的操作。
因此，尽管 CSRF 攻击利用的是 cookie 在同源请求中的行为，但是攻击本身通常是在跨站请求中进行的。
分类
GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。
csrf防御
•进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）
•使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。
•对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
•在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有3种模式。
￮一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用。
￮宽松模式 Lax，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用，但 post请求就不会包含cookie，一定程度上防止csrf。
￮无限制模式 None，相对危险，浏览器会在跨站请求时始终发送 Cookie。这意味着即使请求来自其他站点，浏览器也会发送 Cookie。这种模式需要慎重使用，因为它可能导致安全风险，可能会被滥用。
Cookie 【Samesite：Lax 模式】的理解
假设你正在浏览一个社交媒体网站，比如 socialmedia.com，并且你已经在这个网站上登录了。这个网站为你的浏览器设置了一个包含你的会话信息的 Cookie，这个 Cookie 的 SameSite 属性被设置为 Lax。
现在，假设你在另一个网站 news.com 上看到了一个链接，这个链接指向 socialmedia.com 的一个页面。你点击了这个链接。
由于 SameSite=Lax，当你从 news.com 跳转到 socialmedia.com 时，你的浏览器会将 Cookie 发送到 socialmedia.com。因此，当你到达 socialmedia.com 时，你仍然是登录状态。
但是，如果你在 news.com 上看到一个表单，这个表单的提交动作是向 socialmedia.com 发送 POST 请求，那么在这种情况下，由于 SameSite=Lax，你的浏览器不会在这个 POST 请求中包含 Cookie。这就防止了跨站请求伪造（CSRF）攻击。
总的来说，SameSite=Lax 允许在进行顶级导航（例如点击链接进行页面跳转）时发送 Cookie，但是在其他类型的跨站请求（例如 POST 请求）中不发送 Cookie。这提供了一种折中的安全策略，既能防止 CSRF 攻击，又能在用户期望的情况下保持登录状态。。希望这个例子能帮到你！

token怎么预防csrf攻击？
Token是一种常用的防止CSRF（跨站请求伪造）攻击的方法。
基本原理
生成Token：服务器生成一个随机的、唯一的Token。
发送Token：当用户访问一个需要安全防护的页面时，服务器将Token嵌入到页面的表单中。
提交Token：用户提交表单时，Token会被一同提交到服务器。
验证Token：服务器接收到请求后，会验证表单中的Token是否与服务器之前发送给该用户的Token一致。
注意事项
只有当Token验证通过，服务器才会处理该请求，否则服务器将拒绝该请求。这样，即使攻击者可以伪造请求，但由于他们无法获取到正确的Token，因此无法成功发起CSRF攻击。值得注意的是，Token的保密性和随机性非常重要。
如果Token被攻击者获取，那么攻击者仍然可以伪造带有正确Token的请求来发起CSRF攻击。因此，我们需要确保Token在传输和存储过程中的安全，并且要确保Token的随机性，使得攻击者无法预测Token的值。
其他措施
验证码、在HTTP头中自定义属性并验证、验证HTTP Referer字段等。
39. typescript你用的多吗？你对interface、class、type如何理解的？各自在什么场景下使用。
主要用于完善函数组件的 state 和 props 的类型，便于开发时，静态编译查找错误，方便mock数据。
总结
type与interface在TypeScript中都是用来定义类型的关键字，但它们之间存在一些关键差异：
1.数据形状与类型定义:
￮interface主要用于描述对象的形状，即定义一个结构应该包含哪些属性和方法，不关注这些属性的具体类型是否已知。它适合描述具有多个属性的对象结构，尤其是当这些属性的具体类型可能是复杂类型或需要额外描述时。
￮type则更灵活，不仅可以定义基本类型、联合类型、元组类型等，还能创建类型别名，特别适用于函数类型、联合类型以及更复杂的类型构造。它能直接定义一个具体的类型或者对现有类型进行组合或改造。

2.实现与继承:
￮类(class)可以通过implements关键字实现interface，确保类遵循接口定义的结构。
￮type虽然可以为类的属性和方法提供类型定义，但它本身不能被类直接实现，更适合于类型系统内部的抽象和构造。
￮interface之间可以通过extends关键字实现继承，积累和扩展属性和方法定义。

3.泛型与复合类型:
￮两者都支持泛型的定义与使用，但在复合类型如交叉类型(&)和联合类型(|)上有所区别。
￮interface自身不能直接作为交叉或联合类型的产物，但可以作为这些复合类型的一部分。而type没有这样的限制，既可以直接定义为交叉或联合类型，也能参与构成这些复合类型。

4.适用场景:
￮当需要强调对象结构和接口约定时，interface更为合适，尤其是在需要实现多态或描述API形状的场景。
￮对于复杂的类型操作、类型组合或创建类型别名以简化复杂类型表达时，type因为其灵活性而成为更好的选择。

总结来说，interface倾向于描述对象结构和接口规范，支持类的实现和接口间的继承；而type则是一个更强大的类型工具，适合创建类型别名、处理复杂类型构造及进行类型系统层面的抽象。根据实际需求中对类型的具体要求和使用场景的不同，选择合适的工具来定义类型。

区别
•interface：定义数据的形状,具体这个数据结构如何,有哪些属性,如定义一个 object;
•type：定义数据的类型，指一个数据具体值是什么类型，如 boolean，string。
•type 更倾向于创建类型别名，特别是对于函数类型、联合类型的情况。而 interface 则更多用于描述对象形状或类的结构。两者都完全支持泛型的定义与使用。

•Interface 与 class
￮类（Class）可以通过 implements 关键字来实现一个或多个接口，这意味着类必须提供接口中定义的所有属性和方法的实现。
￮但是 type 类型别名 不可以用 implements 关键字，只能用于描述 class 的属性类型 和 方法中的类型。
•Interface 之间的继承：
接口可以继承其他接口，使用 extends 关键字。这允许一个接口在其基础上添加更多成员或重用现有接口的成员定义。
•interface 不能作为交叉、联合类型的产物，但可以作为其组成元素，而 type 就没有什么限制既可以作为组成元素又可作为产物。


类的理解
•类（class）是面向对象编程中的核心概念，它不仅定义了对象的结构（属性和方法），还提供了方法的实现。
•类可以实现继承、封装和多态等面向对象特性，支持构造函数、访问修饰符（public, private, protected）等。
￮对象实例化：当需要创建具有共同特性和行为的对象实例时。
￮继承和复用：通过继承父类来复用代码和扩展功能。
￮封装：隐藏实现细节，只暴露必要的接口给外部调用。


40. 闭包是什么？什么时候用过？闭包会导致的问题？
概念
•闭包是指有权访问另一个函数作用域中变量的函数。创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
•比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
•函数闭包是指一个函数（内部函数）可以访问其包含外部函数作用域（父函数）的变量，即使外部函数已经执行完毕。
•这意味着内部函数"捕获"了外部函数的变量状态，并可以继续使用这些变量，即使外部函数已经退出执行。

用途
•闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
•闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

要点
1.内部函数访问外部函数变量：内部函数可以访问外部函数中声明的变量，包括参数和其他局部变量。
2.外部函数已经返回：闭包允许外部函数执行完毕后，内部函数仍然能够访问外部函数的变量，这是因为 JavaScript 引擎会保留外部函数的作用域链。
3.保持状态：闭包可用于创建私有变量和保持状态。内部函数可以使用外部函数的变量，同时外部函数的变量不会被其他函数访问，因此这些变量的状态得以保持和修改。
JavaScript
function outerFunction() {
  let outerVariable = 10;

  function innerFunction() {
    console.log(outerVariable); // 内部函数访问外部函数的变量
  }

  return innerFunction; // 返回内部函数
}

const myClosure = outerFunction(); // 外部函数执行，但返回内部函数

myClosure(); // 执行内部函数，仍然可以访问 outerVariable
在这个示例中，outerFunction 返回了 innerFunction，并且 innerFunction 仍然能够访问 outerVariable，即使 outerFunction 已经执行完毕。这是函数闭包的核心特性，它允许我们在 JavaScript 中实现许多有用的模式，如模块模式、私有变量和函数工厂。
JS闭包是一个非常有用的特性，它可以让你在一个函数内部访问到外部函数的变量和参数，从而实现一些高级的功能，比如：
•封装私有变量和方法，防止被外部修改或污染。【函数返回getName，获取函数私有变量的值】
•实现柯里化（currying）和偏函数（partial application），即通过预设一些参数来创建新的函数。
JavaScript
// 创建一个柯里化函数，它可以接受一个函数和一些参数，然后返回一个新的函数
function curry(fn, ...args) {
  // 返回一个新的函数
  return function(...newArgs) {
    // 将之前的参数和新的参数合并起来
    let allArgs = [...args, ...newArgs];
    // 调用原始的函数，并传入合并后的参数
    return fn.apply(this, allArgs);
  };
}
•实现模块化（module pattern），即通过返回一个对象来暴露一些公共的属性和方法，而隐藏内部的细节。
•实现记忆化（memoization），即通过缓存一些计算结果来提高性能。
JavaScript
// 创建一个记忆化函数，它可以接受一个函数，并返回一个新的函数，该函数会缓存计算结果
function memoize(fn) {
  // 用一个对象来存储缓存结果，它不会被外部访问到
  let cache = {};
  // 返回一个新的函数
  return function(...args) {
    // 将参数转换为字符串，作为缓存的键
    let key = JSON.stringify(args);
    // 如果缓存中已经有该键对应的值，直接返回该值
    if (cache[key]) {
      return cache[key];
    }
    // 否则，调用原始的函数，并传入参数，得到结果
    let result = fn.apply(this, args);
    // 将结果存入缓存中，并返回结果
    cache[key] = result;
    return result;
  };
}
闭包内存泄漏
根据词法作用域的规则，能否访问到相关变量是根据写代码的位置，而不是代码如何调用。
如果外层函数执行完毕，但内部函数被保存下来使用且始终不销毁，
那么维持外层函数变量的那块内存就始终得不到释放，这就可能造成内存泄漏。
应用场景
日常：函数柯里化、封装私有变量和方法、模块化编程【暴露公共方法，但隐藏内部细节】、记忆化【缓存结果来提高性能】
vue： get和set函数使用闭包保持对value和dep的引用。当属性被访问时，get函数将当前 Watcher 添加到依赖中，这就是闭包的作用之一，它使得get函数能够访问currentWatcher。当属性被修改时，set函数通知依赖对象（dep）并触发更新操作。
React ： 依赖设置不正确，访问到旧值，因为useEffect中的回调函数在闭包中捕获了组件渲染时的变量值，而不是在每次渲染时重新获取最新值。

41. 说说原型链？proto属性 与 prototype 分别是什么？两者有什么区别呢？
原型链
是一种JS用于实现继承和共享属性的机制。
原型对象
是每个函数在创建时自动生成的一个对象，它存储了该函数的公共属性和方法。
__proto__属性
•是每个对象都有的一个隐式属性，它指向该对象的构造函数的原型对象。
•当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，
这个原型对象又会有自己的原型，于是就这样一直找下去，这样就形成了一个链式结构，也就是原型链。
•通过__proto__属性，一个对象可以访问到它的构造函数的原型对象上的属性和方法，以及更上层的原型对象，
直到Object.prototype为止，所以这就是新建的对象为什么能够使用 toString() 等方法的原因。
•__proto__属性它不是规范中规定的，ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。
区别
原型对象：是每个构造函数创建时自动生成的一个对象，存储公共属性和方法，即 Fn.prototype
__proto__属性： 是每个对象实例的一个隐式属性，它指向该对象的构造函数的原型对象，即 f1.__proto__ ===  Fn.prototype。通过 Object.getPrototypeOf()方法，获取每个对象实例的原型对象。

new 和 Object.create 的区别
•new操作符用于创建一个构造函数的新实例。当使用new操作符时，JavaScript会创建一个新的空对象，然后将这个空对象作为this上下文传递给构造函数。因此，构造函数内部的任何对this的引用都会指向新创建的对象。
•Object.create则是创建一个新对象，并将现有对象设置为新对象的原型。这意味着新对象将继承现有对象的所有属性和方法。
•与new不同的是，Object.create并不会调用或者执行 当前传入的构造函数 或者 对象。因此，如果原型对象中包含初始化在构造函数中的属性，那么这些属性不会被复制到新对象中。
•如果你需要一个完全独立的新实例，并且需要调用构造函数进行初始化，那么应该使用new。
•如果你只是想创建一个继承自另一个对象的新对象，并且不需要调用构造函数，那么应该使用Object.create。
JavaScript
function Person(name) {
    this.name = name
}
// 修改原型
Person.prototype.getName = function() {}
var p = new Person('hello')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // true
// 重写原型
Person.prototype = {
    getName: function() {}
}
var p = new Person('hello')
console.log(p.__proto__ === Person.prototype)        // true
console.log(p.__proto__ === p.constructor.prototype) // false




Person.prototype = {
    getName: function() {}
}
var p = new Person('hello')
p.constructor = Person
console.log(p.__proto__ === Person.prototype)        // true
console.log(p.__proto__ === p.constructor.prototype) // true
p.__proto__  // Person.prototype
Person.prototype.__proto__  // Object.prototype
p.__proto__.__proto__ //Object.prototype
p.__proto__.constructor.prototype.__proto__ // Object.prototype
Person.prototype.constructor.prototype.__proto__ // Object.prototype
p1.__proto__.constructor // Person
Person.prototype.constructor  // Person


JavaScript
function mynew(fn,...args) {
    let obj = {}
    Object.setPrototypeOf(obj, fn.prototype)
    let res = fn.apply(obj, args);
    return res instanceof Object ? res : obj;
}
function myNew(constructor,...args){
    const obj = Object.create(constructor.prototype);
    obj.constructor = constructor;
    let res = constructor.apply(obj,args);
    return res instanceof Object ? res : obj;
}

function Object_create(obj) {
    function c() { }
    c.prototype = obj;
    return new c();
}

42. 浏览器性能指标通常关注哪些？你们是怎么看的？知道如何计算xxx指标的值吗？
浏览器常见指标
￮FP (First Paint)：首次绘制时间，这个指标用于记录页面第一次绘制像素的时间。
￮FCP (First Contentful Paint)：首次内容绘制时间，是浏览器首次渲染页面上的第一个DOM元素的时间点。这个指标用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。FCP 只是记录了加载体验的最开始。如果页面显示的是启动图片或者loading动画，这个时刻对用户而言没有意义。FCP >= FP。
￮LCP (Largest Contentful Paint)：最大内容绘制时间，用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。LCP 是一个以用户为中心的性能指标，可以测试用户感知到的页面加载速度，因为当页面主要内容可能加载完成的时候，它记录下了这个时间点。一个快速的LCP，可以让用户感受到这个页面的可用性。
￮DOMContentLoaded：HTML 加载完成时间，代表 纯 HTML 被完全加载以及解析。
￮Load ：页面完全加载时间，代表 整个页面及所有依赖资源如样式表和图片都已完成加载。
￮FID (First Input Delay)：首次输入延迟，这个指标用于衡量用户首次和网站进行交互到浏览器响应该事件的实际延时时间。
￮TTI (Time To Interact)：首次可交互时间，这个指标用于衡量页面可交互的性能。
￮CLS (Cumulative Layout Shift)：累计布局偏移，这个指标用于衡量页面在加载过程中，视觉元素移动的程度。
￮FMP( First Meaningful Paint，首次有效绘制) 是标记主角元素渲染完成的时间点，主角元素可以是视频网站的视频控件，内容网站的页面框架，也可以是资源网站的头图等。
￮TTFB（Time To First Byte）是一个衡量网页性能的关键指标，它表示从用户浏览器发起一个HTTP请求到接收到服务器响应的第一个字节之间的时间间隔。这个时间包括了DNS查找、TCP连接建立、发送HTTP请求以及服务器处理请求并生成响应的时间。

监控指标实现
JavaScript
// 推荐
data = window.performance.getEntriesByType('navigation')[0]
// 待废弃 
data = window.performance.timing
DOMContentLoaded ｜ DOM Ready
JavaScript
data['domInteractive']- data[ 'startTime']
Load ｜ 页面完全加载 (首次渲染时间+DOM解析耗时+同步JS执行+资源加载耗时)
JavaScript
data['loadEventStart']- data['fetchStart']
首次内容绘制(FCP)
JavaScript
const entries = window.performance.getEntries();
const filterRes = entries.filter((entry) => {
      return entry.entryType === 'paint'
})
filterRes.forEach((item) => {
    if (item.name === 'first-contentful-paint') {
        console.log( 'FCP：',item.startTime)
    }
})
最大内容绘制(LCP)
JavaScript
const observer = new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries();
    const lastEntry = entries[entries.length - 1];
    const lcp = lastEntry.renderTime || lastEntry.loadTime;
    console.log( 'LCP:', lcp)
});
observer.observe({entryTypes : [ 'largest-contentful-paint']});
首次像素绘制(FP)
JavaScript
const entries = window.performance.getEntries();
const filterRes = entries.filter((entry) => {
      return entry.entryType === 'paint'
})
filterRes.forEach((item) => {
    if (item.name === 'first-paint') {
        console.log( 'FP：', item.startTime)
    }
})
TTFB（Time To First Byte）
JavaScript
这段JavaScript代码片段使用了浏览器的`Performance`接口来获取页面性能指标，
并特别针对Paint Timing API过滤出与“paint”相关的性能条目。
然而，它并没有直接计算TTFB（Time To First Byte），
而是用于获取First Contentful Paint (FCP) 的时间戳即浏览器渲染第一个文本、图像或其他非空白内容的时间。
要计算TTFB，我们需要访问网络请求的相关信息，
可以通过`PerformanceResourceTiming`接口获得。
以下是一个修改后的示例，用于获取文档加载过程中的TTFB：


const entries = window.performance.getEntriesByType('navigation');
const navigationEntry = entries[0];
const ttfb = navigationEntry.fetchStart - navigationEntry.startTime;
console.log('TTFB: ', ttfb);
// 或者，如果你想要获取特定资源的TTFB：
const resourceEntries = window.performance.getEntriesByType('resource');
resourceEntries.forEach((entry) => {
    if (entry.initiatorType === 'xmlhttprequest' || 
    entry.initiatorType === 'fetch' || 
    entry.initiatorType === 'img' || entry.initiatorType === 'link' /* ... */ ) {
        // 根据需求选择合适的资源类型
        const ttfbForResource = entry.responseStart - entry.requestStart;
        console.log(`TTFB for ${entry.name}: `, ttfbForResource);
    }
});


上述代码中，对于主文档（即HTML页面）加载时的TTFB，
我们通常关注`navigation`类型的条目，通过`fetchStart`（
浏览器开始准备 fetch 操作的时间点）减去`startTime`（导航开始时间）来得到。

对于具体资源加载时的TTFB，则是通过`responseStart`
（接收到响应的第一个字节的时间点）
减去`requestStart`（发送HTTP请求或TCP连接建立完成的时间点）。
TTFB、FMP、LCP、TTI、Loaded、DOMContentLoaded 常见指标的统计方法和适用场景
1.  Time to First Byte (TTFB)
统计方法：TTFB测量的是从浏览器发起一个HTTP请求到接收到服务器响应的第一个字节所需的时间。这个时间包括网络延迟、DNS查询、TCP连接建立、SSL握手（如果适用）以及服务器处理请求并生成响应的部分时间。可以通过浏览器开发者工具中的网络面板（Network tab）查看每个请求的TTFB值。
   适用场景：TTFB主要用来评估服务器响应速度和网络延迟，对于优化后端服务、CDN配置、数据库查询效率等有直接指导意义。它对于页面加载初期的用户体验至关重要，特别是对于首字节加载速度敏感的应用（如实时聊天、在线交易等）。
2. First Meaningful Paint (FMP)
统计方法：FMP表示用户首次看到“有意义”内容的时刻，即页面加载过程中首次呈现对用户有用或与用户任务相关的内容。由于FMP的定义较为主观且难以自动化度量，现代浏览器并未提供直接的API来获取FMP。早期实践中，可能通过分析浏览器性能记录（如PerformanceTiming API）中的关键渲染事件或使用第三方工具来估算。然而，随着性能指标的发展，FMP逐渐被其他更明确、易于度量的指标替代，如Largest Contentful Paint (LCP)。

  适用场景：虽然FMP作为一个具体指标已较少被直接使用，但其理念——关注用户感知到的初始内容呈现——仍然适用于性能优化。如今，LCP作为FMP的替代，更准确地捕捉到用户视窗内最大内容元素的渲染时间，用于评估首屏内容的加载速度。
3. Largest Contentful Paint (LCP)
统计方法：LCP是现代Web性能指标之一，可通过浏览器提供的`PerformanceObserver`接口来监听并记录。它衡量从页面加载开始到用户视口内可见的最大图像或文本块（通常是首屏最重要的内容元素）渲染完成的时间。浏览器原生支持LCP的测量，开发者无需手动计算。
 适用场景：LCP适用于评估网页首屏内容的加载性能，特别是在新闻、电商、社交媒体等重视首屏视觉冲击力和信息传达效率的场景中。优化LCP有助于提高用户对页面加载速度的满意度，因为它直接影响用户对内容可用性的感知。
4. Time to Interactive (TTI)
统计方法：TTI衡量的是从页面开始加载到页面的主要资源加载完毕，且能够快速响应用户输入（如点击、滚动）的时间点。计算TTI通常涉及多个因素，包括但不限于CPU空闲时间、主线程任务执行情况、关键资源加载完成等。浏览器性能分析工具（如Chrome DevTools）会自动计算TTI，并在性能记录中提供。
适用场景：TTI适用于复杂单页应用（SPA）和交互式网站，这些站点要求用户能够在加载过程中尽早进行交互。优化TTI有助于提升用户对网站响应速度的感知，减少加载期间的卡顿感，特别适用于电商、社交平台、在线游戏等对交互体验要求高的场景。
Chrome DevTools 提供了可视化界面来计算并展示 Time to Interactive (TTI)，但并没有直接提供一个内置的JavaScript API来让开发者在代码中直接获取这一计算结果并上报。然而，尽管不能直接获取DevTools计算的TTI值，开发者仍然可以通过编写JavaScript代码来模拟DevTools的计算逻辑，从而估算TTI并在页面中上报给相应的性能监控服务。

1. 监听关键性能指标：
   - 使用 `PerformanceObserver` 监听相关性能指标事件，如 `longtask`、`resource`、`paint`、`largest-contentful-paint` 等。这些事件可以帮助您追踪主线程任务、资源加载以及视觉变化等情况。
 const observer = new PerformanceObserver((list) => {
     list.getEntries().forEach((entry) => {
       // 处理不同类型的性能事件，如 longtask、resource、paint 等
     });
   });

   observer.observe({ entryTypes: ['longtask', 'resource', 'paint'] })

2. 模拟TTI计算逻辑：
   - 根据TTI的定义，分析收集到的性能数据，识别关键资源加载完成时间、主线程空闲时段以及渲染稳定时刻。
   - 实现算法来判断主线程何时达到足够长的连续空闲时间（例如，连续50毫秒无长任务执行），同时确保关键资源已加载且页面呈现基本稳定。
   - 可能需要维护一个状态机或使用其他方法来同步处理多个事件流，确保准确捕捉到TTI发生的时刻。

3. 上报TTI值：
   - 一旦估算出TTI，可以使用您选择的上报机制（如 AJAX 请求、Beacon API、第三方监控库等）将TTI值发送到您的性能监控服务器。

请注意，由于TTI计算较为复杂且依赖于特定的算法和阈值，自行实现时需要仔细研究和理解其背后的原理，并可能需要不断调整和优化算法以更准确地模拟Chrome DevTools或其他业界认可的TTI计算方法。此外，确保上报逻辑不会对实际页面性能造成过多影响，避免上报操作自身成为影响TTI的因素。

市面上已有成熟的第三方性能监控库（如WebPageTest、Lighthouse、SpeedCurve等）提供了封装好的TTI计算和上报功能，使用这些库可以简化实现过程并确保计算方法的准确性。如果条件允许，使用专业工具或服务通常是更推荐的选择。
TypeScript
  function reportTTI(ttiValue) {
     // 使用您选择的上报方式将TTI值发送到服务器
     fetch('/performance', {
       method: 'POST',
       body: JSON.stringify({ tti: ttiValue }),
       headers: { 'Content-Type': 'application/json' },
     });
   }

   // 假设已计算出TTI值
   const estimatedTTI = calculateTTI(performanceData);
   reportTTI(estimatedTTI);
5. Loaded
统计方法：这里的“Loaded”可能指代`window.onload`事件触发的时间，即整个页面（包括所有资源，如图片、脚本、样式表等）完全加载完毕的时刻。开发者可以通过监听`onload`事件并在回调函数中记录时间来获取这一指标。
适用场景：`onload`事件适用于衡量页面整体加载完成的时间点，尤其当页面包含大量非关键资源（如位于折叠区域的图片、非立即使用的脚本等），且对这些资源的加载完成有严格要求的情况下。不过，对于现代性能优化实践而言，通常更关注首屏内容的加载（如使用LCP），而非所有资源的完全加载。
6. DOMContentLoaded
统计方法：`DOMContentLoaded`事件发生在HTML文档结构完全解析和DOM树构建完成之时，不等待样式表、图片和其他外部资源加载完成。开发者可以通过监听`DOMContentLoaded`事件并在回调函数中记录时间来获取这一指标。
适用场景：`DOMContentLoaded`适用于评估页面结构加载的速度，对于依赖DOM结构进行初始化操作（如执行JavaScript代码、启动路由逻辑、渲染动态内容等）的网站尤为重要。优化`DOMContentLoaded`时间可以加快页面初步可用的时间点，提高用户对页面加载速度的感知，尤其是在单页应用和依赖JavaScript进行交互的站点中。

总结来说，以上指标分别关注不同阶段的加载性能和用户体验，选择和优化指标应根据网站特性和用户期望来确定。现代Web性能优化实践中，LCP、TTI、DOMContentLoaded等指标更为常用，而FMP已逐渐被LCP取代，TTFB则主要用于评估网络层和服务器响应性能。Loaded（`window.onload`）在特定场景下仍具有参考价值，但通常不作为首要优化目标。

浏览器性能指标检测工具
￮Google Lighthouse：是用于提高网页质量的开源自动化工具。您的前端开发人员至少应使用Lighthouse指标，该指标在Google Chrome浏览器工具中可用。
￮Chrome DevTools：这是Chrome浏览器中的一个工具，可以用来记录交互阶段和加载阶段的性能数据。
￮Sitespeed.io：这是一个开源工具，可以根据性能最佳做法和时间指标来分析网站的速度和性能。
￮性能监视器工具：这是Microsoft Edge浏览器中的一个工具，可以获取网页运行时性能的实时视图。
￮网络监视器和性能监视器：这是Firefox浏览器中的工具，可以展示你的网站加载的快慢。


43. 为什么要用 Node 做 BFF 中间层，有什么坏处？会有什么收益？你觉得 BFF 层还可以做哪些更深层次的东西？
我觉得可以分为三点， 业务实际情况、Java 在大数据计算上的优势、BFF层的好处。
•从业务实际情况来说，项目早期很多代码就是 Node.js 后端，直接迁移到 Java 提供 http 接口的模式成本太高。
•Java 在 大数据处理的生态和 高并发问题的系统方案可能更成熟些吧，Java 后端更好招人也算是原因吧。
￮大数据处理：Java在大数据处理方面有着丰富的生态系统。许多大数据处理框架，如Hadoop、Spark等，都是用Java编写的。这些框架提供了处理大规模数据的能力，包括数据存储、查询、分析等。
￮高并发处理：Java的多线程能力使其在处理高并发问题时表现出色。Java提供了多种并发工具，如ExecutorService、Fork/Join框架等，可以帮助开发者更有效地管理线程，提高并发处理的效率。
￮node的v8引擎有内存限制
•Node.js 有 性能开销小、异步编程、开发思想负担等特点，适合并发I/O、实时性较高，适合做为BFF层语言。
【性能开销小，事件循环机制，天然支持高并发。】
a.首先，我觉得Node.js最明显的优势是前后端语言统一，让前端工程师有独立写服务端的能力，适合用Node.js写一些大家需要的工具类项目，框架，脚手架等。
b.第二点，因为Node.js的异步I/O操作与前端常见的ajax调用是类似的，这种异步编程的思维很适合前端去做，而且Node.js 写一个简单服务代码量很少，上手简单，开发快。
c.第三点，Node.js保留了js单线程的特点，没有死锁，没有线程上下文交互，所以性能开销小，开发时思想负担更少，这种就很适合一些低资源占用、要求开发效率高的场景。
d.第四点，因为Node.js的并行I/O无论是在开发效率上，还是在性能方面都有明显优势，所以在 实时性较高的应用，分布式数据库的获取，对并发和实时性要求比较高的游戏领域，都应有Node.js的一席之地。
e.第五点，作为BFF层，服务于前端的后端，这应该算是一种典型的应用场景。将 CPU密集型的逻辑交给后端来写，Node.js作为中间层，去提供前端需要定制化的数据，这样可以减少后端一部分工作量，让后端专注于提升自己的服务质量，尤其是CPU密集型的复杂业务逻辑也更容易复用。

44. 服务器流式返回结果的实现方案有哪些？说说区别与优劣势？为什么不用websocket和轮训？ 
这里，我们需要服务端实时传输数据，而不是一次发给前端渲染。调研了几个方案，最后采用的是 eventSource的应用。
eventSource
1.Server-Sent Events (SSE)：
￮SSE 是一种基于 HTTP 的协议，用于从服务器向客户端推送实时事件。在 SSE 中，客户端与服务器之间的连接保持打开，服务器可以随时向客户端发送数据。
￮SSE 内置了自动重连机制。如果连接意外中断（例如，网络故障或服务器重启），客户端会自动尝试重新建立连接，而无需额外的代码。
￮这种自动重连机制使得 SSE 对于实时通信场景非常方便，因为您不必手动处理连接断开和重新连接的逻辑。
TypeScript
 return new Promise((resolve, reject) => {
        let resMessage = '';
        let lastRemainingList = []
        let intervalId;
        const eventSource = new EventSource(`http://localhost:3000?${queryString.stringify({
            sendData,
            sendSession: sessionId.value,
        })}`);
        contentInfo.eventSource = eventSource
        eventSource.onopen = function () {
            console.log('Connection to server opened1111.');
        };
        eventSource.onmessage = function (event) {
            let index = 0; // 声明一个变量来记录当前显示的文字位置
            try {
                const resData = JSON.parse(event.data)
                const streamResp = resData?.streamResp || ''
                resMessage += lastRemainingList.join('')
                lastRemainingList = streamResp.split('')
                // 清除之前的定时器
                clearInterval(intervalId);
                intervalId = setInterval(() => {
                if (lastRemainingList.length) {
                    resMessage += lastRemainingList.shift()
                    onDownloadProgress(resMessage);
                } else {
                    clearInterval(contentInfo.intervalId);
                }
            }, 10);
                if (resData.isDone) {
                    eventSource.close(); // 关闭EventSource连接
                    resolve(resMessage)
                }
            } catch (error) {
                eventSource.close(); // 关闭EventSource连接
                reject(error)
            }
        };

        eventSource.onerror = function (event) {
            console.error('Error occurred:', event);
            eventSource.close(); // 关闭EventSource连接
            reject(event)
        };
    })

TypeScript
const express = require('express');
const app = express();
const cors = require('cors')//跨域
app.use(cors())
// 定义一个路由，用于向客户端推送事件
app.get('/events', (req, res) => {
  // 设置响应头，指定返回的数据类型为 text/event-stream
  res.setHeader('Content-Type', 'text/event-stream');
  // 设置响应头，禁用浏览器的缓存
  res.setHeader('Cache-Control', 'no-cache');
  // 向客户端发送一条消息
  res.write('data: Hello, world!\n\n');
  // 模拟每隔 5 秒钟向客户端发送一条消息
  let index = 0
  setInterval(() => {
    index += 1;
    res.write('data: This is a message from server  ' + index + '.\n\n');
  }, 3000);
});

// 启动服务器，监听 3000 端口
app.listen(9998, () => {
  console.log('Server is running on port 9998.');
});

Axios 流式请求 | onDownloadProgress 事件
TypeScript
const CancelToken = axios.CancelToken;
contentInfo.axiosSource = CancelToken.source();
await xxxx?.axiosSource?.cancel('请求被用户取消！')
res = await axios.post(`${baseUrl}${SEND_DATA}`, {
    sendData,
    sendSession: sessionId.value,
}, {
    timeout: 180000, // 设置超时时间为3分钟
    // 将 cancel token 传递给请求配置
    cancelToken: contentInfo.axiosSource.token,
    onDownloadProgress: ({ event }) => {
        const xhr = event.target
        const chunk = xhr.responseText as string
        const { content: newChunk } = getBuildContentId(chunk)
        index = lastTextLength
        lastTextLength = newChunk.length
        // 清除之前的定时器
        clearInterval(contentInfo.intervalId);
        // 模拟文字逐步输入的效果
        contentInfo.intervalId = setInterval(() => {
            if (index <= newChunk.length) {
                const chunkValue = newChunk.slice(0, index)
                onDownloadProgress(chunkValue);
                index++;
            } else {
                clearInterval(contentInfo.intervalId);
            }
        }, 10); // 每隔10毫秒更新一次
    },
    headers: {
        Accept: 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded'
    }
})
.then(res => res?.data || '')
.catch(function (error) {
    console.error('Error fetching text:', error);
    throw error
})


JavaScript
const response = await axios({
        method: 'post',
        url: '/api/dataAIAlgoStream',
        data: data,
        header: {
            Accept: '*/*'
        },
        onDownloadProgress: function (progressEvent) {
            console.log('123', progressEvent.event.currentTarget.responseText);
        }
});

fetch('/api/dataAIAlgoStream', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
}).then(response => {
    const reader = response.body.getReader();
    return new ReadableStream({
        start(controller) {
            function push() {
                reader.read().then(({ done, value }) => {
                    if (done) {
                        controller.close();
                        return;
                    }
                    // 将 ArrayBuffer 转换为字符串
                    let string = new TextDecoder("utf-8").decode(value);
                    if (string.trim() !== '') {
                        console.log('string', string);
                    }
                    controller.enqueue(value);
                    push();
                })
            }
            push();
        }
    });
}).then(stream => {
    return new Response(stream, { headers: { "Content-Type": "application/json" } }).text();
}).then(result => {
    console.log(result);
});
Websocket 和 轮训 
•概述：WebSockets 是一种构建在设备 TCP/IP 协议栈之上的传输层，提供全双工通信通道。它保持一个唯一的连接打开，同时消除长轮询的延迟问题。
￮WebSocket 也是一种实现实时通信的协议，但它更灵活，支持双向通信。
￮WebSocket 不内置自动重连机制。如果连接中断，客户端需要自行实现重连逻辑。这通常涉及设置定时器，检测连接状态，并在连接断开时重新建立连接。
￮一些 WebSocket 客户端库提供了自动重连的功能，但这需要您显式地配置和处理。
•特点：
￮实时性更强：服务器可以随时主动向客户端推送数据，而不需要等待客户端发起请求。
￮减少网络传输开销：WebSockets 不需要在每个请求中发送额外的头信息。
￮连接终止时无法自动恢复连接，需要自行实现。
TypeScript
// 后端 WebSocket 服务器代码
const WebSocket = require('ws');
const http = require('http');

const server = http.createServer();
const wss = new WebSocket.Server({ server });

wss.on('connection', (ws) => {
  console.log('有新的连接加入');

  // 监听客户端发送的消息
  ws.on('message', (message) => {
    console.log(`收到客户端消息：${message}`);
    // 在这里处理消息，例如广播给其他客户端
    wss.clients.forEach((client) => {
      if (client !== ws && client.readyState === WebSocket.OPEN) {
        client.send(`服务器收到消息：${message}`);
      }
    });
  });

  // 连接关闭时的处理
  ws.on('close', () => {
    console.log('连接关闭');
  });
});

server.listen(3000, () => {
  console.log('WebSocket 服务器正在监听端口 3000');
});


TypeScript
// 前端 WebSocket 客户端代码
const socket = new WebSocket('ws://localhost:3000');

// 监听连接成功事件
socket.addEventListener('open', (event) => {
  console.log('WebSocket 连接已建立');
  // 可以在这里发送初始消息给服务器
  socket.send('Hello, server!');
});

// 监听服务器发送的消息
socket.addEventListener('message', (event) => {
  console.log(`收到服务器消息：${event.data}`);
});

// 监听连接关闭事件
socket.addEventListener('close', (event) => {
  console.log('WebSocket 连接已关闭');
});
    
•为什么不推荐轮训方案
￮考虑到性能和资源消耗，不要设置过于频繁的请求，qps也比较高。
￮感觉只适用于旧浏览器，推荐使用 WebSocket 来实现更实时的通信。
45. CSS 如何画三角形？
https://zhuanlan.zhihu.com/p/482361933
46. 响应式布局？两栏布局实现？三栏布局实现？flex布局？网格布局？
响应式布局
响应式布局是确保网页在不同设备和屏幕尺寸上都能良好显示的关键技术。以下是几种实现CSS响应式布局的方法，特别适合于适配移动端设备：

1. 使用媒体查询（Media Queries）
媒体查询允许你根据设备视口尺寸、分辨率等特性来应用不同的CSS样式。
CSS
/* 默认样式，例如针对桌面 */
body {
  font-size: 16px;
}

/* 当屏幕宽度小于等于480px时，应用以下样式，比如为移动设备优化 */
@media screen and (max-width: 480px) {
  body {
    font-size: 14px;
  }
  .container {
    grid-template-columns: 1fr; /* 转换为单列布局 */
  }
}

2. Flexbox 的响应式设计
Flexbox 可以轻松调整元素的大小和顺序，非常适合响应式布局。
CSS
.container {
  display: flex;
  flex-wrap: wrap; /* 允许项目换行 */
}

.item {
  flex: 1 0 300px; /* 默认占据一定空间，但可收缩 */
}

@media (max-width: 600px) {
  .item {
    flex: 1 0 100%; /* 在小屏幕上占满全宽 */
  }
}

3. Grid 布局的响应式
CSS Grid 同样强大，可以更精细地控制响应式网格。
CSS
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}

@media (max-width: 768px) {
  .grid-container {
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); /* 在较小屏幕上缩小格子尺寸 */
  }
}

4. 使用vw/vh单位
视窗单位（viewport width/height）可以根据视口大小来设置元素尺寸，非常适合响应式设计。
CSS
.box {
  width: 50vw; /* 占据50%的视口宽度 */
  height: 10vh; /* 占据10%的视口高度 */
}

@media (max-width: 490px) {
  .box {
    width: 90vw; /* 在小屏上调整宽度 */
  }
}

5. Bootstrap 或其他响应式框架 
使用像Bootstrap这样的前端框架可以快速实现响应式布局，它们内置了栅格系统、断点和响应式实用类。
HTML
<!-- 使用Bootstrap的栅格系统 -->
<div class="container">
  <div class="row">
    <div class="col-md-6 col-sm-12"> <!-- 在中等尺寸及以上设备占半宽，在小尺寸设备占全宽 -->
      ...
    </div>
    <div class="col-md-6 col-sm-12">
      ...
    </div>
  </div>
</div>
这些方法各有优势，选择时应考虑项目需求、兼容性和维护性。在实际开发中，往往会结合使用多种技术以达到最佳的响应式效果。

6. rem + 移动端适配
JavaScript
// 物理像素与逻辑像素不一致问题
const htmlEl = document.getElementByTagName("html")[0];
htmlEl.style.fontSize = (window.innerWidth / 750) * 100 + "px";


// 1rem 100px => 则 750px 屏幕宽度 7.5rem

7. PostCSS
PostCSS是一个强大的工具，它通过JavaScript插件来转换CSS代码，提供了现代化的语法、功能和优化，使得编写跨浏览器兼容的CSS变得更加容易。在移动端适配方面，PostCSS的常见作用和写法主要包括以下几个方面：

1.单位转换：如使用postcss-pxtorem或postcss-px-to-viewport插件，将像素单位(px)转换为rem或vw/vh等相对单位，帮助实现屏幕尺寸的自适应布局。
2.自动添加前缀：autoprefixer插件可以自动为CSS属性添加必要的浏览器前缀，确保在不同浏览器上的兼容性。
3.模块化和导入管理：postcss-import插件允许在CSS中使用类似@import的语句，但能直接在编译期间解决依赖，减少HTTP请求。
4.图片和资源处理：postcss-url插件可以优化CSS中的URL引用，比如对图片进行base64编码嵌入或修改资源路径
5.优化和压缩：通过各种优化插件，如cssnano，可以压缩CSS代码，移除无用的规则，提高加载速度。
使用postcss-pxtorem进行rem转换
这样配置后，PostCSS会在构建过程中自动将CSS中的px单位转换为rem单位，依据你的设计稿宽度来适配不同屏幕尺寸的移动设备。
Bash
npm install postcss-pxtorem --save-dev
然后，在你的.postcssrc.js或postcss.config.js文件中配置postcss-pxtorem插件：
JavaScript
module.exports = {
  plugins: [
    require('postcss-import'),
    require('autoprefixer'),
    require('postcss-pxtorem')({
      // 设计稿宽度的1/10作为基准值，例如设计稿是750px宽
      rootValue: 75, 
      // 忽略转换的CSS属性列表，例如不希望字体大小被转换
      propList: ['*'],
      // 是否包含border相关的px转换，默认为true
      includeBorderWidth: true,
      // 是否包含margin相关的px转换，默认为true
      includeMargin: true,
      // 是否转换媒体查询中的px，默认为false
      mediaQuery: false,
      // 是否转换内联样式的px，默认为false
      replace: true,
      // 是否处理CSS内外的URL中的px，默认为false
      minPixelValue: 2, // 设置最小转换数值，小于这个值的px不会被转换
    }),
  ],
};

使用postcss-px-to-viewport进行viewport单位转换
通过这种方式，你可以将固定的px单位自动转换为vw或vh单位，实现更加灵活的响应式布局。
Bash
npm install postcss-px-to-viewport --save-dev

JavaScript
module.exports = {
  plugins: [
    require('postcss-import'),
    require('autoprefixer'),
    require('postcss-px-to-viewport')({
      viewportWidth: 375, // 视口宽度，根据设计稿宽度来设置
      viewportHeight: 667, // 视口高度，可选
      unitPrecision: 5, // 小数点后的精度
      viewportUnit: 'vw', // 希望使用的单位
      selectorBlackList: ['.ignore', '.hairlines'], // 不进行转换的类名
      minPixelValue: 1, // 设置最小的转换数值，避免小数值出现
      mediaQuery: false, // 是否转换媒体查询里的单位
    }),
  ],
};

JavaScript
postcss: {
    autoprefixer: {
        enable: true,
        config: {
            overrideBrowserslist: ['last 3 versions', 'Android >= 4.1', 'ios >= 8']
        }
    },
    pxtransform: {
        enable: true,
        config: {}
    },
    url: {
        enable: true,
        config: {
            limit: 10240 // 设定转换尺寸上限
        }
    },
    cssModules: {
        enable: false,
        // 默认为 false，如需使用 css modules 功能，则设为 true
        config: {
            namingPattern: 'module',
            // 转换模式，取值为 global/module
            generateScopedName: '[name]__[local]___[hash:base64:5]'
        }
    }
}
两栏布局
CSS 实现两栏布局有多种方法，下面列举几种常见的技术方案：

1. 浮动布局（Floats）
CSS
.container {
  overflow: hidden; /* 清除浮动 */
}

.left {
  float: left;
  width: 200px; /* 左侧栏宽度 */
}

.right {
  margin-left: 205px; /* 左侧栏宽度 + 左侧栏边距 */
}

HTML
<div class="container">
  <div class="left">左侧栏</div>
  <div class="right">右侧栏</div>
</div>

2. 使用 Flexbox
Flexbox 提供了一种更现代、更灵活的布局方式。
CSS
.container {
  display: flex;
}

.left {
  width: 200px; /* 左侧栏宽度 */
}

.right {
  flex-grow: 1; /* 右侧栏自适应剩余空间 */
}

HTML
<div class="container">
  <div class="left">左侧栏</div>
  <div class="right">右侧栏</div>
</div>
3. Grid 布局
CSS Grid 是一种二维布局系统，非常适合复杂的页面布局。
CSS
.container {
  display: grid;
  grid-template-columns: 200px auto; /* 左侧固定宽度，右侧自适应 */
}

.left {
}

.right {
}

HTML
<div class="container">
  <div class="left">左侧栏</div>
  <div class="right">右侧栏</div>
</div>

4. 使用定位（Positioning）
这种方法较少使用于流式布局，但在某些特定场景下可能有用。
CSS
.container {
  position: relative;
}

.left {
  position: absolute;
  width: 200px;
  left: 0;
  top: 0;
  bottom: 0; /* 使高度充满容器 */
}

.right {
  margin-left: 205px;
}

HTML
<div class="container">
  <div class="left">左侧栏</div>
  <div class="right">右侧栏</div>
</div>
5. 使用 calc()
结合 calc() 函数可以动态计算宽度，适用于需要精确控制的情况。
CSS
.left {
  float: left;
  width: 200px;
}

.right {
  margin-left: 205px;
  width: calc(100% - 205px); /* 计算剩余宽度 */
}

每种方法都有其适用场景和优缺点，选择时可以根据具体需求和浏览器兼容性来决定。在现代Web开发中，Flexbox和Grid布局因为其灵活性和易用性而被广泛推荐。


三栏布局
浮动布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>浮动布局</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .root {
            overflow: auto;
            width: 100%;
            height: 100%;
        }

        .root>div {
            height: 500px;
        }

        .left {
            width: 200px;
            float: left;
            background-color: #bfa;
        }

        .right {
            width: 300px;
            float: right;
            background-color: green;
        }

        .center {
            margin-left: 200px;
            margin-right: 300px;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="left">left</div>
        <div class="right">right</div>
        <div class="center">
            center
        </div>
    </div>
</body>

</html>
圣杯布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圣杯布局</title>
    <!-- 通过 子元素 padding 腾空位 -->
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .root {
            overflow: auto;
            width: 100%;
            height: 100%;
        }

        .container div {
            height: 200px;
            float: left;
            position: relative;
        }

        .container {
            padding-left: 200px;
            padding-right: 300px;
        }

        .center {
            background-color: #bfa;
            width: 100%;
        }

        .left {
            width: 200px;
            margin-left: -100%;
            left: -200px;
            background-color: yellow;
        }

        .right {
            width: 300px;
            margin-right: -300px;
            background-color: yellowgreen;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="container">
            <div class="center">center</div>
            <div class="left">left</div>
            <div class="right">right</div>
        </div>
    </div>
</body>

</html>
双飞翼布局
HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>双飞翼布局</title>
    <style>
        main > div{
            height: 500px;
            float: left;
        }
        .container{
            overflow: hidden;
            width: 100%;
            background-color: green;
        }
        .center{
            width: 100%;
            height: 600px;
            margin-left: 150px;
            margin-right: 200px;
            background-color: #bfa;
        }
        .left{
            width: 150px;
            background-color: red;
            margin-left: -100%;
        }
        .right{
            width: 200px;
            margin-left: -200px;
            background-color: pink;
        }
    </style>
</head>
<body>
    <div class="root">
        <main>
            <div class="container">
                <div class="center">center</div>
            </div>
            <div class="left">left</div>
            <div class="right">right</div>
        </main>
    </div>
</body>
</html>
flex布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flex布局</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .root {
            width: 100%;
            height: 100%;
            display: flex;
        }

        .center {
            background-color: #bff;
            flex: 1;
            height: 20px;
        }

        .left {
            width: 150px;
            height: 20px;

            background-color: red;
        }

        .right {
            width: 200px;
            height: 20px;

            background-color: yellow;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="left">left</div>
        <div class="center">center</div>
        <div class="right">right</div>
    </div>
</body>

</html>
bfc布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bfc布局</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .root {
            width: 100%;
            height: 100%;
        }

        .center {
            background-color: #bff;
            height: 20px;
            /* 
            display: flow-root;
            开启bfc操作都行
             */
            overflow: hidden;
        }

        .left {
            width: 150px;
            height: 20px;
            float: left;
            background-color: red;
        }

        .right {
            width: 200px;
            height: 20px;
            float: right;
            background-color: yellow;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="left">left</div>
        <div class="right">right</div>
        <div class="center">center</div>
    </div>
</body>

</html>
position布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>定位布局</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .root {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .center {
            background-color: #bff;
            height: 20px;
            margin: 0 300px;
        }

        .left {
            width: 300px;
            height: 20px;
            position: absolute;
            top: 0;
            left: 0;
            background-color: red;
        }

        .right {
            width: 300px;
            height: 20px;
            position: absolute;
            top: 0;
            right: 0;
            background-color: yellow;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="left">left</div>
        <div class="center">center</div>
        <div class="right">right</div>
    </div>
</body>

</html>

flex布局
https://juejin.cn/post/7061196914741477383
Flex是FlexibleBox的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
任何一个容器【含行内元素】都可以指定为Flex布局。
设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
容器：采用Flex布局的元素
项目：它的所有子元素自动成为容器成员
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。
容器属性：
•flex-direction属性决定主轴的方向（即项目的排列方向）。
•flex-wrap属性定义，如果一条轴线排不下，如何换行。
•flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
•justify-content属性定义了项目在主轴上的对齐方式。
•align-items属性定义项目在交叉轴上如何对齐。
•align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
项目属性：
•order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
•flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
•flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
•flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
•flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。
•align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
简单来说： flex布局是CSS3新增的一种布局方式，
可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。
可以使用flex-direction来指定主轴的方向。
可以使用justify-content来指定元素在主轴上的排列方式，
使用align-items来指定元素在交叉轴上的排列方式。
还可以使用flex-wrap来规定当一行排列不下时的换行方式。
对于容器中的项目，可以使用order属性来指定项目的排列顺序，
还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink
来指定当排列空间不足时，项目的缩小比例。

网格布局
https://www.jb51.net/css/891565.html

47. 所有的移动端适配方案？物理像素、逻辑像素的区别？为什么用 750px？
方案
1.响应式设计 (Responsive Design): 利用CSS媒体查询 (@media) 来调整页面布局、图片尺寸、字体大小等，以适应不同屏幕尺寸和分辨率的设备。
2.流式布局 (Fluid Layout): 通过百分比单位而不是固定宽度来设置元素尺寸，使页面元素能够根据屏幕大小自动调整。
3.弹性盒模型 (Flexbox): 使用CSS Flexbox布局可以更灵活地对齐和分布页面元素，简化了多屏幕尺寸下的布局问题。
4.网格系统 (Grids): CSS Grid布局提供了一个二维系统来布局页面内容，非常适合创建复杂的响应式设计。
5.图片自适应 (Image Adaptation): 使用 max-width: 100%; height: auto; 确保图片不会超出其容器，以及SVG和高分辨率图片的支持。
6.viewport设置: 在HTML头部使用 <meta name="viewport"> 标签来控制页面的缩放和布局行为，确保适当的页面缩放比例。
7.Postcss 插件应用：px单位自动转换为vw或vh单位，或者 转化为 rem，实现响应式布局。
JavaScript
// 无论设备的屏幕大小如何，网页的布局都会保持一致。
const meta = document.querySelector('meta[name="viewport"]');
const dpr = window.devicePixelRatio; // 2
const scaleRatio = 1 / dpr; // 假设为 0.5
meta.setAttribute(`initial-scale=0.5, maximum-scale=0.5;mininum-scale=0.5`);

8.REM单位: 使用相对于根元素字体大小的单位(rem)，可以全局控制页面元素的大小，便于进行跨设备的适配。
CSS
html {
    font-size: 16px; /* 基准字体大小，可以根据设计稿调整 */
}
.body-text {
    font-size: 1rem; /* 相对于html的字体大小 */
}

JavaScript
// 物理像素与逻辑像素不一致问题
const htmlEl = document.getElementByTagName("html")[0];
htmlEl.style.fontSize = (window.innerWidth / 750) * 100 + "px";
乘以100是为了将结果从小数转换为百分比形式，以便设置字体大小。
最后，通过 htmlEl.style.fontSize 将计算出的百分比值设置为<html>元素的字体大小。
这样，页面中的其他元素如果使用REM作为单位，其大小就会根据这个动态的根字体大小进行缩放。

如果视口宽度正好是750px，那么计算出的字体大小将是100px（即1rem = 100px），与设计稿上1:1对应。
若视口宽度为375px（设计稿宽度的一半），则计算结果为50px (1rem)
意味着在这种屏幕尺寸下，元素宽度为375px的设计稿元素在页面上会渲染为187.5px（3.75rem），
仍然占据屏幕一半的宽度，实现了视觉上的等比缩放。

•这种方法简化了适配过程，但可能需要额外的媒体查询或JavaScript逻辑来处理极端情况，比如极小或极大的屏幕尺寸。
•确保所有尺寸相关的CSS属性都使用REM作为单位，以充分利用这种动态缩放机制。
•对于某些高DPI设备，可能还需要考虑DPR（设备像素比），进一步微调计算公式，使其更加精确地匹配物理像素和逻辑像素的比例。

物理像素与逻辑像素
•物理像素 (Physical Pixels): 是屏幕硬件的实际像素点，决定了屏幕的分辨率。每个像素点都能显示特定的颜色，是显示屏显示图像的最基本单位。
•逻辑像素 (Logical Pixels/Device-Independent Pixels/DIPs/Points): 是一个抽象概念，用于在不同设备上保持一致的显示效果。它不直接对应屏幕的物理像素，而是操作系统或浏览器用来定义界面元素尺寸和位置的单位。在高DPI（每英寸点数）的屏幕上，一个逻辑像素可能由多个物理像素组合来呈现，以保证图形的清晰度。

为什么使用750px作为设计稿尺寸
750px作为一个常见的设计稿尺寸，主要是因为它与一些流行设备的屏幕尺寸和分辨率相匹配。例如，iPhone 6及之后的一些苹果设备具有750物理像素的宽度（在@2x的Retina屏幕下，逻辑像素为375pt）。选择750px作为设计标准有以下几个原因：
•适配性: 750px的设计稿可以在@2x分辨率的设备上较好地转换，同时向下兼容到较低分辨率的设备，通过缩小图片或调整布局实现适配。
•清晰度: 对于Retina屏幕，提供两倍于逻辑像素的物理像素可以让界面和图像看起来更加清晰细腻。
•工作流程: 设计师和开发者之间的工作流程通常围绕特定的标准进行，750px作为一个约定俗成的标准，方便团队协作和资源管理。
•视觉舒适度: 750px的尺寸被认为是一个平衡点，既能提供足够的设计细节，又不至于因设计过于精细而导致在小屏幕上难以识别。
48. CSS 的样式选择器的优先级排序。
1.内联样式：直接在元素的style属性中定义的样式。

2.ID选择器 (#example)：直接通过元素ID选择。

3.类选择器、属性选择器、伪类 (.example, [attribute="value"], :hover, :focus, ::before, ::after, :not(), :is(), :where()等)：这些选择器的优先级基本相同，具体哪个生效取决于它们在样式表中的位置以及特殊规则（如:not()、:is()、:where()内部选择器的优先级）。

4.标签选择器 (div, p, etc.)：根据元素类型选择。
5.伪元素 (::before, ::after)：尽管伪元素与伪类在概念上接近，但它们在CSS规范中通常被视为与类选择器同一优先级，但实际处理时会根据其特性有所不同。

6.子代选择器 (>): 如 ul > li，直接子元素选择。
7.相邻兄弟选择器 (+): 如 h1 + p。
8.一般兄弟选择器 (~): 如 h1 ~ p。
9.后代选择器 (空格分隔): 如 div p，选择所有后代元素。

10.通配符选择器 (*): 选择所有元素，优先级最低。

49. 权限系统怎么设计的？RBAC模型介绍？为什么用RBAC模型？有没有了解或者对比过其他的理论模型？
文章：00后学习权限系统设计
其他理论模型
DAC（自主访问控制）：用户可以将自己拥有的权限分配给其他人。
MAC（强制访问控制）：用户和资源都有固定的安全属性值，用户可以访问安全属性值同级和更低别的资源，多用于对安全性要求比较高的系统，如多级安全军事系统。
ABAC（基于属性的访问控制）：通过一个或一组属性来控制是否有对操作对象的权限。
RBAC模型优势
•简化权限管理：通过角色分配权限，管理员无需为每个用户单独配置权限，降低了管理复杂度。
•提高安全性：RBAC可以实施最小权限原则，即只授予用户完成任务所需的最小权限，从而降低潜在的安全风险。
•支持灵活扩展：随着组织的发展和变化，可以轻松添加新的角色和权限，以满足不断变化的需求。
RBAC模型缺点
•需要了解组织结构知识，需要深思熟虑的实施。
•缺乏灵活性，可能导致角色爆炸等问题。

50. vue中 computed、watch 区别，具体如何实现?
Vue 3 中的 computed 和 watch 都是用来响应数据变化的重要特性，但它们在使用场景、功能特性和实现方式上有所不同。
computed
功能特点:
•计算属性: computed 用于计算基于响应式依赖的数据的新值。它具有缓存特性，即只有当它的依赖发生变化时，才会重新计算。
•声明式: 计算属性的结果会被缓存起来，直到依赖的响应式属性变化才会重新计算。
•适合场景: 当你需要一个基于其他数据进行计算得出的值，并且这个值在依赖未改变时不需要重复计算。

实现原理简述:
•Vue 3 中的 computed 是基于其响应式系统实现的。当你定义一个 computed 属性时，Vue 会为其生成一个 getter 函数，并在 getter 内部追踪依赖关系。
•当 computed 属性被访问时，getter 会被调用，进而触发依赖数据的 getter，建立起依赖关系。
•Vue 使用一个 _dirty 标志来跟踪计算属性是否需要重新计算。如果依赖的数据发生变化，相关联的 getter 会触发 scheduler，将 _dirty 设为 true。
•下次访问计算属性时，如果 _dirty 为 true，则会重新执行 getter 并更新缓存的值。

watch
功能特点:
•监听变化: watch 更直接地用于监听特定数据源的变化，并在变化时执行回调函数。
•支持异步操作: 可以在回调中执行异步操作，如 API 调用等。
•可选立即执行与深度监听: 提供选项来控制是否立即执行回调以及是否深度监听对象内部属性的变化。
•适合场景: 当数据变化后需要执行一些副作用操作，比如发起网络请求、更新DOM等。

实现原理简述:
•watch 通常在 setup() 函数或 watch 选项中定义，它内部利用了 Vue 的 effect 系统。
•每个 watch 实例都会创建一个 effect 函数，这个 effect 函数会追踪其内部使用的响应式数据。
•当这些数据发生变化时，对应的 effect 会被调度执行，从而触发回调函数。
•Vue 3 的 watch 也可以利用 watchEffect 的底层逻辑，但提供了更细粒度的控制，如手动控制何时执行、清理副作用等。

总结
computed 【不支持异步】更适用于需要缓存计算结果的场景，减少不必要的计算开销。
watch  【支持异步】则提供了更广泛的功能，包括但不限于执行副作用操作和更灵活的监听控制，特别适合于数据变化后的处理流程。
两者都是构建响应式应用不可或缺的部分，选择使用哪一个取决于具体需求。


51. vue不能检测哪些属性?解决方式？
Vue2.js 不能自动检测以下几种情况的变动：
1.对象属性的添加或删除：如果你在创建Vue实例后动态地给一个对象添加新的属性，Vue不会自动追踪这个新属性的变化。同样，如果删除一个属性，Vue也不会知道这一变动。
2.数组的某些变动：
￮直接通过索引设置一个项：vm.items[index] = newValue
￮修改数组的长度：vm.items.length = newLength
￮使用非变异方法，如 Array.prototype.push, splice, shift, unshift 等除外，因为Vue对其进行了包裹以确保响应性。
解决方式：
1.对于对象属性：
￮使用Vue.set(对象, '属性名', 值)或在组件实例中使用this.$set(对象, '属性名', 值)来添加新属性，这样Vue就能追踪到这个新属性的变化。
￮对于删除属性，可以使用Vue.delete(对象, '属性名')或this.$delete(对象, '属性名')。
2.对于数组：
￮使用Vue提供的变异方法，如push, pop, shift, unshift, splice, sort, reverse等，这些方法会自动更新视图。
￮如果需要直接设置索引或修改长度，仍然推荐使用Vue的变异方法或Vue.set来确保响应性。
确保数据在data选项中声明也是关键，因为Vue在初始化时会将这些属性转换为getter/setter来实现响应式。


Vue 3 对这些常见问题进行了一些改进，提供更好的响应性和更灵活的API来处理数据变化。
1.对象属性的添加或删除：Vue 3 引入了新的响应性系统，它不再完全依赖于Object.defineProperty，而是使用了Proxy，这使得Vue能够更自然地追踪对象属性的添加和删除，无需显式调用Vue.set或this.$set。在Vue 3中，只要在组件的setup()函数中声明的响应式对象，其属性的添加和删除都会自动被Vue跟踪。
2.数组的变动：虽然Vue 3中的数组仍然存在一些限制，但使用Proxy的响应性机制也让Vue能更透明地处理数组的变动。直接通过索引修改或更改数组长度现在更容易被Vue检测到，尤其是在使用ref或reactive创建的响应式数组上。不过，使用数组的变异方法（如.push()、.splice()等）仍然是最佳实践，因为它们确保了最佳的性能和兼容性。
总的来说，Vue 3在设计上减少了对特定API的依赖，提供了更直观和强大的响应式机制，从而减轻了开发者在处理数据变化时的一些常见痛点。

52. 常见样式应用float、position等对布局的影响，例如 position：relative，top ： 200px。
在Web开发中，布局是一个非常关键的环节，它决定了网页内容的排列方式和视觉效果。float 和 position 是两种常用的CSS属性，它们对元素的布局有着重要影响。
float
float 属性主要用于让元素浮动到左侧或右侧，使得文本和其他内联元素围绕它进行排列。这一特性常用于实现图文混排、多栏布局等场景。当一个元素被设置为浮动时，它会从当前的文档流中移出，影响其后的兄弟元素排列。
•示例: float: left; 会使元素向左浮动。
•影响: 
￮浮动元素会脱离正常文档流，周围的非浮动内容会围绕它排列。
￮若多个元素连续浮动，它们会按照指定方向依次排列，形成多列效果。
￮父容器若没有清除浮动(clear属性或使用.clearfix类等方法)，可能会导致高度塌陷，即父元素高度不包含浮动子元素的高度。
position
position 属性用于设定元素的定位类型，控制元素在页面上的布局方式。有四种主要的定位类型：static、relative、absolute、fixed。

•relative:
￮说明: position: relative; 使元素相对于其正常位置（即元素原本在文档流中的位置）进行定位。
￮影响: 
▪设置top: 200px; 会让元素向下偏移200像素。同样，可以使用left、right、bottom来调整元素在水平或垂直方向的位置。
▪相对定位的元素仍然占据其在文档流中的原始空间，周围的元素不会因为它的偏移而重新排列。
▪常用于微调元素位置，或者作为绝对定位(position: absolute;)元素的参照物。

总结
•float 主要用于创建流式布局，让元素在页面上左右浮动，适用于图文混排、分栏等场景。
•position: relative; 则是在不改变元素在文档流中位置的前提下，对元素进行微调定位，特别适合于作为绝对定位元素的基点或者是对元素进行细微的位置调整。

这两种属性在实际开发中经常结合使用，以达到理想的布局效果。理解它们的工作原理对于前端开发者来说至关重要。
53. css 盒模型介绍和应用
CSS盒模型是Web设计中的一个核心概念，它描述了元素在页面上占用空间的方式，包括元素的内容（content）、内边距（padding）、边框（border）和外边距（margin）四个部分。理解盒模型对于精确控制网页布局至关重要。下面是对W3C盒模型和IE盒模型的进一步解释，以及它们的应用场景和如何在实际开发中使用box-sizing属性来切换这两种模型。
W3C盒模型
W3C标准盒模型是CSS规范中定义的标准模型。在这个模型下，当你为一个元素设置宽度（width）和高度（height）时，这些尺寸仅指元素内容区域的大小，不包括边框（border）和内边距（padding）。外边距（margin）则位于这个总和之外。
•总宽度 = 内容宽度（content width） + 左右内边距（padding-left + padding-right）+ 左右边框（border-left-width + border-right-width）+ 左右边距（margin-left + margin-right）
•总高度 = 内容高度（content height）+ 上下内边距（padding-top + padding-bottom）+ 上下边框（border-top-width + border-bottom-width）+ 上下外边距（margin-top + margin-bottom）
应用
适用于需要精确控制内容区域尺寸，而边框和内边距作为额外层添加的情况。在响应式设计和需要严格控制内容尺寸的布局中较为常见。

IE盒模型（也称为Quirks模式盒模型）
Internet Explorer早期版本使用的盒模型有所不同，它将元素的指定宽度和高度视为包括内容、内边距和边框的总宽度和总高度。这意味着指定的尺寸会“挤压”内容区域的实际可用空间。
•如果按照IE盒模型逻辑计算，当给定一个宽度时：内容宽度 = 设定的width - (左右内边距 + 左右边框)

这种模型较少直接应用，因为它可能导致布局预测性较差。但在某些特定历史遗留项目或需要兼容旧浏览器时，了解其行为仍然重要。

box-sizing属性的应用
为了统一不同浏览器之间的表现，并灵活选择盒模型类型，CSS提供了box-sizing属性。
•content-box: 默认值，遵循W3C盒模型。
•border-box: 使元素遵循IE盒模型，指定的width和height包括内容、内边距和边框，但不包括外边距。
许多现代Web开发者倾向于在全局样式中设置box-sizing: border-box;，这样可以简化布局计算，使得元素的尺寸更容易预测，尤其是在进行流式布局或响应式设计时。
这样做可以让内边距和边框不会影响元素的总宽度和高度，提高了布局的灵活性和一致性。
CSS
*, *::before, *::after {
  box-sizing: border-box;
}
通过上述设置，所有元素都将采用border-box模型，大大简化了跨浏览器的布局问题处理。

54. css单位有哪些？
•px (像素)：计算机屏幕上的基本点，通常对应屏幕的一个物理像素点，但实际解释可能因设备和浏览器而异。
•% (百分比)：相对于其包含块的同名属性的百分比值。
•em：相对于当前字体大小的单位，如果未设置，默认为16px。
•rem：相对于根元素（通常是）的字体大小的单位。
•vw：视口宽度的1%。
•vh：视口高度的1%。
•vmin：取vw和vh中的较小值。
•vmax：取vw和vh中的较大值。
•deg, rad, grad, turn：用于表示角度的单位，分别对应度、弧度、梯度和圈数。
•fr：在CSS Grid布局中使用，表示可用空间的一份。
•rpx：小程序宽度750rpx
•calc(100% - 80px);
55. 复合选择器的应用？li[name = "wuba"]:nth-of-type?
在CSS中，复合选择器用于结合两个或多个简单选择器来定位文档中的特定元素。您给出的例子 li[name = "wuba"]:nth-of-type(n) 是一个很好的复合选择器示例，它结合了属性选择器和:nth-of-type伪类。这个选择器的含义如下：
•li[name = "wuba"]：这是一个属性选择器，用于选取所有<li>元素中那些name属性值等于"wuba"的元素。
•:nth-of-type(n)：这是一个伪类，用于选取属于其父元素的特定类型的第n个子元素。在这里，它会查找所有满足上述属性条件的<li>元素，并进一步筛选出这些元素中每个类型（即<li>）的第n个同级兄弟元素。
结合起来，li[name = "wuba"]:nth-of-type(n) 将会选择所有名字属性为"wuba"的<li>元素中，每个父元素下同类中的第n个元素。
1.后代选择器 (E F): 选取E元素内部的所有F元素，无论嵌套了多少层。
CSS
div p { color: red; } /* 选择所有div内的p元素 */
2.子选择器 (E > F): 仅选取E元素的直接子元素F。
CSS
ul > li { font-weight: bold; } /* 选择所有作为ul直接子元素的li */
3.相邻兄弟选择器 (E + F): 选取紧接在E元素之后的同级F元素。
CSS
li + li { margin-top: 10px; } /* 选择每个li后面紧邻的li，为其添加上边距 */
4.一般兄弟选择器 (E ~ F): 选取E元素之后的所有同级F元素。
CSS
h2 ~ p { text-indent: 2em; } /* 选择所有h2后同级段落，缩进文本 */
5.属性选择器 (E[attribute=value]): 选取具有指定属性和值的E元素。
CSS
input[type="text"] { width: 200px; } /* 选择type属性为"text"的input元素 */
6.伪类 (E:hover, E:focus, etc.): 用于表示元素的特定状态。
CSS
a:hover { color: blue; } /* 鼠标悬停在链接上时改变颜色 */
结合这些基本选择器，你可以构建出非常复杂和精确的选择器表达式，以满足各种样式化需求。
56. 网站变灰？
css 滤镜属性
JavaScript
img {
  filter: grayscale(100%);
}
除了使用CSS滤镜属性（如grayscale）使网站变为灰阶外，还有其他几种方法可以实现类似的效果，以适配不同场景或作为滤镜的补充。以下是一些替代或辅助方法：

使用透明度与叠加层：
可以在网站的最上层添加一个半透明的灰色覆盖层，使其遮盖整个页面内容，创造出灰暗的效果。这种方法不改变原始内容的颜色，而是通过视觉叠加达到灰化效果。
CSS
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5); /* 黑色半透明 */
    z-index: 9999; /* 确保覆盖在所有内容之上 */
}
在需要时，通过JavaScript动态添加这个类到<body>标签上。

调整图片和背景颜色：
直接更改页面中图片和背景的颜色为灰色。这可以通过修改图片的opacity或为其添加一个灰色遮罩来实现，同时调整所有背景颜色为灰色系。
CSS
img {
    opacity: 0.5; /* 或使用filter: grayscale(100%); */
}
body, div, a, p, ... { /* 根据需要指定更多的元素 */
    background-color: #ccc; /* 浅灰色背景 */
}

修改颜色方案：
如果网站使用了预定义的颜色方案，可以通过修改CSS变量（如果使用了CSS Variables）来快速切换到一个灰阶版本的颜色方案。这样可以保持设计的一致性，同时使整个网站色调变灰。
CSS
:root {
    --primary-color: #333; /* 默认颜色 */
    --secondary-color: #666; /* 默认颜色 */
}
/* 哀悼模式 */
.mourning-mode :root {
    --primary-color: #666; /* 更改为灰色 */
    --secondary-color: #999; /* 更改为更深的灰色 */
}

使用SVG滤色器：
对于支持SVG的浏览器，可以使用SVG滤色器（<filter>元素）定义复杂的颜色变换效果，并应用到页面元素上，这种方法更为灵活但可能更复杂。

综合以上方法，可以创建一个全面且兼容性良好的网站灰化方案，以适应哀悼、纪念等特殊场合的需求。在实际应用中，根据具体需求选择最适合的技术组合。

57. 水平垂直居中？分别居中？
flex布局
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flex居中</title>
    <style>
        .father {
            background-color: #bfa;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
        }

        .children {
            background-color: red;
            height: 240px;
            width: 500px;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="father">
            <div class="children">
                children
            </div>
        </div>
    </div>
</body>

</html>
定位
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>定位居中法【3种】</title>
    <style>
        .father {
            background-color: #bfa;
            position: relative;
            height: 300px;
        }

        .children {
            background-color: red;
            height: 240px;
            width: 500px;
            position: absolute;
            
            /* top: 50%; */
            /* left: 50%; */
            /* transform: translate(-50%,-50%); */
            
            
            /* top: 50%; */
            /* left: 50%; */
            /* margin-left: -250px;
            margin-top: -120px; */

            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="father">
            <div class="children">
                children
            </div>
        </div>
    </div>
</body>

</html>
inline-block法
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>inline-block</title>
    <style>
        .father {
            background-color: #bfa;
            height: 300px;
            text-align: center;
            line-height: 300px;
        }

        .children {
            background-color: red;
            height: 240px;
            width: 500px;
            display: inline-block;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div class="root">
        <div class="father">
            <div class="children">
                children
            </div>
        </div>
    </div>
</body>

</html>
分开实现
水平居中 
对于 行内元素 : text-align: center; 
对于确定宽度的块级元素： 
（1）width和margin实现。margin: 0 auto; 
（2）绝对定位和margin-left: -width/2, 前提是父元素position: relative 
对于宽度未知的块级元素 
（1）table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 
display:table），再通过给该标签添加左右margin为auto。 
（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。
（3）绝对定位+transform，translateX可以移动本身元素的50%。 
（4）flex布局使用 justify-content:center 
垂直居中 
1.利用 line-height 实现居中，这种方法适合纯文字类 
2.通过设置父容器 相对定位 ，子级设置 绝对定位 ，标签通过margin实现自适应居中 
3.弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中 
4.父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现 
5.table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是： 
vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。
58. JS类型，类型判断方式？
基本数据类型：String, Number, Boolean, null , undefined, Symbol , BigInt
引用数据类型：Object类型（包括Function , Array , Date , map，RegExp ,set 等）

•typeof 区分基本数据类型，除了 null 为 object
•instanceOf 区分对象类型
•Object.prototype.toString.call(obj).slice(8,-1）
•obj.__proto__ === Array.prototype
•Array.isArrray(obj)
•constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了。
JavaScript
function Fn(){};
 
Fn.prototype = new Array();
 
var f = new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true

59. JS 继承方式的方法及优劣
概论
•原型链继承：这是最基本的继承方式，它利用了JS中每个函数都有一个原型对象，每个对象都有一个指向原型对象的内部属性__proto__，从而形成了一个原型链。通过原型链，一个对象可以访问到它的构造函数的原型对象上的属性和方法，以及更上层的原型对象，直到Object.prototype为止。原型链继承的优点是简单易懂，可以实现代码重用和运行时扩展；缺点是所有子对象共享同一个原型对象，因此如果一个子对象修改了继承的引用类型属性（如数组或对象），则会影响到其他子对象，而且不能向父类构造函数传递参数。
•借用构造函数继承：这是一种通过在子类构造函数内部调用父类构造函数来实现继承的方式，通常使用call或apply方法来改变父类构造函数内部的this指向。借用构造函数继承的优点是可以避免引用类型属性的共享问题，而且可以向父类构造函数传递参数；缺点是只能继承父类的实例属性和方法，不能继承原型属性和方法，而且每个子类都有父类实例函数的副本，影响性能。
•组合继承：这是一种结合原型链继承和借用构造函数继承的方式，它使用原型链继承来实现对原型属性和方法的继承，使用借用构造函数继承来实现对实例属性的继承。组合继承的优点是可以同时保留类型识别和原型继承的优点；缺点是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。
•原型式继承：这是一种利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型来实现继承的方式。它相当于对传入其中的对象执行了一次浅复制，并返回一个新对象。原型式继承的优点是可以在不需要创建自定义类型的情况下实现对象之间的属性共享；缺点是同样存在引用类型属性共享问题。
•寄生式继承：这是一种在原型式继承的基础上，在返回新对象之前增强该对象或添加新属性和方法的方式。它相当于对传入其中的对象执行了一次浅复制，并在复制后添加一些额外功能，并返回一个新对象。寄生式继承的优点是可以在不需要创建自定义类型的情况下对对象进行增强或定制；缺点是同样存在引用类型属性共享问题，而且不能实现方法复用。
•寄生组合式继承：这是一种结合借用构造函数传递参数和寄生模式实现继承的方式，它使用借用构造函数来继承父类实例属性，并使用Object.create方法来创建一个以父类原型为原型的新对象，并将其赋值给子类原型。寄生组合式继承的优点是可以避免原型链继承和借用构造函数继承的缺点，而且效率高，是实现继承的最佳方式。
•ES6类继承：这是一种使用ES6中的class关键字来实现继承的方式，它使用extends关键字来指定子类要继承的父类，并使用super关键字来调用父类的构造函数和方法。ES6类继承的优点是语法简洁，易于理解和使用；缺点是兼容性较差，需要转译成ES5或更低版本的代码才能在旧版浏览器中运行。

组合继承与寄生式继承
组合继承的核心思想：
•使用call()或apply()方法在子类构造函数内部调用父类构造函数，这样可以复制父类的实例属性到子类实例上。
•设置子类的原型对象等于父类的新实例，从而使得子类能够继承父类的原型上的方法。
JavaScript
function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(this.name);
}

function Child(name, age) {
    Parent.call(this, name); // 继承属性
    this.age = age;
}
Child.prototype = new Parent(); // 继承方法
Child.prototype.constructor = Child; // 修正构造函数指针

let child = new Child('Tom', 18);
child.sayName(); // 输出 "Tom"
组合继承的问题：
•它会调用两次父类构造函数，一次是在创建子类原型时（new Parent()），另一次是在子类型构造函数内部（Parent.call(this, name)），可能会导致资源浪费。
寄生式继承的核心思想：
•不直接修改或连接原型链，而是通过创建一个新的对象，这个对象与父类实例具有相同的原型，然后在这个新对象上扩展额外的方法或属性。
示例代码：
JavaScript
function createAnother(original) {
    let clone = Object.create(original); // 创建一个原型指向original的新对象
    // 添加其他方法或属性到clone上，如果需要的话
    clone.someMethod = function() {...};
    return clone;
}

let parent = new Parent('Tom');
let child = createAnother(parent);

// 注意：这里没有自动继承parent的非实例方法，比如sayName()
寄生式继承的特点：
•更灵活，可以根据需求动态创建具有特定扩展的新对象。
•不会像组合继承那样造成不必要的父类构造函数的调用。
寄生组合式继承：
寄生组合式继承是结合了组合继承和寄生式继承的优点，避免了上述两种方法的缺陷。
它通过创建一个没有调用父类构造函数的原型对象来继承父类的原型，
同时仍然通过构造函数调用来继承父类的实例属性。
JavaScript
function inheritPrototype(subType, superType) {
    let prototype = Object.create(superType.prototype); // 创建新的原型对象
    prototype.constructor = subType; // 修复构造函数指针
    subType.prototype = prototype; // 将新的原型赋值给子类
}

function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(this.name);
}

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}

inheritPrototype(Child, Parent);

let child = new Child('Tom', 18);
child.sayName(); // 输出 "Tom"

// 写法2
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor 。
区别：
•组合继承同时通过原型链和构造函数调用来实现继承，可能导致父类构造函数被调用两次。
•寄生式继承主要关注对象的复制，而不是创建基于原型链的继承结构，通常用于创建独立的对象副本。
•寄生组合式继承则是综合以上两者，确保只调用一次父类构造函数，并有效继承原型链上的方法，同时不增加多余的实例属性。
总结
JavaScript
// 对象继承的方式
/**
 * 1. 原型链方式：
 * 缺点明显，创建子类时无法传递参数
 * 只能继承父类的原型对象中的属性和方法，而不能继承父类的构造函数中的属性和方法。
 * 对于引用类型的数据，所有的实例对象都会共享数据，容易出现意外修改
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() { }
Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 2. 构造函数模式，无法实现方法的复用
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}

var child = new Child();
child.sayName(); // TypeError: child.sayName is not a function

/**
 * 3. 组合继承：通过将原型链继承和构造函数继承结合起来，
 * 既能继承父类原型上的属性和方法，又能继承父类构造函数中的属性和方法。
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 4.原型式继承 ，它的实现方式是创建一个临时构造函数，然后将一个对象作为这个构造函数的原型，最后返回这个构造函数的一个实例。
 * 这种方式可以在不必预先定义构造函数的情况下实现继承，但是它也会导致对象间的共享问题。
 */
function createAnother(original) {
    var clone = Object.create(original);
    return clone;
}

var person = {
    name: 'Tom',
    age: 20
};

/**
 * 5. 寄生式继承 它的实现方式是创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。
 */
function createAnother(original) {
    var clone = Object.create(original);
    clone.sayHi = function () {
        console.log('hi');
    };
    return clone;
}

var person = {
    name: 'Tom',
    age: 20
};

/**
 * 6. 寄生组合继承：通过使用Object.create()方法来优化组合继承，
 * 避免了在子类构造函数中创建父类实例。
 * 超类型原型作为副本，这样就避免了创建不必要的属性。
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 7. ES6的class继承：通过使用class和extends关键字来实现继承。
 */
60. 作用域链
作用域
作用域是指变量的可见范围，也就是在哪些地方可以访问到这些变量。
JS 中有两种作用域：全局作用域和局部作用域。
全局作用域是指在任何地方都可以访问到的变量，比如用 var 声明的变量或者直接赋值的变量（不推荐）。
局部作用域是指只在某个特定的区域内可以访问到的变量，比如函数内部或者块级语句（如 if、for、while 等）内部。ES6 引入了 let 和 const 关键字，可以创建块级作用域，从而避免了 var 声明的变量提升和污染全局作用域的问题。
执行上下文
执行上下文是指 JS 代码执行时所处的环境，它包含了变量对象、作用域链、this 值等信息。
JS 中有三种执行上下文：全局执行上下文、函数执行上下文和 eval 执行上下文。
全局执行上下文是在 JS 代码开始执行时创建的，它创建了一个全局对象（浏览器中是 window 对象），并将 this 值绑定到这个对象上。
函数执行上下文是在每次调用函数时创建的，它创建了一个活动对象（也叫做变量对象），用来存储函数内部的变量、参数、函数声明等，并将 this 值绑定到调用函数的对象上（如果没有对象，则绑定到全局对象或者 undefined）。
eval 执行上下文是在使用 eval 函数时创建的，它类似于函数执行上下文，但不常用。
执行上下文有两个阶段：创建阶段和执行阶段。在创建阶段，JS 引擎会对变量、函数、参数等进行预处理（也叫做变量提升或者函数提升），并确定 this 的值。在执行阶段，JS 引擎会逐行执行代码，并根据作用域链来查找变量的值。
作用域链
作用域链是由当前执行上下文和其外部执行上下文组成的一个链表结构，它保证了当前执行上下文可以访问到外部变量。
区别
•作用域是在定义时确定的，也就是说变量的可见范围取决于它在哪里声明，而不在乎它在哪里使用。
•执行上下文是在运行时确定的，也就是说 this 的值和变量的值取决于它在哪里调用，而不在乎它在哪里定义。
61. Map、Object的区别，set应用，weakmap应用
Map vs Object
Key 类型：
•Object：传统对象的键（key）必须是字符串类型或者符号（Symbol）。如果传入非字符串类型的键，会被自动转换为字符串。
•Map：Map 的键可以是任何值，包括对象，这使得它更加灵活。
顺序性：
•Object：ES6 之前的对象没有明确的顺序概念，虽然 ES2015 引入了遍历对象键的顺序（基于插入顺序），但这更多是规范上的一个定义，并且在某些情况下可能不可靠。
•Map：保持插入顺序，这意味着遍历 Map 时，元素会按照插入的顺序被访问到。
迭代：
•Object：可以使用 for...in 循环或 Object.keys()、Object.values()、Object.entries() 等方法来迭代，但需要注意 for...in 会遍历原型链上的属性。
•Map：提供了 forEach 方法和可迭代协议，可以直接用 for...of 遍历，更方便且不会涉及到原型链上的属性。
Set 应用
Set 是一种不包含重复元素的集合。它的主要应用场景包括：
•去重：可以快速去除数组中的重复元素。
•成员检查：高效地检查某个值是否存在于集合中。
•交集、并集、差集操作：配合其他集合方法，可以实现集合的数学运算。
JavaScript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

//并集
let union = new Set([...a, ...b]);

//交集
let inset = new Set([...a].filter((x) => b.has(x)));

//差集
let difference = new Set([...a].filter((x) => !b.has(x)));

WeakMap 应用
WeakMap 是一种特殊类型的 Map，其键必须是对象，而这些对象是弱引用的。这意味着如果对象没有任何其他引用，并且仅被 WeakMap 引用，那么垃圾回收器可以回收这个对象。
WeakMap 的主要应用场景包括：
•私有变量：在 JavaScript 中模拟类的私有成员，因为 WeakMap 中的键是弱引用，不会阻止被引用的对象被垃圾回收。
•元数据存储：当你想要为某些对象关联一些额外信息，但又不想影响这些对象的垃圾回收时，可以使用 WeakMap 存储这些信息。
是否需要保持键的类型多样性、是否关心元素的插入顺序、是否需要去重功能，以及是否需要对键（特别是对象键）维持弱引用等。
JavaScript
const elementMetadata = new WeakMap();
function setElementData(element, data) {
    elementMetadata.set(element, data);
}
function getElementData(element) {
    return elementMetadata.get(element);
}

// 示例使用
const someElement = document.getElementById('someId');
setElementData(someElement, { tag: 'div', purpose: 'main content' });

console.log(getElementData(someElement)); // 输出关联的元数据

// 假设某个时候someElement不再被使用，它可以被垃圾回收，WeakMap中的条目也会随之消失
someElement = null; // 假设这里解除了所有对someElement的引用
62. 数组常见 api ，数组遍历方式，forEach、map、for in、for of 、while、do while 的区别？
遍历相关方法
https://zhuanlan.zhihu.com/p/452465956

1. forEach():
￮遍历数组的每个元素，并对每个元素执行提供的回调函数。
￮通常用于在迭代过程中执行某些操作。
JavaScript
const numbers = [1, 2, 3, 4];
numbers.forEach((num) => {
  console.log(num);
});
2.  map():
•遍历数组的每个元素，并对每个元素执行提供的回调函数，然后将每次回调函数的返回值收集到一个新数组中。
•返回一个新数组，不会改变原始数组。
JavaScript
const numbers = [1, 2, 3, 4];
const doubled = numbers.map((num) => {
  return num * 2;
});
console.log(doubled); // 输出 [2, 4, 6, 8]
3. filter()
•遍历数组的每个元素，并使用提供的回调函数来筛选元素，返回一个包含满足条件的元素的新数组。
•返回一个新数组，不会改变原始数组。
JavaScript
const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter((num) => {
  return num % 2 === 0;
});
console.log(evenNumbers); // 输出 [2, 4]
4. reduce():
•遍历数组的每个元素，执行一个累加的操作，将元素逐个累加到一个累加器中，并返回最终的累加结果。
•返回一个单一的值。
JavaScript
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, num) => {
  return accumulator + num;
}, 0);
console.log(sum); // 输出 10
5. find()、findIndex()
•遍历数组的每个元素，并使用提供的回调函数来查找满足条件的第一个元素。
•返回找到的第一个元素，如果没有找到则返回 undefined。
JavaScript
const numbers = [1, 2, 3, 4];
const result = numbers.find((num) => {
  return num > 2;
});
console.log(result); // 输出 3
6. some() 和 every():
•some 遍历数组的每个元素，检查是否至少有一个元素满足条件。
•every 遍历数组的每个元素，检查是否所有元素都满足条件。
•返回布尔值 (true 或 false)。
JavaScript
const numbers = [1, 2, 3, 4];
const hasEven = numbers.some((num) => {
  return num % 2 === 0;
});
console.log(hasEven); // 输出 true

const allEven = numbers.every((num) => {
  return num % 2 === 0;
});
console.log(allEven); // 输出 false

数组操作方法
push、pop、shift、unshift、splice、slice、include、Array.isArray

数组方法实现
JavaScript

// 自定义Array.reduce()方法的实现
Array.prototype.customReduce = function (callback, initialValue) {
  let accumulator = initialValue !== undefined ? initialValue : this[0];
  const startIndex = initialValue !== undefined ? 0 : 1;

  for (let i = startIndex; i < this.length; i++) {
    accumulator = callback(accumulator, this[i], i, this);
  }

  return accumulator;
};

// 自定义Array.map()方法的实现
Array.prototype.customMap = function (callback) {
  const result = [];

  for (let i = 0; i < this.length; i++) {
    result.push(callback(this[i], i, this));
  }

  return result;
};

// 自定义Array.filter()方法的实现
Array.prototype.customFilter = function (callback) {
  const result = [];

  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      result.push(this[i]);
    }
  }

  return result;
};

// 自定义Array.find()方法的实现
Array.prototype.customFind = function (callback) {
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      return this[i];
    }
  }

  return undefined;
};

// 自定义Array.every()方法的实现
Array.prototype.customEvery = function (callback) {
  for (let i = 0; i < this.length; i++) {
    if (!callback(this[i], i, this)) {
      return false;
    }
  }

  return true;
};



遍历方法区别
在JavaScript中，遍历集合（如数组）或执行重复任务有多种循环结构和方法可用，每种都有其特定用途和差异。下面是forEach、map、for...in、for...of、while、和do...while的主要区别：

forEach
•类型：这是数组的一个方法。
•用途：用于遍历数组中的每个元素，并对每个元素执行提供的函数。
•返回值：undefined，不返回新数组，也不会改变原数组。
•迭代控制：无法使用break或continue来控制循环流程。
•适用场景：当需要对每个元素执行操作但不需要返回新数组时。

map
•类型：同样是数组的一个方法。
•用途：遍历数组的所有元素，并根据回调函数生成一个新数组，原数组不变。
•返回值：一个新的数组，包含回调函数处理后的结果。
•迭代控制：同样不支持break或continue。
•适用场景：需要基于原数组创建一个经过变换的新数组时。

for...in
•类型：循环语句。
•用途：遍历对象的可枚举属性（不推荐用于数组）。
•返回值：无直接返回值，主要用于属性访问。
•迭代控制：可以使用break和continue。
•适用场景：遍历对象的属性，但需注意避免在数组上使用，除非明确知道在做什么。

for...of
•类型：循环语句，ES6引入。
•用途：遍历可迭代对象（如数组、Set、Map、字符串等）的元素值。
•返回值：无直接返回值。
•迭代控制：支持break和continue。
•适用场景：遍历任何实现了可迭代协议的数据结构，更安全且易于理解。

while
•类型：条件循环语句。
•用途：只要指定条件为真，就重复执行代码块。
•返回值：无直接返回值。
•迭代控制：通过条件表达式直接控制循环流程。
•适用场景：当循环次数未知，但知道循环结束的条件时使用。

do...while
•类型：条件循环语句，与while相似。
•用途：先执行一次循环体，然后只要条件为真就继续执行。
•返回值：无直接返回值。
•迭代控制：同样通过条件表达式控制，但至少执行一次循环体。
•适用场景：适合至少需要执行一次循环体的情况，即使初始条件就为假。

总的来说，选择哪种循环或迭代方法取决于具体需求，如是否需要返回新数组、遍历的对象类型、以及对控制流程的需求等。
63. Object、Reflect 常见api的应用，区别是什么？
Object和Reflect都是JavaScript中用于操作对象的重要内置对象。
Object常见API及其应用
1.Object.create(proto[, propertiesObject])
￮应用：用于创建一个新对象，其原型是proto，并可以指定额外的属性描述。
￮区别：直接创建一个具有指定原型链的对象。

2.Object.defineProperty(obj, prop, descriptor)
￮应用：给对象添加或修改某个属性，并可精确控制该属性的特性（如可配置性、可枚举性、可写性等）。
￮区别：如果尝试修改不可配置或不可写的属性，会抛出错误。

3.Object.getOwnPropertyDescriptor(obj, prop)
￮应用：获取对象某个属性的描述符。
￮区别：直接获取属性的详细配置信息。

4.Object.keys(obj)/Object.values(obj)/Object.entries(obj)
￮应用：分别获取对象自身的可枚举属性名、属性值、属性键值对数组。
￮区别：提供不同视角来遍历对象属性。

Reflect常见API及其应用
https://www.jb51.net/article/264768.htm
1.Reflect.get(target, property[, receiver])
￮应用：获取对象的属性值，支持代理对象。
￮区别：相比直接访问属性，提供了更规范化的访问方式，可用于代理对象的拦截。

2.Reflect.set(target, property, value[, receiver])
￮应用：设置对象的属性值，同样支持代理对象。
￮区别：操作失败时返回false而不是抛出错误，提高了错误处理的灵活性。

3.Reflect.defineProperty(target, property, attributes)
￮应用：类似于Object.defineProperty，但失败时返回false。
￮区别：提供了更友好的错误处理机制，避免了try-catch块的需要。

4.Reflect.apply(target, thisArg, argumentsList)
￮应用：调用目标函数，允许显式设定this上下文和参数列表。
￮区别：提供了更通用的函数调用机制，特别适用于代理或特殊调用上下文。

5.Reflect.ownKeys(obj)
返回一个由目标对象自身的所有属性键组成的数组。这包括常规字符串属性、Symbol属性，而且无论这些属性是否可枚举。这个方法非常适合于需要获取对象所有属性细节的场景，特别是当你需要考虑Symbol作为键的情况。
Reflect对象提供了一个静态方法用于遍历对象的所有自有属性，包括不可枚举的属性和Symbol类型的键。
JavaScript
const obj = {
  name: 'Alice',
  age: 30,
  [Symbol('secret')]: 'hidden information'
};

console.log(Reflect.ownKeys(obj)); // 输出: ['name', 'age', Symbol(secret)]
对比于Object.keys()和Object.getOwnPropertyNames()，Reflect.ownKeys()的优势在于它能同时获取到Symbol类型的属性键，使得遍历更加全面。在进行深度复制、检查或修改对象属性时，这是一个非常有用的功能。
主要区别
•规范化和错误处理：Reflect提供了更为规范化的方法调用，尤其是在操作失败时返回布尔值而非抛出异常，这使得错误处理更加统一和可控。
•与Proxy集成：Reflect方法被设计为与Proxy对象紧密集成，使得在使用Proxy时能够更方便地拦截和控制对象操作。
•功能重叠与补充：许多Reflect的方法在功能上与Object方法重叠，但Reflect更偏向于提供一种更现代、更灵活的API来操作对象。
•使用习惯：尽管Reflect提供了很多优点，但在实际开发中，由于历史原因和习惯，开发者可能更多地使用Object的API。然而，在需要更精细控制或与Proxy一起使用时，Reflect成为了首选。
总结来说，Reflect是对Object对象操作方法的一种补充和完善，特别是在ES6之后，提供了更一致和灵活的对象操作接口，尤其是在与代理(Proxy)配合使用时展现出了更大的优势。

64. Object属性的获取、Symbol、原型属性、属性描述符
在JavaScript中，对象属性的管理是一个核心概念，涉及多个方面，包括属性的获取、使用Symbol作为键、原型链上的属性访问以及属性描述符的使用。下面逐一介绍这些概念：
属性的获取
•点运算符：最直接的方式，如obj.propertyName。
•方括号 notation：允许使用变量或字符串作为键，如obj['propertyName']，对于动态或特殊字符的属性名很有用。
•Reflect.get(target, property[, receiver])：提供了一种更规范的方式来获取对象属性，尤其在代理(Proxy)中使用。
Symbol作为属性键
•Symbol 是一种原始数据类型，它的值是唯一的，常用于作为对象的键，以避免属性名冲突。
•创建Symbol：const sym = Symbol('description')。
•访问Symbol属性：同样使用方括号notation，如obj[sym]。
原型属性
•原型链：JavaScript中的对象可以通过原型链向上查找属性。
•__proto__**或****Object.getPrototypeOf(obj)** 获取对象的原型。
•obj.prototype.propertyName 访问原型上的属性。如果对象本身没有这个属性，会沿着原型链查找。

属性描述符
属性描述符定义了属性的行为，包括是否可枚举、可配置、可写等。有两种类型：
•数据描述符：有value、writable、enumerable、configurable字段。
•存取描述符：有get、set、enumerable、configurable字段，用于定义属性的getter和setter。

操作属性描述符的方法：
•Object.getOwnPropertyDescriptor(obj, prop)：获取指定属性的描述符。
•Object.defineProperty(obj, prop, descriptor)：定义或修改一个属性，传入描述符。
•Object.defineProperties(obj, props)：批量定义或修改属性。
•Object.getOwnPropertyDescriptor(obj)：返回对象所有自身属性的描述符。
JavaScript
const obj = {};

// 使用Symbol作为键
const sym = Symbol("uniqueKey");
obj[sym] = "Secret Message";

// 定义属性描述符
Object.defineProperty(obj, "name", {
  value: "Alice",
  writable: false, // 不可修改
  enumerable: true, // 可枚举
  configurable: true // 可配置
});

// 获取描述符
console.log(Object.getOwnPropertyDescriptor(obj, "name"));

// 访问原型属性
const proto = Object.getPrototypeOf(obj);
proto.age = 30;
console.log(obj.age); // 通过原型链访问到age属性

理解这些概念有助于深入掌握JavaScript对象的特性和操作，是进阶JavaScript编程的基础。
65. this指针应用、箭头函数的this
this对象
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。
•第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
•第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
•第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
•第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。
优先级：构造器调用模式 (new)> apply、call 和 bind 调用模式 > 方法调用模式 > 函数调用模式
箭头函数this指向
箭头函数是ES6中引入的一种新的函数语法，它有一些特殊的特性，其中之一就是没有自己的this指针。箭头函数中的this指向与普通函数不同，它会继承外层作用域中的this指向，也就是说箭头函数中的this指向在定义时就已经确定了，而不是在运行时动态绑定。这样可以避免一些常见的this指向问题，比如在回调函数、事件处理器、定时器等场景中。
JavaScript
// 定义一个Person构造函数
function Person(name) {
  this.name = name;
}

// 在Person原型上定义一个sayHello方法
Person.prototype.sayHello = function() {
  console.log("Hello, I'm " + this.name);
}

// 创建一个Person实例
var alice = new Person("Alice");

// 调用sayHello方法
alice.sayHello(); // Hello, I'm Alice

// 在Person原型上定义一个sayHelloLater方法，使用setTimeout延迟调用sayHello方法
Person.prototype.sayHelloLater = function() {
  // 使用普通函数作为回调
  setTimeout(function() {
    // 这里的this指向window对象，因为setTimeout是由window调用的
    this.sayHello(); // Uncaught TypeError: this.sayHello is not a function
  }, 1000);
}

// 调用sayHelloLater方法
alice.sayHelloLater(); // 报错

// 在Person原型上定义一个sayHelloLater2方法，使用setTimeout延迟调用sayHello方法
Person.prototype.sayHelloLater2 = function() {
  // 使用箭头函数作为回调
  setTimeout(() => {
    // 这里的this指向alice对象，因为箭头函数继承了外层作用域中的this指向
    this.sayHello(); // Hello, I'm Alice
  }, 1000);
}

// 调用sayHelloLater2方法
alice.sayHelloLater2(); // 正常输出


66. 前端路由实现原理？前端spa是什么？现在的spa应用是怎么实现的？
前端路由实现原理
主要是通过监听URL的变化，来模拟页面跳转并更新界面，而实际上并不重新请求页面资源。这样可以实现单页面应用（SPA）的无刷新浏览体验。以下是前端路由实现的一些关键点：
1.监听hash变化：早期的前端路由实现主要依赖于HTML5的hashchange事件。URL中的hash部分（#后面的内容）改变时，浏览器不会重新加载页面，而是触发hashchange事件。前端框架可以监听这个事件，根据hash值的变化来决定显示哪个页面内容。
2.HTML5 History API：随着HTML5的普及，History API（包括pushState、replaceState和popstate事件）成为了更现代的前端路由实现方式。这些API允许开发者在不刷新页面的情况下修改浏览器的访问历史和URL，从而实现页面之间的导航。当用户点击后退或前进按钮时，popstate事件会被触发，前端应用可以根据新的URL展示相应的内容。
3.路由匹配与组件渲染：前端路由库会根据当前URL匹配预先定义好的路由规则，然后根据匹配结果加载或切换对应的组件（如React组件），更新UI，给用户带来页面跳转的错觉，但实际上整个过程没有重新加载页面。
前端 SPA 概念
•前端SPA（Single Page Application，单页面应用程序）是指将所有必要的HTML、CSS、JavaScript等资源一次性加载到客户端，之后的页面交互和数据更新都通过异步请求和前端路由来完成，无需再次加载整个页面。
•用户体验更加流畅，因为减少了页面加载时间。
•更好地利用现代前端框架的功能，如状态管理、组件化开发等。例如，现代前端框架React：使用如 React Router这样的路由库来定义应用的路由配置。每个路由对应一个组件，根据URL的变化自动渲染相应的组件，组件化开发整个应用。

67. react-router怎么实现路由切换? 说说实现原理？ history 和 hash两种路由模式的区别？ History 模式下，用户在某个url下刷新，不做任何配置就会404，怎么样解决这个问题呢？
React Router 的实现原理
React Router 是一个用于在单页面应用中管理页面路由的库。
它基于 React 组件的方式来实现页面之间的切换和导航。
a.BrowserRouter 或 HashRouter：React Router 提供了两种主要的路由器组件，即 BrowserRouter 和 HashRouter。BrowserRouter 使用浏览器的 History API 来管理路由，而 HashRouter 使用 URL 中的哈希部分（#）来管理路由。它们都是顶层组件，用于包裹应用的根组件，以监听 URL 的变化并更新应用的渲染。

b.Route 组件：Route 组件用于声明哪个组件应该在特定的 URL 下被渲染。每个 Route 组件都会根据当前 URL 的路径来判断是否匹配，并渲染相应的组件。它可以使用 path 属性来定义匹配的路径，以及 component 属性来指定要渲染的组件。

c.Switch 组件：Switch 组件是一个容器组件，用于包裹多个 Route 组件。它会遍历所有的 Route 组件，并渲染第一个与当前 URL 匹配的组件。这样可以确保只有一个页面组件被渲染，避免多个页面同时渲染的情况。

d.Link 和 NavLink 组件：Link 组件用于在应用中实现导航链接，它生成一个 <a> 标签，点击时不会刷新整个页面，而是通过 History API 或哈希来更新 URL。NavLink 组件是 Link 的扩展，它可以根据当前 URL 是否匹配其路径来自动添加活动状态的样式。

e.Route Props 和 URL 参数：Route 组件可以接收一些额外的属性（props），这些属性可以包含 URL 中的参数，如 match、location 和 history。这些属性允许你在组件中访问当前 URL 的信息，以及实现动态的路由逻辑。

f.编程式导航：React Router 还提供了编程式导航的方式，即通过 JavaScript 代码来触发路由的切换。这可以通过 history 对象来实现，例如使用 history.push('/new-route') 来切换到新的路由。

总的来说，React Router 的实现原理是基于监听 URL 变化，根据匹配的路径渲染相应的组件，同时提供了导航链接和编程式导航的功能，以实现单页面应用中的页面导航和路由管理。

history 模式下，用户在某个url下刷新，不做任何配置就会404，怎么样解决这个问题呢？
在 hash 模式下，URL 中的路径信息包含在 # 符号之后。浏览器在发送请求时，会忽略 # 后面的部分，因此服务器接收到的请求总是根路径 /。所以即使 URL 拼错了，服务器也会返回根目录下的 HTML 文件，因为服务器只关心 # 之前的部分，而前端会处理 # 后面的部分。
只需要在前端项目，加一个捕获所有未匹配的路由，通常是 404 提示页面。
JavaScript
const router = new Router({   mode: 'hash', 
// 使用 hash 模式routes: 
[
     { path: '/', component: Home },    
     { path: '/user/profile', component: UserProfile },  
     { path: '*', component: NotFound } 
// 捕获所有未匹配的路由   
]});
在 history模式下，只能是修改服务端的东西，比如 给所有404异常请求都返回固定的404页面 或者 根项目的index.html。
￮静态文件中间件：app.use(express.static(path.join(__dirname, 'public'))); 设置静态文件目录。
￮API 路由：定义特定的 API 路由和服务路由，例如 /api/data 和 /service/status。
￮前端路由处理：在 app.get('*', (req, res, next) => { ... }) 中，通过检查请求头的 Accept 字段，决定是否返回 index.html。如果请求是对 HTML 的请求（通常是浏览器导航），返回 index.html，否则将请求传递给下一个中间件。
￮404 页面处理：app.use((req, res, next) => { ... }) 捕获所有未匹配的路由，并返回自定义的 404 页面。
￮错误处理：最后的错误处理器 app.use((err, req, res, next) => { ... }) 处理服务器中的其他错误，并返回 500 错误信息。
JavaScript
const express = require('express');
const path = require('path');

const app = express();
const port = 3000;

// 设置静态文件目录
app.use(express.static(path.join(__dirname, 'public')));

// 定义 API 路由
app.get('/api/data', (req, res) => {
  res.json({ message: 'Hello, world!' });
});

// 处理其他服务的路由
app.get('/service/status', (req, res) => {
  res.send('Service is running');
});

// 捕获前端路由（除开已定义的 API 和服务路由）
app.get('*', (req, res, next) => {
  const accept = req.headers.accept || '';
  if (accept.includes('text/html')) {
    // 如果请求头接受 HTML，则返回 index.html
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
  } else {
    // 否则将请求传递给后续中间件
    next();
  }
});

// 处理 404 页面
app.use((req, res, next) => {
  res.status(404).sendFile(path.join(__dirname, 'public', '404.html'));
});

// 处理其他错误
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});

history 和 hash两种路由模式的区别？
SPA(单页面应用): 单页面应用是使用一个html下加载js, css等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。
React-router 里的 router 分为两类。
hash router 很简单，window.location.hash获取hash值，监听hashchange事件。
history router 是基于 history 库开发，原理是浏览器本身提供的history的两个api和popstate事件的监听。
1.hash 路由模式的实现主要是基于下面几个特点：
￮URL 中的 hash 值只是客户端的一种状态，向服务端发送请求的时候，hash 部分不会被发送。
￮hash 值得改变会在浏览器的历史记增加访问记录，所以可以通过浏览器的回退、前进控制 hash 值的改变。
￮可以通过 a 标签设置 href 值或者通过 js 给location.hash 赋值来改变 hash 值。
￮可以通过hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。
2.history 路由模式的实现主要是基于下面几个特点：
￮通过 pushState 和 replaceState 两个API 来操作实现 URL 的变化。
￮可以通过 popstate 事件来监听 URL 的变化，从而对页面进行跳转（渲染）。
￮history.pushState() 或 history.replaceState() 不会触发 popstate 事件，需要手动触发页面跳转。
￮可以通过监听 popstate 事件来检测 URL 的变化。当调用 pushState 或 replaceState 方法或点击 <a> 标签改变 URL 时，不会触发 popstate 事件，但是可以通过拦截 pushState/replaceState 的调用和 <a> 标签的点击事件来检测 URL 变化。
对比
￮pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL，而 hash 只可修改 # 后面的部分。
￮pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中。而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中。
￮pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中，而 hash 只可添加短字符串。pushState() 可额外设置 title 属性供后续使用。
￮在hash模式下，URL只更改#后面的部分，浏览器不会重新发起HTTP请求，不利于SEO。
在history模式下，当你使用history.pushState()或history.replaceState()方法改变URL时，虽然URL发生了变化，但浏览器并不会因此重新发起HTTP请求。这是因为这两个方法只是改变了浏览器的历史记录，并没有真正地向服务器发送请求。然而，如果用户直接在浏览器的地址栏中输入一个新的URL，或者刷新页面，则会向服务器发起HTTP请求，获取新的页面。
￮history模式会发起请求，如果url匹配失败会报错，所以记得后端有个默认的index.html作为兜底。

代码
HTML
<!DOCTYPE html>
<html lang="en">
<body>
<ul>
    <ul>
        <!-- 定义路由 -->
        <li><a href="#/home">home</a></li>
        <li><a href="#/about">about</a></li>
        <!-- 渲染路由对应的 UI -->
        <div id="routeView"></div>
    </ul>
</ul>
</body>
<script>
    let routerView = routeView
    window.addEventListener('hashchange', ()=>{
        let hash = location.hash;
        routerView.innerHTML = hash
    })
    window.addEventListener('DOMContentLoaded', ()=>{
        if(!location.hash){//如果不存在hash值，那么重定向到#/
            location.hash="/"
        }else{//如果存在hash值，那就渲染对应UI
            let hash = location.hash;
            routerView.innerHTML = hash
        }
    })
</script>
</html>

JavaScript
<!DOCTYPE html>
<html lang="en">
<body>
<ul>
    <ul>
        <li><a href='/home'>home</a></li>
        <li><a href='/about'>about</a></li>
        <div id="routeView"></div>
    </ul>
</ul>
</body>
<script>
    let routerView = routeView
    window.addEventListener('DOMContentLoaded', onLoad)
    window.addEventListener('popstate', ()=>{
        routerView.innerHTML = location.pathname
    })
    function onLoad () {
        routerView.innerHTML = location.pathname
        var linkList = document.querySelectorAll('a[href]')
        linkList.forEach(el => el.addEventListener('click', function (e) {
            e.preventDefault()
            history.pushState(null, '', el.getAttribute('href'))
            routerView.innerHTML = location.pathname
        }))
    }

</script>
</html>


68. 浏览器事件冒泡、事件捕获、事件委托？React的事件委托有什么区别？React如何获取原生事件？
浏览器中的事件处理机制主要包括事件冒泡、事件捕获以及事件委托，这些概念在理解React的事件处理机制时非常重要。

1.事件冒泡：这是DOM事件处理的一个阶段，当一个事件在一个元素上触发后，如果该元素没有处理该事件，事件会向上传播到其父元素，直到文档根节点或者遇到一个处理该事件的元素为止。这一过程称为事件冒泡。

2.事件捕获：与事件冒泡相反，事件捕获是事件处理的另一个阶段，它从最上层的祖先元素开始，然后逐级向下传播到目标元素。这一机制允许在事件到达目标元素之前就在某个祖先元素上截获并处理它。

3.事件委托：也称作事件代理，是一种利用事件冒泡或捕获机制来减少事件监听器数量的技术。通过将事件监听器绑定在父元素上，而非每个子元素上，可以利用事件流的特性来判断实际的目标元素，并执行相应的操作。这样可以有效减少内存消耗，特别是对于动态生成的大量子元素，只需在父元素上设置一次监听器即可。

React中的事件委托：
React 实现了自己的事件系统，但它也是基于浏览器的事件冒泡机制的。React 并不直接将事件监听器绑定到每个DOM元素上，而是采用事件委托的方式，将大部分事件监听器绑定到document上。这意味着，无论React应用中的元素如何嵌套，实际的事件监听器都只存在于document这一层级。当事件发生时，React会根据事件目标确定哪个组件应该处理该事件，然后调用对应的处理函数。这种方式减少了内存使用，提高了性能，并且简化了跨浏览器兼容性问题。

React如何获取原生事件：
在React中，可以通过在事件处理函数中访问event.nativeEvent来获取底层的原生浏览器事件对象。例如，如果你有一个onClick处理函数，你可以这样获取原生事件：
JavaScript
handleClick = (event) => {
  // 获取原生事件对象
  const nativeEvent = event.nativeEvent;
  console.log(nativeEvent);
  // 进行其他操作...
}

// 在组件中使用此处理函数
<button onClick={this.handleClick}>Click me</button>
在React中，event.target实际上指的是触发事件的DOM元素，它是对原生DOM事件中的event.target的一个封装。当你在React组件中处理事件（如onClick、onChange等）时，传递给事件处理器的event对象是React合成事件（SyntheticEvent）的一个实例，这是React为了实现跨浏览器兼容性和提供一些额外的便利性而创建的一个包装对象。
尽管是封装过的，React的合成事件系统确保了event.target的行为与原生DOM事件中的event.target非常相似，都指向触发该事件的DOM元素。
因此，从功能上看，你完全可以把它当作是“原生的触发事件目标”。你仍然可以使用event.target来访问触发事件的元素属性，比如修改样式、读取DOM属性等，就像在原生JavaScript中那样。
不过，需要注意的是，由于React合成事件最终会在适当的时候调用原生事件，并在其后清理自己以避免内存泄漏，所以在使用过程中应当注意不要依赖于React合成事件对象在事件处理函数之外的存在。

69. 解决跨域问题，jsonp原理，cors预检请求
同源策略
同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。
这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。
同源指的是：协议、端口号、域名必须一致。
跨域解决方案
最佳方案，CORS【跨域资源共享】
浏览器将CORS分为简单请求和非简单请求：
简单请求不会触发CORS预检请求。
若该请求满足以下两个条件，就可以看作是简单请求：
1）请求方法是以下三种方法之一：
•HEAD
•GET
•POST
2）HTTP的头信息不超出以下几种字段：
•Accept
•Accept-Language
•Content-Language
•Last-Event-ID
•Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
在简单请求中，在服务器内，至少需要设置字段：Access-Control-Allow-Origin


在非简单请求中，在服务器内，至少需要设置字段：Access-Control-Allow-Origin，Access-Control-Allow-Methods，Access-Control-Allow-Headers。
Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段

为了避免Options 预检请求次数过多，通过 设置 Access-Control-Max-Age来指定预检请求的有效期
•Origin: 表示请求来自哪个源。
•Access-Control-Request-Method：用来列出浏览器的CORS请求会用到哪些HTTP方法。
•Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

跨域请求携带cookie，还需要满足以下3个条件
•Access-Control-Allow-Credentials: true   
•Access-Control-Allow-Origin 设置为非 *
•xhr.withCredentials = true 或者 axios.defaults.withCredentials = true

日常方案，配置webpack ｜ vite 的devServer，原理就是服务器之间是没有同源策略限制的。
TypeScript
 devServer: {       
    proxy: {            
    '/api': {                
            target: 'http://xxx.com/',            
            pathRewrite: {'^/api' : ''},       
            changeOrigin: true, // target是域名的话，需要这个参数，是ip则不需要      
            secure: false, // 设置支持https协议的代理           
        }
    } 
}
配置 changeOrigin 修改 host 的作用是在代理请求时，
将请求头中的 Host 字段修改为目标服务器的地址。这通常用于解决跨域请求的问题。

node项目，用一些跨域中间件，其实本质就是CORS。
jsonp，仅支持get方法，容易受到xss攻击，利用<script>标签没有跨域限制。
TypeScript
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>

nginx配置代理，与cors一致。
iframe跨域
document.domain = 'aaa.com'，设置相同的主域， 子窗口通过 window.parent.xxx 获取变量值。
利用一个中间页面，监听页面hash值变化实现 iframe跨域。
websocket协议
实现浏览器与服务器全双工通信，天然支持跨域。
postMessage API 
对于页面和其打开的新窗口或多窗口的数据传递。
iframe.contentWindow.postMessage 和 window.parent.postMessage
JavaScript
以下是您请求的跨域方案的代码示例：
使用 document.domain 进行跨域(1)(2)：
// 在父页面和子页面中设置相同的主域
document.domain = "example.com";
利用 location.hash 进行跨域(3)：
// 在 iframe 中
window.parent.location.hash = 'message';
// 在父页面中
window.addEventListener('hashchange', function() {
    var hash = window.location.hash;
    // 处理消息
});
使用 WebSocket 进行跨域(4)(5)：
// 创建 WebSocket 连接
var socket = new WebSocket("ws://localhost:8080");

// 连接打开时发送消息
socket.onopen = function() {
    socket.send("Hello Server!");
};
使用 postMessage API 进行跨域(6)(7)(8)(9)：
// 在源窗口中var iframe = document.createElement('iframe');
iframe.src = "http://www.sourceB.com";
document.body.appendChild(iframe);

// 发送数据给 iframe
iframe.contentWindow.postMessage('Hello, IFrame!', 'http://www.sourceB.com');
// 在目标窗口中
window.addEventListener('message', function(event) {
    if (event.origin !== "http://example.com") return;
    // 处理消息
}, false);
70. 前端debugger方式?错误分析、代码调试、抓包
代码调试
•前端项目：写debugger，自动进入到浏览器调试模式，也可以是vscode launch.json文件配置浏览器调试。
•后端项目：我习惯于vscode打断点在项目里慢慢看。
抓包
•app、小程序端：习惯用Charles，主要用于配置代理环境，实现在手机端本地调试，抓包主要是查看埋点问题。
•pc端：习惯于用whistle，可以替换switch host，无host缓存问题，在开发者工具里的network观察。
错误分析
观察 console、vconsole、network里的错误信息。
sourceMap配置: devtool: cheap-module-source-map或eval-source-map。
这样在浏览器的开发者工具中，错误堆栈跟踪将直接指向源代码中的问题行。
线上环境：通常都是安装了sdk，通过sourceMap上报错误信息，定位异常代码的位置。
JavaScript
TypeError: Cannot read property 'xxx' of undefined
2at Module.<anonymous> (http://localhost:8080/bundle.js:1:17)
71. SEO 优化及解决
常见SEO优化方式
1.元标签优化：确保每个页面都有合适的<title>、<meta description>和<meta keywords>标签，这些是搜索引擎理解页面内容的关键信息。
2.语义化HTML：使用语义化的HTML标签（如<header>、<main>、<article>、<section>等）来结构化内容，帮助搜索引擎更好地解析页面结构。
3.图片优化：为图片添加alt属性描述，便于搜索引擎理解图片内容。同时，通过压缩和合理命名图片文件来提高加载速度和相关性。
4.响应式设计：确保网站在不同设备上都能良好展示，提高用户体验和搜索引擎评价。搜索引擎倾向于优先展示移动友好的网站。
5.内部链接：合理规划网站内部链接结构，有助于搜索引擎抓取更多页面，并理解页面间的关系和重要性。
6.页面速度优化：减少HTTP请求、压缩代码和资源、利用缓存等手段加快页面加载速度。页面速度是搜索引擎排名的一个重要因素。
Server-Side Rendering (SSR)
Server-Side Rendering 是一种技术，用于在服务器端生成HTML，然后将其发送到浏览器，而不是像客户端渲染（CSR，如React的默认模式）那样在浏览器中使用JavaScript动态渲染页面。SSR的优势在于：
•即时内容加载：用户无需等待JavaScript执行即可看到页面内容，这对于SEO特别有利，因为搜索引擎爬虫通常不会执行JavaScript，直接渲染的HTML更易于被索引。
•更好的搜索引擎可见性：由于内容直接在HTML中可用，搜索引擎可以更容易地抓取和理解页面内容，提高了页面的可索引性和排名。
•改善用户体验：对于禁用JavaScript的用户或使用屏幕阅读器的用户，SSR提供了更好的体验。
然而，SSR也带来了额外的服务器负载和可能的延迟问题
渐进式Web应用（Progressive Web Apps, PWA）
PWA是一种使用现代Web技术（HTML, CSS, JavaScript）构建的Web应用，旨在提供接近原生应用的用户体验。
•离线可用性：通过Service Workers实现缓存机制，使得应用在无网络连接时也能提供基础功能。
•安装便捷：用户可以直接从浏览器将PWA“安装”到他们的设备上，看起来就像一个原生应用，拥有独立的图标和全屏模式。
•推送通知：能够发送推送通知，增强用户参与度。
•即时加载：通过高效的缓存策略，实现快速加载。
•安全性：要求使用HTTPS来保证通信的安全性。
静态站点生成（Static Site Generation, SSG）
SSG是一种网站构建方式，它在构建时将数据（如Markdown文件或CMS内容）与模板结合，预先生成纯HTML文件。与之相对的是动态站点，后者在每次请求时才生成页面内容。
•高性能：因为内容是静态的，页面加载速度快，服务器只需提供静态文件，无需执行复杂的后端逻辑。
•SEO友好：搜索引擎更容易抓取和索引静态内容。
•低成本：静态站点对服务器资源的需求较低，可以部署在低成本甚至免费的CDN上。
•开发效率：适合内容为主的网站，编辑内容后重新生成即可，无需复杂的后端配置。
同构渲染（Isomorphic Server-side Rendering, ISG）
同构渲染结合了客户端渲染（Client-Side Rendering, CSR）和服务器端渲染（Server-Side Rendering, SSR）的优点，允许在服务器和客户端使用相同的代码库来渲染组件。
•首屏加载快：通过服务器端预渲染内容，快速向用户提供可交互的页面，类似于SSR。
•SEO优化：同样因为服务器生成的HTML对搜索引擎友好。
•无缝切换：首次加载后，控制权可以平滑地转移到客户端，实现类似SPA（单页应用）的交互体验。
•复杂性增加：需要更复杂的架构来确保两端（服务器和客户端）的渲染结果一致，增加了开发和维护的难度。

72. webpack常见配置项优化？
webpack优化
￮首先，我先说说我平时写webpack的配置文件的思路，主要的配置项都是最初写好的。
▪配置文件主要分为 webpack.common.js、webpack.dev.js、webpack.prod.js，也就是线上与开发环境，走不同的打包配置，最后用 webpack-merge 合并配置。
JavaScript
const merge = require('webpack-merge');
module.exports = merge.smart(commonConfig,{...})
▪利用 minimist 这个包 读取 package.json 里的参数配置项 和 命令行参数。
•通常是实现条件编译，指定打包某一部分页面，提升本地打包速度和热更新效率。
•对于多页的项目，通常会把 项目入口 和 HtmlWebpackPlugin 插件的 配置信息 抽取出来维护。
•类似于 .env.mobile 文件，也可以定义不同 mode下的环境变量。
JavaScript
const minimist = require('minimist');
const args = minimist(process.argv.slice(2));
const { platform } = args;

"build:zhuzhan": "pnpm run lint && NODE_ENV=production webpack --mode production --platform zhuzhan",

- `--html` 打包的页面是否带.html后缀
- `--platform xx` 指定当前打包的platform
- `--page 'Home,Cashout'` 指定只打包某个页面，需要先指定platform再指定page
例如 npm run build:dst -- --page='Home'
        

JavaScript
new HtmlWebpackPlugin({
    minify: process.env.NODE_ENV === 'development' ? false : { // 压缩HTML文件
        removeComments: true, // 移除HTML中的注释
        minifyCSS: true, // 压缩内联css
    },
    inject: true, // 打包代码放到body的最后面
    name: chunkName, // chunk名
    title: title || '到家精选联盟', // html标题
    entry: path.join(rootPath, entry || `src/pages/${prefix}/${key}/index`), 
    template: template || `public/${prefix}Index.html`,
    filename: `${chunkName}`, // 页面名称
    chunks: [chunkName],
    production: process.env.NODE_ENV === 'production' ? 1 : 0,
    isChallenge,
    sjtPay,
    isUnionhy,
})    
▪定义 resolve.alias 别名 、 DefinePlugin 定义全局变量、style-loader、file-loader等常见loader，通过 babel-loader 对 node_modules 或 src里源代码进行降级处理。
▪常见的优化策略
•TerserPlugin压缩代码，MiniCssExtractPlugin 抽取css，cache-loader缓存loader处理结果，splitChunk.chunks 设为async，externals 排除一些如react 公共包。
▪其余的优化策略
•dllplugin：减少类库的打包次数
•持久性缓存：hard-source-webpack-plugin
•thread-loader、HappyPack 【多线程打包，加快打包速度】
•image-webpack-loader，imagemin-webpack-plugin压缩图片，转化为 webp 格式 等等。
•用 BundleAnalyzerPlugin 分析后处理
•webpack5：设置缓存组，cacheGroups，有效使用公共依赖
JavaScript
'cache-loader'
plugins: [
    new MiniCssExtractPlugin({
        filename: 'static/css/[name].css',
        chunkFilename: 'static/css/[name].css',
    }),
],
optimization: {
    minimizer: [
        new TerserPlugin({
            parallel: true,
            cache: true,
        }),
    ],
    splitChunks: {
       chunks: 'async',
    },
},
externals: {
    // axios: 'axios',
    react: 'React',
    'react-dom': 'ReactDOM',
    'react-router': 'ReactRouter',
    'react-router-dom': 'ReactRouterDOM',
},
 
▪生产环境和线上环境的webpack的差异性通常体现 devtool的sourceMap 和 output的 publicPath的区别。
JavaScript
devtool: 'source-map',
devServer: {
}
output: {
    publicPath: '//j1.58cdn.com.cn/git/lbg-fe/csc/',
},
output: {
    path: path.join(__dirname, '../dist'),
    filename: '[name].v-[hash:10].js',
    chunkFilename: '[name].v-[hash:10].js',
    publicPath: '/',
    // clean: true,
},    
73. 无限滚动的虚拟列表怎么实现的？不定高情况如何解决？加载时机判断，性能优化，浏览器dom节点处理细节?
虚拟列表是一种优化长列表渲染性能的技术，它只对可见区域内的数据进行渲染，从而避免了不必要的DOM操作。让我们来探讨一下虚拟列表的实现方法。
为什么需要虚拟列表？
假设我们有一个需要展示一万条记录的长列表，如果直接将这一万条数据一次性渲染到页面中，会导致以下问题：
•性能瓶颈：渲染大量DOM元素会消耗大量时间，特别是在列表项结构复杂的情况下。
•内存占用：一次性加载大量数据会占用大量内存，影响页面性能。
•渲染延迟：用户需要等待很长时间才能看到完整的列表。
虚拟列表的目标是解决这些问题，只渲染可见区域内的数据，从而提高性能。
实现思路
虚拟滚动是一种优化大量列表渲染的技术，尤其适用于移动端或数据量巨大的场景。其核心思想是只渲染当前屏幕可见的项，以及一些缓冲区内的项，而不是一次性渲染所有数据。这样可以显著减少DOM操作和内存消耗，提升应用性能。
关键点分析
1.计算可视区域: 首先需要确定用户的可视高度(userHeight),。
2.确定每个Item的高度: (rowHeight) 这个值对于固定高度的虚拟滚动至关重要，因为它允许我们准确地计算出哪些项应该被渲染。
3.计算缓冲区: (bufferSize) 缓冲区用于处理快速滚动的情况，确保在滚动过程中用户不会看到空白区域。它决定了在可视区域之上和之下额外渲染多少个元素。
4.监听滚动事件: (onScroll) 通过监听滚动事件，实时计算当前视口的起始和结束索引(startIndex 和 endIndex)，并更新状态。
5.动态渲染: 根据计算出的起始和结束索引，动态生成和渲染需要显示的项。使用绝对定位将每个元素放置在其正确的位置上，以模拟一个长列表的效果。
6.优化渲染性能: 利用React的虚拟DOM特性，只更新真正发生变化的部分，避免不必要的重绘。
7.“不定高”的虚拟列表
a.实际上在初始化时仍依据预估的高度进行渲染，在等到渲染完成后根据元素的实际高度动态更新各个元素的位置，并通过transform的方式，让列表渲染容器移动位置，使其始终保持在可视容器中。
b.为了避免重复计算每一个元素的实际高度我们需要一个数组cachedPositions来缓存每一个元素的位置以及高度信息。
c.对渲染出来的元素做实际高度更新，在 componentDidMount 生命周期内进行。
d.当发生滚动需要渲染更多的元素时，在componentDidUpdate 生命周期钩子来重新进行计算、判断和更新：
JavaScript
//当前滑动的scrollTop - 没有消失完全的高度 - 缓冲区的高度
getTransform = () => `
    translate3d(0, ${
        scrollTop -  
        (scrollTop % rowHeight) -  
        Math.min(originStartIdx, bufferSize) * rowHeight
    }px, 0)
`;
技术细节
•性能考量: 确保rowHeight尽可能准确，因为它是计算渲染范围的关键。
•滚动惯性处理: 快速滚动时，可能需要更大的bufferSize来防止闪烁或空白出现。
•边界情况: 处理startIndex和endIndex，确保它们不会超出数据总范围(total)。
•样式调整: 注意rowRender中的样式属性，如height和top，确保每个元素正确地对齐和显示。
•兼容性: 考虑不同设备和浏览器的差异，特别是滚动事件的处理和样式渲染。
掘金文章
https://juejin.cn/post/7232856799170805820#heading-8
https://juejin.cn/post/6948011958075392036
【https://juejin.cn/post/7185500155235205177】推荐
固定高度- hook
JavaScript
import React from "react";

export interface FixInnerHeightListProps {
    /**
     * 用户视野高度
     */
    userHeight: number;
    /**
     * 数据总数
     */
    total: number;
    /**
     * 每个item的行高
     */
    rowHeight: number;
    /**
     * 每个item的渲染方法
     * @param index 序列号
     * @param styleData 样式
     */
    rowRender: (index: number, styleData: React.CSSProperties) => any;
    /**
     * 缓冲区的个数
     */
    bufferSize?: number;
    /**
     * no-data时的显示
     */
    noDataContent?: React.ReactNode;
}

export default class FixInnerHeightList extends React.Component<FixInnerHeightListProps> {
  state = { scrollTop: 0 };
  //可视范围的高度
  height = this.props.userHeight || 800;
  //数据总条数
  total = this.props.total || 1000;
  //固定的行高
  rowHeight = this.props.rowHeight || 90;
  //用来过渡快速滑动来不及渲染问题
  bufferSize = this.props.bufferSize || 5;

  //可视范围内展示的元素数
  limit = Math.ceil(this.height / this.rowHeight);
  //记录当前的真实下标
  originStartIdx = 0;
  startIndex = Math.max(this.originStartIdx - this.bufferSize, 0);
  endIndex = Math.min(
    this.originStartIdx + this.limit + this.bufferSize,
    this.total - 1
  );

  scrollContainer = React.createRef<HTMLDivElement>();

  onScroll = (e: any) => {
    if (e.target === this.scrollContainer.current) {
      const { scrollTop } = e.target;
      const { total, rowHeight, limit, originStartIdx, bufferSize } = this;

      //计算当前的startIndex
      const currentIndex = Math.floor(scrollTop / rowHeight);

      if (originStartIdx !== currentIndex) {
        this.originStartIdx = currentIndex;
        this.startIndex = Math.max(currentIndex - bufferSize, 0);
        this.endIndex = Math.min(currentIndex + limit + bufferSize, total - 1);
        this.setState({ scrollTop });
      }
    }
  };

  renderDisplayContent = () => {
    const { rowHeight } = this;
    const content: any[] = [];
    for (let i = this.startIndex; i <= this.endIndex; ++i) {
      content.push(
        this.props.rowRender(i, {
            height: rowHeight - 1 + "px",
            lineHeight: rowHeight + "px",
            left: 0,
            right: 0,
            position: "absolute",
            top: i * rowHeight,
            borderBottom: "1px solid #000",
            width: "100%"
        })
      );
    }
    return content;
  };

  render() {
    const { height, total, rowHeight } = this;
    return (
      <div
        ref={this.scrollContainer}
        style={{
          overflowX: "hidden",
          overflowY: "auto",
          height,
          backgroundColor: "#fff"
        }}
        onScroll={this.onScroll}
      >
        <div style={{ height: total * rowHeight, position: "relative" }}>
          {this.renderDisplayContent()}
        </div>
      </div>
    );
  }
}

不定高-hook
JavaScript
let cachedPositions: any[] = [];
const updateCachedPositions = (startIdx: number) => {

    const cachedPositionsLen = cachedPositions.length;
    let cumulativeDiffHeight = cachedPositions[startIdx].dValue;
    cachedPositions[startIdx].dValue = 0;

    for (let i = startIdx + 1; i < cachedPositionsLen; ++i) {
      const item = cachedPositions[i];
      cachedPositions[i].top = cachedPositions[i - 1].bottom;
      cachedPositions[i].bottom = cachedPositions[i].bottom - cumulativeDiffHeight;
      if (item.dValue !== 0) {
        cumulativeDiffHeight += item.dValue;
        item.dValue = 0;
      }
    }

    return cachedPositions[cachedPositionsLen - 1].bottom;
};

onmessage = (e) => {
  console.log(e);
    if (e.data[0] === 'update') {
        cachedPositions = e.data[2];
        const bottom = updateCachedPositions(e.data[1]);
        postMessage([cachedPositions, bottom]);
    }
};
export {}

JavaScript
export enum CompareResult {
    eq = 1,
    lt,
    gt
}
  
export function binarySearch<T, VT>(
    list: T[],
    value: VT,
    compareFn: (current: T, value: VT) => CompareResult
  ) {
    let start = 0;
    let end = list.length - 1;
    let tempIndex = 0;
  
    while (start <= end) {
      tempIndex = Math.floor((start + end) / 2);
      const midValue = list[tempIndex];
  
      const compareRes: CompareResult = compareFn(midValue, value);
      if (compareRes === CompareResult.eq) {
        return tempIndex;
      }
      if (compareRes === CompareResult.lt) {
        start = tempIndex + 1;
      }
      if (compareRes === CompareResult.gt) {
        end = tempIndex - 1;
      }
    }
  
    return tempIndex;
}
  

JavaScript
import React from "react";
import { binarySearch, CompareResult } from "./bst";

export interface DynamicInnerHeightListProps {
  /**
   * 用户视野高度
   */
  userHeight: number;
  /**
   * 数据总数
   */
  total: number;
  /**
   * 估算的每个item的行高
   */
  estimateRowHeight: number;
  /**
   * 每个item的渲染方法
   * @param index 序列号
   * @param styleData 样式
   */
  rowRender: (index: number, styleData: React.CSSProperties) => any;
  /**
   * 缓冲区的个数
   */
  bufferSize?: number;
  /**
   * no-data时的显示
   */
  noDataContent?: React.ReactNode;
}

interface CachedPosition {
  /**
   * 元素的下标
   */
  index: number;
  /**
   * 顶部距离定位的偏移位置
   */
  top: number;
  /**
   * 底部距离定位的偏移位置
   */
  bottom: number;
  /**
   * 元素的高度
   */
  height: number;
  /**
   * 元素渲染后和之前估计的高度的差值
   */
  dValue: number;
}

export default class DynamicInnerHeightList extends React.Component<DynamicInnerHeightListProps> {
  state = {
    scrollTop: 0,
  };

  height = this.props.userHeight;
  total = this.props.total;
  estimateRowHeight = this.props.estimateRowHeight;
  bufferSize = this.props.bufferSize || 5;

  scrollHeightContainer = React.createRef<HTMLDivElement>();

  limit = Math.ceil(this.height / this.estimateRowHeight);
  originStartIdx = 0;
  startIndex = 0;
  endIndex = Math.min(
    this.originStartIdx + this.limit + this.bufferSize,
    this.total - 1
  );

  /**
   * 用来保存每个元素渲染后的高度数据，避免重复计算
   */
  cachedPositions: CachedPosition[] = [];
  actualContentRef = React.createRef<HTMLDivElement>();
  phantomContentRef = React.createRef<HTMLDivElement>();
  phantomHeight = this.estimateRowHeight * this.total;

  worker: Worker | null = null;

  constructor(props: DynamicInnerHeightListProps) {
    super(props);
    console.log("url", import.meta.url);
    this.worker = new Worker(new URL("./worker.ts", import.meta.url));
    this.initCachedPositions();
  }

  componentDidMount() {
    if (this.actualContentRef.current && this.total > 0) {
      this.updateCachedPositions();
    }
  }

  componentDidUpdate() {
    if (this.actualContentRef.current && this.total > 0) {
      this.updateCachedPositions();
    }
  }

  componentWillUnmount() {
    this.worker?.terminate();
  }

  initCachedPositions = () => {
    for (let i = 0; i < this.total; ++i) {
      this.cachedPositions[i] = {
        index: i,
        top: i * this.estimateRowHeight,
        bottom: (i + 1) * this.estimateRowHeight,
        height: this.estimateRowHeight,
        dValue: 0,
      };
    }
  };

  /**
   * mounted以及updated之后更新元素高度数据数组
   */
  updateCachedPositions = () => {
    if (!this.actualContentRef.current) {
      return;
    }
    const nodes: NodeListOf<any> = this.actualContentRef.current.childNodes;
    const start = nodes[0];

    //计算显示的每个元素的高度的不同
    nodes.forEach((node: HTMLDivElement) => {
      if (!node) return;
      const rect = node.getBoundingClientRect();
      const { height } = rect;
      const index = Number(node.id.split("-")[1]);
      const oldHeight = this.cachedPositions[index].height;
      const dValue = oldHeight - height;

      if (dValue) {
        this.cachedPositions[index].bottom -= dValue;
        this.cachedPositions[index].height = height;
        this.cachedPositions[index].dValue = dValue;
      }
    });

    let startIdx = 0;
    if (start) {
      startIdx = Number(start.id.split("-")[1]);
    }

    if (this.worker) {
      this.worker.postMessage(["update", startIdx, this.cachedPositions]);
      this.worker.onmessage = (e) => {
        const [newCachedPositions, height] = e.data;
        this.phantomHeight = height;
        this.cachedPositions = newCachedPositions;

        if (this.phantomContentRef.current) {
          this.phantomContentRef.current.style.height = `${height}px`;
        }
      };
    }
  };

  /**
   * 二分法查找当前的元素
   * @param scrollTop 已滚动的距离
   */
  getStartIndex = (scrollTop = 0) => {
    let idx = binarySearch<CachedPosition, number>(
      this.cachedPositions,
      scrollTop,
      (currentValue, targetValue) => {
        const currentCompareValue = currentValue.bottom;
        if (currentCompareValue === targetValue) {
          return CompareResult.eq;
        }
        if (currentCompareValue < targetValue) {
          return CompareResult.lt;
        }

        return CompareResult.gt;
      }
    );

    const targetItem = this.cachedPositions[idx];

    //如果找到的是一个不可见的元素，则+1处理显示下一个
    if (targetItem.bottom < scrollTop) {
      idx += 1;
    }

    return idx;
  };

  onScroll = (e: any) => {
    if (e.target === this.scrollHeightContainer.current) {
      const { scrollTop } = e.target;
      const { originStartIdx, bufferSize, limit, total } = this;

      const currentIndex = this.getStartIndex(scrollTop);

      if (originStartIdx !== currentIndex) {
        this.originStartIdx = currentIndex;
        this.startIndex = Math.max(this.originStartIdx - bufferSize, 0);
        this.endIndex = Math.min(
          this.originStartIdx + limit + bufferSize,
          total - 1
        );
        this.setState({ scrollTop });
      }
    }
  };

  /**
   * 通过css控制实际渲染后的节点的偏移
   */
  getTransform = () => `
    translate3d(0, ${
      this.startIndex >= 1
        ? this.cachedPositions[this.startIndex - 1].bottom
        : 0
    }px, 0)
  `;

  renderDisplayContent = () => {
    const content: any[] = [];
    for (let i = this.startIndex; i <= this.endIndex; ++i) {
      content.push(
        this.props.rowRender(i, {
          left: 0,
          right: 0,
          width: "100%",
        })
      );
    }
    return content;
  };

  render() {
    const { height, phantomHeight, total } = this;
    const { noDataContent } = this.props;
    return (
      <div
        ref={this.scrollHeightContainer}
        style={{
          overflowX: "hidden",
          overflowY: "auto",
          height,
          //   width: 200,
          position: "relative",
        }}
        onScroll={this.onScroll}
      >
        <div
          ref={this.phantomContentRef}
          style={{ height: phantomHeight, position: "relative" }}
        />
        <div
          ref={this.actualContentRef}
          style={{
            width: "100%",
            position: "absolute",
            top: 0,
            transform: this.getTransform(),
          }}
        >
          {this.renderDisplayContent()}
        </div>
        {total === 0 && (noDataContent || <div>暂无数据</div>)}
      </div>
    );
  }
}

74. http状态码
•201 Created：在成功创建新资源时使用。常用于POST请求成功并创建了新的资源。
•204 No Content：表示服务器成功处理了请求，但没有返回任何内容。常见于DELETE请求成功删除资源时
•205 Reset Content：该状态码表示服务器已经成功处理了客户端的请求，并且要求客户端重置当前页面。常见应用场景是在进行表单提交后，服务器需要清除表单数据并重置用户界面。
•206 Partial Content：该状态码表示服务器已经成功处理了范围请求，即客户端请求的资源的一部分。常见应用场景是在下载大文件时进行分块传输。
TypeScript
HTTP/1.1 206 Partial Content
Content-Type: application/octet-stream
Content-Length: 1000000
Content-Range: bytes 500000-1499999/2000000
Date: Fri, 01 Oct 2021 12:00:00 GMT

...（文件的部分内容）...
在此示例中，客户端发起了一个范围请求，要求下载一个大小为 2,000,000 字节的文件的一部分。
服务器返回状态码 206，并在响应头部中提供了 Content-Range 字段，指示返回的是文件的哪个范围。
同时，响应正文中包含了文件的部分内容。
•302 Found：表示所请求的资源暂时移动到不同的URL。与301状态码类似，但302状态码表示临时移动。
•304 Not Modified：表示资源在客户端缓存中未发生变化，可以直接使用缓存的内容。常用于缓存控制。
•301 Moved Permanently：表示所请求的资源已永久移动到新的URL。常见的应用场景是网站重定向或更改网页URL。当服务器收到请求后，会将响应中的Location字段设置为新的URL，并且客户端应该使用新的URL发送后续请求。
•307 Temporary Redirect：也表示所请求的资源暂时移动到了新的URL。与301状态码不同，307状态码表示临时移动。当服务器收到请求后，会将响应中的Location字段设置为新的URL，表示资源的临时位置，同时要求客户端继续使用原始URL发送后续请求。
•400 Bad Request：表示服务器无法理解客户端的请求或请求参数有误。常见的应用场景包括请求的语法错误、缺少必要的参数、参数格式错误等。当服务器收到此状态码时，通常会在响应中提供具体的错误信息以帮助客户端排查问题。
•401 Unauthorized：表示客户端需要进行身份验证才能获取请求的资源。
•403 Forbidden：表示服务器拒绝处理请求，因为客户端的请求权限不足。
•404 Not Found：表示所请求的资源不存在。
•405 Method Not Allowed：表示服务器不支持客户端请求的方法。
•406 Not Acceptable：表示服务器无法生成根据客户端请求中的 Accept 头部信息提供的内容。
•500 Internal Server Error：表示服务器在执行请求时遇到了意外错误。
•502 Bad Gateway：表示作为代理或网关的服务器从上游服务器接收到无效的响应。
•503 Service Unavailable：表示服务器暂时无法处理请求，通常是因为服务器过载或维护中。
•504 Gateway Timeout：表示作为代理或网关的服务器无法在预定的时间内从上游服务器接收到响应。
•505 HTTP Version Not Supported：表示服务器不支持客户端请求的HTTP协议版本。
75. jsbridge的实现原理
JSBridge的实现原理主要是为了实现在原生应用（Native）和Web页面（通常是嵌入在原生应用内的WebView组件中加载的H5页面）之间的双向通信。具体来说，它涉及以下几个核心步骤和概念：
1.注入JS接口: 在原生应用启动时，通常会在WebView加载完成时，通过WebView的接口向JavaScript环境中注入一个或多个JavaScript对象（称为Bridge）。这个过程是Native调用JS的过程，目的是让Web页面的JavaScript可以访问到这些对象，从而调用Native的功能。
2.消息传递: JSBridge的核心在于定义一套消息传递机制，允许JavaScript和Native代码互相调用对方的功能。这通常通过字符串化的JSON消息来实现，包含调用的方法名、参数以及用于接收响应的回调ID。
￮从JS调用Native: 当JavaScript需要调用Native代码时，它会通过Bridge对象发送一个包含调用信息的消息。这个消息会被Native端监听到，并根据消息的内容执行相应的Native函数，完成后通过之前约定的方式返回结果给JavaScript。
￮从Native调用JS: 类似地，当Native需要触发JavaScript中的函数时，它可以通过WebView的evaluateJavascript方法执行一段JavaScript代码，这段代码通常会调用之前注入到JavaScript环境中的某个函数，并传递必要的参数。
3.消息队列与同步: 为了保证消息传递的顺序和可靠性，JSBridge通常会实现一个消息队列来管理待处理的消息，确保消息被顺序处理，且每个调用都有对应的回调机制。
4.安全性和沙箱限制: 由于涉及到跨环境通信，JSBridge还需要考虑安全策略，确保只允许预期的交互发生，防止任意代码执行等安全风险。
5.兼容性处理: 不同平台（如Android和iOS）和不同版本的WebView可能有不同的实现细节，因此在实现JSBridge时需要考虑兼容性问题，确保在各种环境下都能稳定工作。
综上所述，JSBridge的实现原理围绕着如何在JavaScript与Native之间搭建一个安全、高效、灵活的通信桥梁，使得两者能够互相调用，共同完成复杂的应用功能。

76. vue双向绑定实现原理代码
数据响应式原理
Vue 3 采用 Proxy 结合 响应式 API 来实现数据的响应式。
•初始化数据：在 Vue 3 初始化过程中，会调用 reactive 方法初始化 data 数据。这个方法使用 Proxy 对象来代理数据，实现数据的监听。
•监听数据变化：当读取 data 中的数据时，会自动触发 get 方法。当修改 data 中的数据时，会自动触发 set 方法。这样，Vue 3 可以检测到数据的变化。
•通知观察者：观察者（Watcher）会自动触发重新渲染当前组件。Vue 3 框架会遍历并对比新旧虚拟 DOM 树中每个节点的差异，并将这些差异局部修改到真实 DOM 树上。
vue2 实现
JavaScript
let data = {
    name: "hdf",
    age: 19,
    friend: {
        name: "张纹龙",
    },
};

//变成响应式数据
observer(data);

function observer(target) {
    function defineReactive(target, key, value) {
        //深度观察
        observer(value);
        Object.defineProperty(target, key),
        {
            get() {
                return value;
            },
            set(newValue) {
                observer(newValue);
                if (newValue !== value) {
                    value = newValue;
                    console.log("更新视图");
                }
            },
        };
    }
    if (!target || typeof target == "object") {
        return target;
    }
    for (let key in target) {
        defineReactive(target, key, target[key]);
    }
}

vue3 实现
JavaScript
// 判断是否为对象 ，注意 null 也是对象
const isObject = val => val !== null && typeof val === 'object'
// 判断key是否存在
const hasOwn = (target, key) => Object.prototype.hasOwnProperty.call(target, key)

function reactive(target) {
    // 首先先判断是否为对象
    if (!isObject(target)) return target

    const handler = {
        get(target, key, receiver) {
            console.log(`获取对象属性${key}值`)
            // 这里还需要收集依赖，先空着
            track(target, key)

            const result = Reflect.get(target, key, receiver)
            // 递归判断的关键, 如果发现子元素存在引用类型，递归处理。
            if (isObject(result)) {
                return reactive(result)
            }
            return result
        },

        set(target, key, value, receiver) {
            console.log(`设置对象属性${key}值`)

            // 首先先获取旧值
            const oldValue = Reflect.get(target, key, reactive)

            // set 是需要返回 布尔值的
            let result = true
            // 判断新值和旧值是否一样来决定是否更新setter
            if (oldValue !== value) {
                result = Reflect.set(target, key, value, receiver)
                trigger(target, key)
            }
            return result
        },

        deleteProperty(target, key) {
            console.log(`删除对象属性${key}值`)

            // 先判断是否有key
            const hadKey = hasOwn(target, key)
            const result = Reflect.deleteProperty(target, key)

            if (hadKey && result) {
                // 删除时，是否需要 响应式触发trigger
                trigger(target, key)
            }

            return result
        },
    }
    return new Proxy(target, handler)
}

// activeEffect 表示当前正在走的 effect
let activeEffect = {}
const effectStack = [];

function effect(fn,options = {}) {
  const effectFn = () => {
      cleanup(effectFn)
      activeEffect = effectFn
      effectStack.push(effectFn);
      const res = fn()
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
      return res;
  }
  effectFn.deps = []
  effectFn.options = options;
  if(!options.lazy){
     effectFn()
  }
  // computed
  return effectFn
}

function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
        const deps = effectFn.deps[i]
        deps.delete(effectFn)
    }
    effectFn.deps.length = 0
}

// targetMap 表里每个key都是一个普通对象 对应他们的 depsMap
let targetMap = new WeakMap()

function track(target, key) {
    if (!activeEffect) return
    // 获取当前对象的依赖图
    let depsMap = targetMap.get(target)
    // 不存在就新建
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()))
    }
    // 根据key 从 依赖图 里获取到到 effect 集合
    let dep = depsMap.get(key)
    // 不存在就新建
    if (!dep) {
        depsMap.set(key, (dep = new Set()))
    }
    // 如果当前effectc 不存在，才注册到 dep里
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect)
        activeEffect.deps.push(dep)
    }
}

// trigger 响应式触发
function trigger(target, key) {
    // 拿到 依赖图
    const depsMap = targetMap.get(target)
    if (!depsMap) {
        // 没有被追踪，直接 return
        return
    }
    // 拿到了 视图渲染effect 就可以进行排队更新 effect 了
    const dep = depsMap.get(key)
    // 遍历 dep 集合执行里面 effect 副作用方法
    // 避免 副作用的依赖数组 无限增删依赖问题
    const effectsToRun = new Set(dep);
    effectsToRun.forEach(effectFn => {
        if(effectFn.options.scheduler){
            effectFn.options.scheduler(effectFn)
        }else{
            effectFn()
        }
    })
}

function computed(fn) {
    let dirty = true;
    let val;
    const effectFn = effect(fn,{
        lazy: true,
        scheduler(fn){
            if(!dirty) {
                dirty = true
                trigger(obj, 'value');
            }
        }
    });
    const obj = {
        get value(){
            if(dirty){
                val = effectFn();
                dirty = false;
                // console.log('重新计算',val);
            }else{
                // console.log('旧值',val);
            }
            track(obj, 'value');
            return val;
        }
    }
    return obj
}

// 遍历读取对象的每个值
function traverse(value,seen = new Set()){
    if(value !== 'object' || value === null || seen.has(value)){
        return;
    }
    seen.add(value);
    for(const k in value){
        traverse(value[k],seen);
    }
    return value;
}

function watch(source,cb,options={}){
    let getter;
    let newValue,oldValue;
    if(typeof source === 'function'){
        getter = source;
    }else{
        getter = traverse(source);
    }
    const job = ()=>{
        newValue = effectFn();
        cb(oldValue,newValue);
        oldValue = newValue;
    }
    const effectFn = effect(()=> getter(),{
        lazy: true,
        scheduler: job
    })
    if(options.immediate){
        job()
    }else{
        oldValue = effectFn();
    }
}


77. pc端项目-页面性能优化 ｜spa 单页加载速度优化方式？｜ h5页面-页面性能优化如何实现的 ？
性能优化
第一步：准备工作
•影响首屏渲染速度或者页面性能的主要原因是什么？
•原有页面获取数据和渲染流程至少能大致说清楚。
•已经做了哪些页面性能方面的优化？
•是否知道页面的性能指标，有数据支撑才有说服力。
•h5 和客户端方面的大致优化方向，需要后端和性能监控平台支持的地方，有了大致的概念。
￮客户端
▪HTML预加载 preload，在webview启动前，提前下载HTML文档。
•【常见的资源位、金刚位，推荐算法的计算结果预加载】
•页面缓存策略【缓存时间设定，进入或离开界面更新缓存，放入内存中，关闭app清除缓存】
￮有些SSR的页面会涉及到状态的变更，比如说：领劵场景。
a.H5 页面在打开时针对状态可能会发生变更的组件，再次请求接口获取最新的状态数据。
b.客户端由进入页面就更新HTML文档修改为：关闭webview时更新HTML文档。
•引起的问题：预加载无形中造成了大量的请求，SSR 服务和算法服务的压力增加。
•CDN缓存减少服务端压力
•预加载展望：提前把页面内的资源加载好，这样在打开一个页面的时候可以减少大部分的网络请求从而更快速的把内容呈现给用户。这里还需要考虑如何跟离线包进行协作。
▪HTML预请求 prefetch ，在webview初始化的同时，去下载HTML主文档。
•预加载是在App启动后用户无任何操作的情况下就会去下载，但是预请求只会在用户单击打开H5页面的时候才会去下载。
•深入挖掘：可以在路由阶段【路由->native页面初始化->webview启动】进行拦截，既可以统一收口而且距离用户点击的时间间隔可以忽略不计。通过这种方式将下载HTML时机提前了平均80ms+。
▪HTML 预渲染 prerender
•客户端提前通过webview将页面渲染好，等待用户访问时，可直接展示，从而达到瞬开效果。但是这种功能肯定不能对所有的页面进行开放，而且存在一定的弊端。
•会额外消耗客户端资源，需要在主线程空闲时执行，并需要控制预渲染的页面数量。
•如果页面一进入就会下红包雨，这种页面是不适合做预渲染的，需要进行规避。
▪离线包的实现
•通过提前将H5页面内所需的css、js等资源聚合在一个压缩包内，由客户端在App启动后进行下载解压缩，在后续访问H5页面时，匹配是否有本地离线资源，从而加速页面访问速度。
•资源拦截这块安卓这边实现比较简单，webview支持 shouldInterceptRequest, 可以在该方法内检测是否需要进行资源拦截，需要的话返回 WebResourceResponse 对象，不需要直接返回 null。
▪接口预请求
•通过客户端发起H5页面首屏接口请求，远比等待客户端页面初始化、下载HTML、JS下载执行的时机更提前，从而节省用户的首屏等待时间。在本地测试过程中发现接口预请求可提前100+ms，用户也就可以更快的看到内容。
￮h5优化的方向
▪服务端渲染ssr + 页面资源的缓存，是我最先想到的点。
•接口预请求 + 浏览器缓存
•静态页面缓存：无接口
•无用户状态的页面缓存：展示内容一致
•有用户状态的界面缓存：千人千面，涉及算法接口响应较慢，减轻服务端压力，可以转为CSR。
￮如果利用cdn缓存，可以改为首页ssr，后续通过csr方式更新内容。
￮在感知到内容变更时自动调用CDN服务商的刷新缓存接口来更新CDN缓存内容。
▪预渲染html
通过puppeteer将SPA页面渲染出来并将HTML文档进行保存，配合上述页面刷新策略，并将HTML通过CDN进行托管，让你的 SPA 页面 像 SSR 一样丝滑。主要实现方案是通过基于webpack的插件prerender-spa-plugin，并配置需要预渲染的路由，这样经过打包之后就会产出对应路由的页面。方案本身是通用的，但是每接入一个页面都需要人工check。
▪css的优化
•将首屏所需要的css 文件通过内联方式内嵌到HTML中，由SSR服务一并返回。
•对css文件进行拆分，按需加载。
•最初尝试了MiniCssExtractPlugin 插件他可以把css分成单独的文件，并且每一个js会对应生成一个css文件，但是他需要建立在webpack5之上，然而项目中使用的next版本是9.5，于是就想着升级到最新版next12。经过不懈的努力，通过阅读 next 源码发现了端倪，发现在打包时将所有的公共css通过 splitChunks 进行分组，由于项目中组件都是动态引入的，这里直接在 next.config.js 中修改webpack打包参数，将 splitChunks.cacheGroups.styles 配置删除，使用默认的 chunks: async 配置，即可实现按需引入。
▪图片优化
•避免图片src为空，因为也会发请求。
•压缩图片质量，webp格式。
第二步：h5 性能优化措施
资源体积优化
•webpack优化：见上文
网络方面
•减少网络请求次数，防抖节流：按钮点击、联想搜索、scroll事件处理
•图片：图片懒加载，小图片 url-loader 转化为base64，合成雪碧图，svg图标。
•请求的并发控制，避免一次性发出大量请求，采用http2多路复用。
资源的缓存
•利用浏览器的强缓存和协商缓存
•CDN缓存与预加载：使用内容分发网络（CDN）将静态资源部署在网络边缘节点，可以快速响应用户的请求，并且可能预先推送或预加载资源以减少TTFB。
•利用好localStorage、seesionStorage、cookie，还有一些比如 mobx、vuex、zustand等状态管理工具，
尽可能从开发上就通过缓存来减少网络请求。
•webpack- splitchunks：有效拆分公共依赖，提高缓存利用率。
浏览器渲染优化
•减少浏览器重排次数 和 长列表的虚拟滚动：通常比较受重视的两点。
a.批量操作： 尽量将对DOM的多次操作合并成一次，然后一次性应用到DOM。比如，使用DocumentFragment进行操作，最后再插入文档。比如，根据行列索引进行网格布局时，先给元素设置display: none，确定后再修改style.display: grid。
b.使用样式类： 使用样式类而不是直接操作样式属性，因为在同一类操作下浏览器可能会进行优化，减少重排次数。
c.脱离文档流：常见操作就是利用绝对定位、fixed布局、浮动元素、overflow：hidden等方法，利用BFC是独立渲染区域，脱离文档流，不影响周围元素排布的特点，缩小了重排重绘的范围。
d.缓存布局信息： 在JavaScript中获取布局信息（如offsetTop、offsetWidth等）时，最好将其缓存起来，避免多次获取导致多次重排。
e.避免频繁读取布局信息： 避免在循环中或事件处理程序中频繁读取导致重排的布局信息。
f.使用css3 硬件加速（GPU加速）：比如 使用transform属性进行动画，浏览器会新建图层去绘制，然后再与原图层合成，不会引起原有图层的重排与重绘。
•css样式提前至head标签内，避免css文件加载阻塞。
•JS脚本async、defer模式的运用，避免JS的加载阻塞HTML的解析渲染。
•合理使用 Layers
•布局抖动优化：提前定好宽高
•SSR页面首屏 css 内联(Critial CSS)
•通过 Web Worker 减少主线程耗时
•通过 RAF 回调，在线程空闲时执行代码逻辑
•避免 css 嵌套过深
•preload 预加载，prefetch 预请求，提前加载或者请求后续需要的资源。
•keep-alive缓存渲染好的页面组件。
•数据埋点上报延迟发送，不阻塞 onload 事件触发
•自定义字体优化，使用 fontmin 生成精简的字体包
•图片、视频懒加载，资源压缩

进阶策略
•服务端渲染ssr + 流式渲染
服务端渲染（Server-Side Rendering, SSR）与流式渲染结合是一种提升用户体验和优化服务器资源使用的技术策略。这种策略特别适用于内容丰富的网页应用，比如新闻网站、社交媒体平台等，旨在让用户尽快看到页面内容，同时减轻服务器负担。下面我将概述如何实现这一技术组合及其核心思想。
核心思想
a.服务端渲染 (SSR): 传统客户端渲染（CSR，Client-Side Rendering）在浏览器中通过JavaScript动态构建DOM，而SSR则是在服务器上预先渲染好HTML，再将其发送给浏览器。这样用户无需等待JavaScript执行和数据获取即可看到页面的初始内容，有利于SEO和提高首屏加载速度。
b.流式渲染: 在SSR的基础上，流式渲染允许服务器在未完成整个页面渲染之前就开始向客户端发送部分HTML内容。这意味着用户可以更早地看到页面信息，即使剩余内容仍在服务器上处理。这大大减少了用户感受到的加载时间，提高了交互体验。
实现方法
实现SSR结合流式渲染，通常涉及以下几个关键步骤和技术点：
a.选择技术栈: 需要选择支持SSR和流式渲染的技术框架，如Next.js（React生态）、Nuxt.js（Vue生态）、SvelteKit（Svelte生态）等。这些框架通常内置或易于配置SSR，并对流式渲染提供一定程度的支持或可以通过插件实现。
b.分块与流式响应: 服务器端需要对页面内容进行逻辑分块，优先渲染最重要的内容块（如标题、摘要），然后逐步输出其他内容块。这要求后端渲染逻辑能够识别内容的优先级并按需输出。Node.js中的可写流（Writable Stream）是一个常用的工具来实现这一过程。
c.客户端接管: 当服务器开始流式传输HTML时，客户端（浏览器）可以立即开始解析已接收的部分HTML并显示内容。同时，客户端需要准备好接管后续的渲染工作，比如加载剩余的JavaScript、CSS以及执行必要的客户端渲染逻辑以增强交互性。
d.缓存策略: 为了进一步提升性能，应实施有效的缓存策略。对于频繁访问的页面或部分内容，可以考虑在服务器端或CDN上设置缓存，减少实时渲染的压力。
e.错误处理与优雅降级: 在实现流式渲染过程中，确保对错误有良好的处理机制，比如当某个内容块渲染失败时，不影响其他块的正常输出。同时，为不支持流式渲染的浏览器提供回退方案，保证基本的可用性。
总结
服务端渲染结合流式渲染是一种高级前端优化策略，它通过尽早展示内容给用户，显著提升了网页的加载速度和用户体验。实现这一技术需要深入理解前后端渲染流程、HTTP协议及现代前端框架的高级特性。随着Web技术的发展，越来越多的工具和框架开始支持这种模式，使得开发者能更便捷地实现高性能的Web应用。

第三步：研究项目本身问题
•影响首屏渲染速度或者页面性能的主要原因是什么？
•原有页面获取数据和渲染流程有了基本认知。
•已经做了哪些页面性能方面的优化？
•是否知道页面的性能指标，有数据支撑才有说服力。
这个项目主要流程就是HTML模板放在Java那边，js和css等资源通过cdn链接获取，html的某些变量被注入一些JSON信息，代表页面的主体内容。
这种 浏览器的缓存 + 页面结构数据获取，已经在服务端完成了，已经有了类似于SSR首屏渲染的苗头，只是Java不是把拼装后的首页html直接发给前端。
客户端：已经做了html、css、js等资源文件的预加载preload，html渲染的时机也没问题，甚至对有些高频的页面做了预渲染。所以，问题就主要定位到 h5页面本身的性能问题。

h5 性能优化可以分为几个大方向。 
资源体积大小和打包速度（terser插件代码压缩、webpack条件编译、代码拆分、路由懒加载、多线程打包插件、webpack打包缓存、splitchunks里有效拆分公共依赖，提高缓存利用率、DllPlugin引入打包好的库、排除不需要外包文件、指定文件夹减少缩小范围）
减少网络请求（防抖节流、并发控制、图片懒加载、小图片base64、雪碧图、避免图片src为空等）、
资源的缓存（利用浏览器缓存、状态管理根据、storage里的和cookie缓存、有效拆分项目代码、存储公共依赖也是重要方向）、
浏览器渲染优化（更加细节、主要就是减少重绘重排和长列表的虚拟滚动）、
服务端渲染（开启SSR、首屏样式内联返回） 

实际方案
•微前端拆分项目，明显提升热更新效率
•影响页面完整加载的埋点上报：延迟上报时间或者改变上报时间。主要应用策略是通过 IntersectionObserver api 去延迟发送展现埋点。
•JSON 渲染机制，利用数据罗盘项目想到的idea，将骨架屏占位的操作提前，减少浏览器的回流重绘操作。
•在活动页面改版的过程中进行，与后端一起抽离原有的业务代码逻辑，就是分开请求，尽可能用上缓存。
•对于不涉及用户登录态、推荐算法、分流策略的数据接口，让后端都加上浏览器缓存。

78. ssr应用和实现方法，nextjs框架实现原理
React Server-Side Rendering (SSR) 应用是一种提高用户体验和搜索引擎优化（SEO）的技术，它允许React应用在服务器上预先渲染HTML，然后将其发送到浏览器，从而让用户更快地看到页面内容，而不是等待所有JavaScript bundle下载并执行之后才渲染视图。
React SSR 应用的实现方法
1.使用ReactDOMServer: React提供了几个用于服务器渲染的API，如renderToString()和renderToStaticMarkup()，它们可以将React组件转换成HTML字符串。在Node.js环境中，你可以这样使用：
JavaScript
const ReactDOMServer = require('react-dom/server');
const MyComponent = require('./MyComponent');

// 渲染组件为HTML字符串
const html = ReactDOMServer.renderToString(<MyComponent />);
2.数据预取: 在服务器端渲染时，你需要确保所有必要的数据已经准备好。这通常涉及到在渲染之前执行数据获取逻辑（如API调用）。
3.客户端 hydration: 一旦服务器生成的HTML被浏览器接收，React在客户端“激活”或“hydrates”这个静态HTML，使其成为一个完全交互式的客户端应用。
4.路由和状态管理: SSR应用还需要考虑如何处理客户端和服务器端的路由同步以及状态管理，以确保用户体验的连贯性。
Next.js框架实现原理
Next.js是一个基于React的框架，它内置了对SSR的支持，并且简化了许多配置和实现细节。
Next.js使得构建高性能、易于维护的SSR React应用变得更加直接和高效。
1.自动代码分割: Next.js利用Webpack进行动态导入，实现按需加载，这意味着每个页面及其依赖仅在访问时加载，提高了性能。
2.文件系统路由: Next.js根据项目中的文件结构自动生成路由。例如，创建一个pages/about.js文件就会自动创建一个/about的路由。
3.预渲染与动态渲染: 
￮静态生成 (Static Site Generation, SSG): Next.js可以在构建时生成静态HTML文件，适用于内容不经常变化的页面。
￮服务器端渲染 (Server-Side Rendering, SSR): 对于需要动态数据的页面，Next.js会在每次请求时在服务器上渲染页面。
￮Incremental Static Regeneration (ISR): 结合了SSG和动态数据，允许静态页面在一定时间间隔或触发时自动更新。
4.Node.js服务器: Next.js使用Node.js作为服务器环境来处理SSR和API请求。它提供了一个开发服务器，并且可以轻松部署到生产环境。
5.热更新与模块缓存: Next.js利用Node.js的模块系统和热更新能力，当文件改变时，它能够高效地重新加载和编译受影响的部分，而不是重启整个服务器。
6.API路由: 除了页面路由，Next.js还支持API路由，可以直接在同一个项目中编写API逻辑，便于统一管理和部署。
79. 开发 h5 项目遇到的常见问题有哪些？用过navigator吗？
1.兼容性问题：不同的移动设备和浏览器对HTML5特性的支持程度不一，可能导致页面显示不一致或功能失效。例如，某些CSS3特性在老版本的浏览器中可能不被支持，支付宝小程序顶部有收藏键遮挡，taro的swiper组件的内部高度不在微信小程序生效等。
2.触摸事件与点击延迟：移动端的触摸事件（如touchstart、touchend）处理不当可能导致响应迟缓或双击缩放问题。
3.屏幕适配与布局问题：在不同尺寸和分辨率的屏幕上保持良好的视觉体验需要灵活的布局方案，如使用百分比布局、Flexbox或Grid布局，以及适当的媒体查询。
4.键盘遮挡输入框问题：在iOS和部分Android设备上，虚拟键盘弹出时可能会遮挡输入框，需要通过JS调整页面滚动或输入框位置。
5.性能优化：加载速度慢、动画卡顿等性能问题是常见的挑战，需要优化资源加载、使用懒加载、减少DOM操作等策略。
6.Web存储与离线访问：合理使用localStorage、IndexedDB等进行数据缓存，以及利用Service Worker和manifest文件实现离线访问能力。
7.调用原生功能：如通过navigator对象调用设备的GPS定位、相机、拨打电话、发送短信等功能，需要注意权限管理及兼容性问题。
8.跨端情况下的页面链接跳转 和 埋点上报策略的变化 会变得比较复杂。

关于navigator对象，它是JavaScript的内置对象，用于提供有关浏览器的信息，常用于检测客户端的功能或者确定用户代理。例如，navigator.userAgent可以用来获取用户代理字符串，从而判断用户使用的浏览器类型或版本；而navigator.geolocation可以用来访问浏览器的地理定位API。此外，如之前提到的，window.navigator.standalone属性可以用来判断网页是否以全屏模式（Web App模式）显示在iOS的Safari中。在H5项目开发中，navigator对象是非常实用的工具，特别是在需要与设备原生功能交互时。
80. 团队如何检测和上报出现异常的界面或者接口？
方案
要快速定位页面错误代码的具体位置，可以通过以下步骤结合错误信息与SourceMap进行分析：
1. 监听错误事件
首先，在前端代码中使用 window.addEventListener('error', errorHandler) 监听JavaScript运行时错误。对于未捕获的Promise rejection，可以使用 window.addEventListener('unhandledrejection', rejectionHandler)。
2. 错误处理器收集信息
在错误处理器（如 errorHandler 和 rejectionHandler）中，你需要收集错误信息，特别是错误堆栈（event.error.stack）。堆栈跟踪包含错误发生时的函数调用序列和每个调用的文件及行号信息，尽管这些信息是针对打包后的代码。
3. 上报错误堆栈
将收集到的错误信息（包括堆栈跟踪）上报到错误监控平台。确保在打包生产环境代码时，一同上传SourceMap文件到该平台。SourceMap是源代码与编译或压缩后代码之间的映射关系，它能帮助我们还原出错误发生在原始源代码的确切位置。

平台端处理流程
1.接收错误报告：错误监控平台接收到包含堆栈信息的错误报告。
2.解析堆栈信息：平台会使用类似于 source-map 库解析上报的错误堆栈。这一步涉及到读取上传的SourceMap文件，依据堆栈中的行号和列号在映射中查找对应的源代码位置。
3.生成可读的错误报告：通过解析，平台将打包后的代码位置转换为源代码位置，生成一个易于开发者理解的错误报告。报告中会包含错误类型、发生错误的源文件名、行号、列号以及周围的源代码上下文。
4.提供错误报告界面：平台以友好的界面展示错误报告，开发者可以直接点击错误报告中的链接跳转到源代码编辑器的相应行，迅速定位并修复问题。

示例错误报告
假设平台生成的错误报告可能如下所示：
Plain Text
Error: Cannot read properties of undefined (reading 'foo')
at Component.render (src/components/MyComponent.js:23:10)
这里，src/components/MyComponent.js:23:10 是根据SourceMap还原出的源代码位置，开发者可以立即知道错误发生在 MyComponent.js 文件的第23行第10列，而无需手动追踪压缩后的代码。
通过这种机制，即使在生产环境中使用了压缩和混淆的代码，也能高效地定位并解决错误。

81. 大文件上传
https://juejin.cn/post/7110121072032219166
需求分析
1.校验文件格式，界面有相应的文案提示【文件格式校验】
2.文件上传，不限制文件大小【大文件上传】
3.上传期间断网，再次联网不用重新上传，文件上传暂停【断点续传】
4.进度条提示，上传成功或者失败会有相应的弹窗提示【文件切片的拆分与统计】
5.上传同一个文件，可以做到秒传【文件存储与查询】
分工
前端
1.校验文件格式【比如 支持doc, md , pdf 等，界面有提示文案】
2.使用 MD5（或者其他哈希算法）计算文件的哈希值
3.文件切片
4.发起检查请求，比对文件的hash值
5.实现普通的文件上传
6.上传进度计算，统计文件上传情况
7.上传完成，通知后端合并切片
后端
1.普通的文件接收
2.检查接收到的文件hash值，然后通知前端当前hash是否有未完成的上传
3.文件切片合并
总结
1.前端检查文件格式【后缀名判断 -> 】
文件格式判断
JavaScript

切片逻辑
利用file对象的slice方法，对文件进行切分，存入一个数组。
JavaScript
createChunks(file,chunkSize) {
    let start = 0;
    let partList = [];
    while (start < file.size) {
        const end = current + chunkSize;
        partList.push(file.slice(start,end));
        start = end;
    }
    return partList;
},

计算文件 hash
•当文件内容发生改变时，hash值也会发生改变。
•如果只根据文件名区分，当上传同名的新文件时，后端会以为是断点续传，导致旧文件资源无法得到替换。
•这里用递归读取切片内容，是为了防止并发读取大量blob内容，容易把内存挤爆
•采用web worker形式，避免计算hash时间过长，造成浏览器的主线程的阻塞
JavaScript

calculateHash(partList, fileIndex) {
  return new Promise((resolve) => {
    const worker = new Worker('./hash.js');
    worker.postMessage({ partList });
    worker.onmessage = (event) => { // 监听子进程 传过来的数据
      const { percent, hash } = event.data;
      this.setHashPercent(percent, fileIndex); 
      if (hash) {
        resolve(hash);
      }
    };
  });
},

// hash.js
self.importScripts('https://cdn.bootcss.com/spark-md5/3.0.0/spark-md5.js');
self.onmessage = e => {
  const { partList } = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index => {
    const reader = new FileReader();
    reader.readAsArrayBuffer( partList[index]);
    // 这里用递归读取切片内容，是为了防止并发读取大量blob内容，容易把内存挤爆
    reader.onload = e => {
      count++;
      spark.append(e.target.result);
      if (count === partList.length) {
        self.postMessage({
          percentage: 100,
          hash: spark.end()
        });
        self.close();
      } else {
        percentage += 100 / partList.length;
        self.postMessage({
          percentage
        });
        loadNext(count);
      }
    };
  };
  loadNext(0);
};


并发请求
JavaScript
createRequests(partList) {
  return partList.map((part) => {
    const formData = new FormData();
    // part.chunk 每个切片的真正内容
    formData.append(part.filename, part.chunk.slice(part.loaded), part.filename);
    return request({
      url: `${this.action.partUpload}/${part.filename}/${part.chunk_name}/${part.loaded}`,
      method: 'POST',
      data: formData, // 这里FormData 格式
      setXHR: (xhr) => {
        part.xhr = xhr;
      },
      // 进度条 核心 event.loaded 返回已经上传过的文件大小
      onProgress: (event) => {
        const percent = parseInt(Number((Number(part.loaded + event.loaded) / part.chunk.size * 100)), 10);
        part.percent = percent > 100 ? 100 : percent;
      },
    });
  });
},
async uploadParts(partList, filename, fileIndex) {
  if (!filename) return;
  const requests = this.createRequests(partList);// 获取切片请求
  await Promise.all(requests);// 同时请求
},
断点续传、秒传
每次上传分片前先获取已经上传文件的列表, 将列表与本地列表进行筛选, 已经上传的移除。
JavaScript
createRequests(partList, uploadedList) {
  const partLists = partList.filter((part) => {
    const uploadedFile = uploadedList.find((item) => item.filename === part.chunk_name);
    if (!uploadedFile) { // 未上传过的
      part.loaded = 0;
      part.percent = 0;
      return true;
    }
    if (uploadedFile.size < part.chunk.size) { // 上传过一部分的
      part.loaded = uploadedFile.size; // 后端返回已上传过文件的大小
      part.percent = parseInt(Number((Number(part.loaded) / part.chunk.size * 100)), 10);
      return true;
    }
    if (uploadedFile.size >= part.chunk.size) {
      part.percent = 100;
      return false;
    }
    return false;
  });
  return partLists.map((part) => {
    const formData = new FormData();
    formData.append(part.filename, part.chunk.slice(part.loaded), part.filename);
    return request({
      url: `${this.action.partUpload}/${part.filename}/${part.chunk_name}/${part.loaded}`,
      method: 'POST',
      data: formData,
      setXHR: (xhr) => {
        part.xhr = xhr;
      },
      onProgress: (event) => {
        const percent = parseInt(Number((Number(part.loaded + event.loaded) / part.chunk.size * 100)), 10);
        part.percent = percent > 100 ? 100 : percent;
      },
    });
  });
},
async uploadParts(partList, filename, fileIndex) {
  if (!filename) return;
  // 先向服务器获取已上传过的文件列表
  const { needUpload = true, uploadedList = [] } = await this.getUploadedList(filename);
  if (!needUpload) { // 表示该文件已经上传完整, 不用在上传.
    partList.forEach((item) => {
      item.percent = 100;
    });
    this.handleSuccess(fileIndex, true);
    return;
  }
  const requests = this.createRequests(partList, uploadedList);
  await Promise.all(requests);
  const res = await request({
    url: this.action.upload,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: JSON.stringify({ filename }),
  });
  if (res.success) {
    this.handleSuccess(fileIndex);
    return;
  }
  this.$message.error('发生未知异常错误，请重新上传!');
},
暂停 ｜继续
JavaScript
// 继续
async resumeItem(index) {
  const { partList = [], hashName } = this.fileList[index];
  this.fileList[index].state = UPLOADING;
  this.uploadParts(partList || [], hashName, index);
},
// 暂停 xhr.abort 核心 将每个请求 xhr 保存到 partList 中
pauseItem(index) {
  const { partList = [] } = this.fileList[index];
  this.fileList[index].state = PAUSE;
  partList.forEach((part) => part.xhr && part.xhr.abort());
},
82. 瀑布流布局
瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部，瀑布流的主要特性便是错落有致，定宽而不定高的设计让页面区别于传统的矩阵式图片布局模式。
实例
主体思路是记录每一列的高度，父容器相对定位，成员绝对定位，利用top与left属性控制位置，每次新增加成员时找到高度最低的那个将成员置于其下方，即可实现瀑布流布局。
如果不需要动态加入成员，而只是一次性加载供展示用，那么可以考虑使用flex布局将容器设置为flex-direction: column;以及flex-wrap: wrap;
CSS
.container {
  display: flex;
  flex-direction: column;
  flex-wrap: wrap;
  height: 800px; /* 适当的高度 */
}

.container {
column-count: 5;
/* 列数 */
column-gap: 10px;
/* 列间距 */
}
并给予容器一个合适的高度来实现，还可以使用CSS3新增的column-*多列布局来实现。
这两种也就是纯CSS实现的瀑布流布局的方式，
但是由于这两种方式都是将成员纵向排列，并不适合需要动态插入成员的布局，当需要动态插入成员时还是需要使用Js来实现。
JavaScript
<!DOCTYPE html>
<html>
<head>
    <title>Js瀑布流布局</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1" />
    <style type="text/css">
        #container{
            position: relative; /* 父容器relative */
        }
        .item{
            position: absolute; /* 成员设置为absolute */
            display: flex; /* 主要为显示字居中 */
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            color: #fff; /* 字体颜色白色 */
        }
    </style>
</head>
<body>
    <div id="container"></div>
</body>
    <script type="text/javascript">
        var column = 3; // 制作三列布局
        var counter = 0; // 计数器 为显示当前块计数
        var columnHeight = Array(column).fill(0); // 记录每列高度
        var container = document.getElementById("container"); // 父容器对象
        var colorList = ["#EAA78C", "#F9CD82", "#9ADEAD", "#9CB6E9", "#E49D9B", "#97D7D7", "#ABA0CA", "#9F8BEC","#ACA4D5", "#6495ED", "#7BCDA5", "#76B4EF","#E1C38F","#F6C46A","#B19ED1","#F09B98","#87CECB","#D1A495","#89D196","#FE9E9F", "#93BAFF", "#D999F9", "#81C784", "#FFCA62", "#FFA477"]; // 颜色列表

        function random(min=0, max=1) { // 生成随机数
          return min + ~~((max-min)*Math.random()) // min <= random < max 
        }

        function findMinColumn(arr){ // 找到高度最小的列
            var min = arr[0];
            var index = 0;
            arr.forEach((v,i) => {
                if(v < min) {
                    min = v;
                    index = i;
                }
            })
            return [index,min];
        }


        function appendImg(){
            var gap = 3; // 间隙设为3px
            for(let i=0;i<12;++i){ // 每次加载12个成员
                var unit = {
                    height:random(100,500), //随机一个不定高度
                    width: 300, // 定宽
                    color: colorList[random(0,colorList.length)] // 随机颜色
                }
                var [minIndex,min] = findMinColumn(columnHeight); // 获取高度最小列以及下标
                var d = document.createElement("div");  // 创建一个节点
                d.className = "item"; // 设置class
                d.style.background = unit.color; // 设置背景颜色
                d.style.height = `${unit.height}px`; // 设置宽度
                d.style.width = `${unit.width}px`; // 设置宽度
                d.style.top = `${min + gap}px`; // 设置上偏移
                d.style.left = `${(300 + gap) * minIndex}px`; // 设置左偏移
                d.innerText = `${++counter}#${unit.height}X${unit.width}`; // 设置文字
                columnHeight[minIndex] += (unit.height+gap); // 更新选中列的高度
                container.appendChild(d); // 添加节点
            }
        }

        function init(){
            appendImg(); // 初始加载
            var endLoad = columnHeight.some(v => v > window.innerHeight); // 获取是否有某列高度大于屏幕高度
            if(!endLoad) init(); // 如果没有则递归调用继续加载
        }

        (function(){
             init(); // 打开页面自动加载
        })();

        window.onscroll = function (){ // 浏览器触底事件
            var marginBottom = 0;
            if (document.documentElement.scrollTop){
                var scrollHeight = document.documentElement.scrollHeight;
                var scrollTop = document.documentElement.scrollTop + document.body.scrollTop;
                var clientHeight = document.documentElement.clientHeight;
                marginBottom= scrollHeight - scrollTop - clientHeight;
            } else {
                var scrollHeight = document.body.scrollHeight;
                var scrollTop = document.body.scrollTop;
                var clientHeight = document.body.clientHeight;
                marginBottom= scrollHeight - scrollTop - clientHeight;
            }
            if(marginBottom<=0) appendImg();
        }

    </script>
</html>

83. 从 URL 到 浏览器渲染的流程
DNS 查询
浏览器首先需要将用户输入的网址转换成相应的 IP 地址，这个过程称为 DNS 解析。浏览器会向本地 DNS 服务器发送一个 DNS 查询请求，本地 DNS 服务器会将这个请求转发到根域名服务器、顶级域名服务器、权威域名服务器等，最终查询到目标网站的 IP 地址，并返回给浏览器。 
TCP 握手
得到服务器 IP 地址后，会通过 TCP 三次握手与服务器建立连接。
浏览器会向目标网站的服务器发送一个 SYN 报文段，如果服务器端回复一个 SYN/ACK 报文段，浏览器就会发送一个 ACK 报文段，这样就建立了一个 TCP 连接。
TLS 协商
HTTPS 的链接还需要再进行 TLS 协商以确保数据传输的安全性。
响应
通常我们输入url，是发起get请求会得到html文件和相应的资源文件。
因为 TCP 的慢启动规则，初次请求的内容大小通常是 14KB 的数据，下一个包的数据大小会一直翻倍，直到达到预定的阈值或遇到拥塞。
解析
当浏览器收到服务器发送的数据后，就进入了解析阶段。
对于html文件，浏览器会通过解析器将html标签转换为DOM节点，得到DOM树。如果遇到不加async、defer属性的script标签，会阻塞html的解析。
对于css文件，需要用 CSS 解析器构建 CSSOM 树，表示选择器间的层级关系。目的是为了给 JavaScript 提供操作样式的能力和为渲染树的合成提供基础的样式信息。
defer 和 async 属性都是去异步加载外部的JS脚本文件，它们则不会阻塞 DOM 的解析，其区别如下：
•执行顺序： 
￮多个带 async 属性的标签，不能保证加载的顺序；
￮多个带 defer 属性的标签，按照加载顺序执行；
•脚本是否并行执行： 
￮async 表示脚本的下载是异步的，而下载完毕后如果 DOM 未解析完，则阻塞 DOM 解析，先执行脚本。
￮defer 表示脚本的下载是异步的，而执行 JavaScript 脚本需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前才执行。
将 DOM 和 CSSOM 组合成一个 Render 渲染树，从渲染树的根节点开始构建，遍历每个可见的节点。
像 <head> 和它的子节点以及
任何具有 display: none 样式的结点不会出现在 Render 树上。
而具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。

第一次计算出节点位置和大小的过程，称为Layout布局。
对节点大小和位置的重新计算，称为回流。
到了最后一步，就是需要将各个节点绘制到页面上，称为绘制。

在绘制时，可以分为多个图层，将内容提升到GPU上的层可以提高绘制性能，比如css3的transfrom等一些特定属性。
每个图层会生成绘制列表，并提交到合成线程。
合成线程将图层分成不同的图块，并通过栅格化将图块转化为位图，合成线程发送绘制图块的指令，然后浏览器进程会生成页面，并显示在屏幕上。
至此，主线程的绘制页面完成了。
值得注意的是，浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列， 浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。
流程
url检查->强缓存判断->DNS查询->mac地址->TCP三次握手-> https握手-> DOM树 -> CSSOM树-> render树->布局、回流、绘制-> 分图层、GPU性能提升-> 绘制列表，提交合成线程-> 分为图块-> 栅格化为位图-> 线程发送绘制图块的命令-> 主线程绘制完毕 -> 渲染队列，批处理，回流与重绘

（1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
（4）获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
（5）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
84. React 弹窗组件手写
JavaScript
import React, { useState } from 'react';
import ReactDOM, { createPortal } from 'react-dom';
import './index.scss';
const Modal = ({ isOpen, onClose, children }) => {
    // 如果modal未打开，则不渲染任何内容
    if (!isOpen) return null;
    // 使用createPortal方法将内容渲染到modal-root中
    return createPortal(
        <div className="modal-overlay">
            <div className="modal">
                {children}
                <button className="modal-close" onClick={onClose}>
                    关闭
                </button>
            </div>
        </div>,
        document.getElementById('modal-root')
    );
};

export default function MessageBox() {
    const [showModal, setShowModal] = useState(false);
    const handleClick = () => {
        setShowModal(true);
    };

    const handleClose = () => {
        setShowModal(false);
    };
    return (
        <div>
            <button style={{ color: 'red' }} onClick={handleClick}>显示消息弹窗</button>
            <Modal isOpen={showModal} onClose={handleClose}>
                <h2>消息标题</h2>
                <p>这里是消息内容...</p>
            </Modal>
        </div>
    );
}

JavaScript
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .modal {
    background-color: white;
    padding: 2rem;
    border-radius: 4px;
    width: 80%;
    max-width: 600px;
    text-align: center;
    position: relative;
  }
  
  .modal-close {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 100px;
    height: 30px;
    background: none;
    border: 1px solid black;
    box-shadow: 0px 2px 0 0 rgba(0, 0, 0, 0.3);
    font-size: 20px;
    cursor: pointer;
  }
85. git工作流程
在日常开发中，Git的工作流程通常包括以下几个步骤：
1.初始化仓库 (git init): 创建一个新的Git仓库。
2.添加文件 (git add): 将文件添加到暂存区。
3.提交更改 (git commit): 将暂存区的更改保存到本地仓库。
4.分支管理 (git branch, git checkout, git merge, git rebase等): 创建、切换和合并分支。
5.同步更新 (git fetch, git pull, git push): 与远程仓库同步代码。

Git Merge:
•当你使用 git merge 命令时，Git会将指定分支（比如一个特性分支）的提交历史合并到当前分支上，形成一个新的合并提交。这样做保留了所有提交历史，包括分支点之后两个分支上的所有提交。
•这种合并方式会产生一个具有合并信息的新提交，可以看到两个分支合并的过程，适合长期存在的分支或需要保留分支发展历史的情况。
Git Rebase:
•使用 git rebase 时，Git会把当前分支的提交历史“重放”到目标分支（通常是主分支）的最新提交之上。这意味着它会修改当前分支的提交历史，使其看起来像是直接基于目标分支的最新提交创建的。
•重置操作会使提交历史更加线性，看起来更“干净”，适用于还在开发中的特性分支，或当你不希望在主分支上看到特定的开发分支历史时。但需要注意，重写历史可能会影响与他人协作，特别是当更改已经推送到公共仓库时。
Git Revert:
•git revert 会创建一个新的提交来撤销之前的一个或多个提交，这个新提交的效果与要撤销的提交完全相反，但不会改变其他提交的历史。这种方式安全，因为它不会丢失任何历史信息，适合撤销已经推送并可能被他人依赖的提交。
Git Reset:
•git reset 有多种模式，但常用的是将HEAD指针移动到指定的提交，并根据参数（--soft, --mixed, --hard）决定是否保留暂存区和工作目录的更改。
￮--soft 只移动HEAD，保留所有更改在暂存区和工作目录。
￮--mixed（默认）移动HEAD并将更改移出暂存区，但保留工作目录的更改。
￮--hard 移动HEAD并丢弃所有后续更改，包括暂存区和工作目录的更改。
•使用 git reset 特别是 --hard 时要格外小心，因为它会导致数据丢失。这种操作更适合在本地未推送的更改上进行撤销操作。
综上所述，选择哪种命令取决于你想要达到的目的以及对版本历史的要求。
86. 如何检测 浏览器 内存泄漏的代码位置？前端日常开发时如何判断内存问题？
对 JS 堆内存 的监控
利用 window.performance.memory 提供了关于当前网页JavaScript堆内存使用情况的信息。
这个接口主要用于监控内存使用量，帮助开发者了解和诊断内存使用模式，并不直接用来检测内存泄漏，但可以作为辅助工具。
1.usedJSHeapSize:
这个属性表示当前JavaScript堆中已使用的内存大小，即JS对象（包括V8引擎内部对象）占用的内存数量。它是实时变化的，反映了当前时刻的内存占用情况。
2.totalJSHeapSize:
表示当前JavaScript堆的总大小，即浏览器为JavaScript分配的可使用的内存空间。这个值可能会随着页面生命周期和内存需求动态调整。
3.jsHeapSizeLimit:
指明了JavaScript堆内存大小的限制，即浏览器为当前上下文设定的最大内存使用量。当JavaScript堆接近或达到这个限制时，可能会触发垃圾回收机制以释放内存，否则可能会导致页面崩溃或性能问题。

•内存使用趋势：通过比较 usedJSHeapSize 在不同时间点的值，可以观察内存使用的变化趋势，判断是否有异常增长的情况。
•内存分配效率：分析 usedJSHeapSize 相对于 totalJSHeapSize 的比例，可以评估内存分配的效率和余量。
•潜在的内存限制：了解 jsHeapSizeLimit 可以帮助开发者意识到应用可能面临的内存上限，进而优化内存使用策略，防止因超出限制而导致的错误。
•
Chrome 开发工具
使用Chrome开发者工具中的Performance面板是定位和分析前端内存泄漏问题的一个有效方法。以下是利用该面板进行内存泄漏检查的步骤：
准备阶段
1.打开开发者工具：在Chrome浏览器中，按F12或右键点击页面选择“检查”来打开开发者工具。
2.切换到Performance面板：在开发者工具中找到并点击Performance标签页。
录制与分析
1.开始录制：点击面板左上角的圆形录制按钮开始录制。在录制之前，可以配置录制设置，确保Memory选项已被勾选，这样可以记录内存分配和垃圾回收事件。
2.模拟用户操作：在你认为可能导致内存泄漏的操作前后，保持录制状态。例如，如果你怀疑某个功能或交互有内存泄漏问题，就在开启该功能或执行交互的同时继续录制。
3.停止录制：完成操作后，停止录制。此时，开发者工具会生成一个详细的性能记录。
分析内存使用情况
1.查看内存图表：在录制结果的概览图中，寻找内存使用量随时间变化的趋势。正常情况下，内存使用在操作后应有所下降（因为垃圾回收），若持续上升则可能有内存泄漏。
2.详细分析：
￮Summary（汇总）视图：查看记录期间各种资源的使用情况，包括内存分配。
￮Memory视图：专注于内存分析，这里可以查看堆快照（Heap Snapshots）和分配时间线（Allocation Timeline）。
￮JS Heap（JavaScript堆）区域：关注内存使用峰值和回收情况。
3.采取堆快照：在怀疑内存泄漏的点，可以手动采取堆快照，然后在操作后再次采取快照，对比两个快照的差异来定位增加的内存对象。
￮使用Take heap snapshot按钮获取堆快照，然后在Snapshot面板中比较差异，查找未释放的对象和其保留树（Retainers）。
定位问题代码
1.录制性能概况：打开Chrome开发者工具，切换到"Performance"标签页。点击左上角的圆形录制按钮开始录制。此时可以执行你认为可能导致内存泄漏的操作，比如导航到新页面、触发特定功能等，然后停止录制。
2.分析记录：停止录制后，开发者工具会生成一个性能概况报告。这个报告详细地展示了录制期间的CPU使用率、FPS变化、内存分配情况等。
3.关注内存图表：在性能报告的顶部，你会看到一个概览图，其中包括了"Memory"图表。这个图表展示了堆内存的使用情况随时间的变化。如果在某个操作后内存使用显著上升且没有下降，这可能是内存泄漏的一个迹象。
4.深入分析具体事件：点击内存图表上的某个点或者某个时间段，可以查看该时刻的详细内存分配情况。这有助于识别哪些操作或函数调用导致了大量内存分配。
5.查看详细的内存分配：在概览图下方，你可以找到"Memory"选项卡，这里会列出具体的内存分配详情，包括哪些函数分配了多少内存，以及分配的是哪种类型的内存（如JavaScript对象、字符串、数组等）。这有助于进一步追踪到问题代码。
6.分析保留树：在堆快照的比较中，重点关注那些在新快照中出现而旧快照中没有的对象，特别是那些大的DOM节点或事件监听器，它们常常是内存泄漏的源头。
7.审查代码：根据分析结果，回溯到对应的代码位置，检查为什么这些对象没有被正确地垃圾回收，是否仍有引用指向它们。
内存泄漏日常问题
•移除不必要的引用：确保不再使用的对象和DOM元素被适当地解除引用。
•清理事件监听器：移除不再需要的事件监听器，特别是绑定在全局或长期存在的对象上的监听器。
•组件生命周期管理：在组件的生命周期方法中（如React的componentWillUnmount），清理资源和取消网络请求。
•单例模式的应用：尽可能复用同一个全局对象

87. 如何检测 Node 内存泄漏？出现内存不足怎么办？
为了演示如何使用 Node.js 的内置调试工具配合 Chrome DevTools 检测内存泄漏，我将提供一个简化的步骤指南和代码示例。这个例子将展示如何启动一个简单的 Node.js 应用并使用 DevTools 进行基本的内存分析。
步骤 1: 准备 Node.js 应用
首先，创建一个简单的 Node.js 文件，我们这里叫它 memory-leak-example.js，这个示例将模拟一个简单的内存泄漏场景：
JavaScript
function createLeak() {
    const arr = new Array(1000000).fill('Some data');
    // 这里没有释放arr，每次调用都会增加内存占用
}

setInterval(createLeak, 1000); // 每秒创建一次内存泄漏
这段代码每秒创建一个包含一百万个字符串的大数组，但没有进行适当的清理，可能会导致内存泄漏。
步骤 2: 启动应用并连接 DevTools
打开终端，使用 --inspect 或 --inspect-brk 参数启动你的应用。--inspect-brk 会在应用程序的第一行代码处暂停执行，这对于捕捉初始状态很有用。
Bash
node --inspect-brk memory-leak-example.js
运行命令后，你会看到类似以下输出，指示了调试器的 WebSocket URL：
Plain Text
Debugger listening on ws://127.0.0.1:9229/...
步骤 3: 使用 Chrome DevTools
1.打开 Chrome 浏览器，输入 chrome://inspect 并回车。
2.在 "Remote Target" 部分，你应该能看到你的 Node.js 应用。点击 "Inspect" 链接来打开 DevTools。
3.转到 "Memory" 面板。
4.点击 "Take heap snapshot" 按钮来记录当前的内存状态。你可以给快照命名，便于后续比较。
5.让应用运行一段时间（比如几分钟），让内存泄漏有机会累积。
6.再次拍摄一个堆快照。
7.在快照对比界面，DevTools 会高亮显示内存增长的对象，这有助于你定位潜在的内存泄漏源。
步骤4：使用内存分析工具
•应用诸如 memwatch-next 这样的第三方库，它可以监测 V8 内存分配，提供内存泄漏的实时警告。
•heapdump 库可以生成堆转储文件，方便离线分析内存使用情况。
•在关键位置添加日志记录内存使用情况，比如使用 process.memoryUsage() 获取内存使用统计信息。
•使用 APM（Application Performance Monitoring）工具，如 New Relic、Datadog 或 PM2，这些工具能提供更全面的应用性能监控，包括内存使用情况。

通过对比两个快照，查找那些“Delta”（变化量）显著增加的对象，这些通常是内存泄漏的线索。点击这些对象可以查看其引用树，帮助理解为什么它们没有被垃圾回收。
•记得在实际应用中识别并修复导致内存泄漏的代码。
•内存分析是一个迭代过程，可能需要多次尝试和修正。

88. Node 如何进行CPU密集型计算？qps过高怎么解决？cpu利用率过高如何处理？当qps达到峰值时，该如何处理？
•业务方案
￮BFF层 + RPC框架：Node.js 本身不适合处理CPU密集型计算，所以实际业务中 用 Node.js 搭建 BFF层，复杂计算交给其他服务完成。
￮负载均衡: 使用反向代理（如Nginx）或云服务的负载均衡器，将请求分发到多个Node.js实例，分散请求压力。
￮升级服务器硬件: 增加机器数量，升级机器的CPU内存或个数。
•中台已做的事情
￮系统性能监控：设置CPU利用率和QPS的阈值预警，及时发现问题并采取应对措施。
￮拒绝服务策略：当QPS达到峰值时，首先确保系统的稳定性，可能需要暂时拒绝一部分请求（通过HTTP状态码如503响应），以防止服务完全瘫痪。
￮请求限流策略：比如令牌桶或漏桶算法，以及服务降级策略，在系统接近饱和时优先保证核心功能的可用性。
￮自动扩容策略：达到设定阈值后会自动扩充机器，横向扩展，提升整体处理能力。
•Node.js 多进程
￮Child Processes: 在Node.js中，可以使用child_process模块来创建子进程，将CPU密集型任务分配给这些子进程处理。这样，主进程可以继续处理I/O任务，而不会被CPU密集型任务阻塞。
￮Cluster模块: 利用Node.js的cluster模块，可以在多核CPU上创建多个进程（工作进程），实现负载均衡。每个工作进程可以处理请求，包括CPU密集型任务，从而有效利用多核CPU资源。
•缓存策略
￮数据库缓存：对频繁访问且不经常变更的数据使用缓存，比如Redis，减少数据库查询和计算需求。
￮CDN加速：缓存静态资源，可以提高资源加载速度，减少服务器的负载。
￮浏览器缓存：强制缓存和协商缓存的应用，减轻服务器压力。
•代码层次
￮通过优化数据库查询sql语句，使用索引，分库分表等方式，提升数据库读写性能。
￮避免循环嵌套，减少不必要的递归调用。

89. 扫码登录的实现原理
原理概述
1.生成二维码: 用户在Web端请求登录时，服务器（通常使用Node.js）生成一个包含唯一标识（如UUID）的二维码，并将其状态存储在数据库或内存中。
2.展示二维码: Web前端接收并展示这个二维码给用户，同时开始轮询（或使用WebSocket）查询该二维码的状态变化。
3.手机扫码: 用户使用手机App扫描此二维码，App读取到二维码中的唯一标识（UUID）。
4.验证与授权: App通过内部认证机制确认用户身份后，携带UUID及用户身份信息向App服务器发起请求。
5.信息同步: App服务器收到请求后，与Web服务器通信，告知该UUID对应的登录请求已验证，并传递必要的用户凭证（如Token）。
6.完成登录: Web服务器收到App服务器的通知后，更新二维码状态为已验证，并通过轮询反馈给前端。前端接收到登录成功的通知后，可以使用返回的凭证自动登录用户。
技术方案
•前端技术栈:
￮Vue.js/Angular/React: 用于构建用户交互界面，展示二维码并处理轮询或WebSocket连接以监听登录状态。
￮axios/fetch: 用于前端向后端发送HTTP请求，获取二维码信息和检查登录状态。
•Node.js后端:
￮Express/Koa: 作为后端服务器框架，处理路由、生成二维码、存储和验证UUID等。
￮Redis/MongoDB: 用于存储UUID及其关联状态和用户凭证，Redis可提高响应速度，适合短暂存储。
￮JWT: JSON Web Tokens可以用来安全地传输用户凭证，实现无状态认证。
￮qrcode: 生成二维码图片的库，如qr-image或qrcode-svg，用于服务器端生成二维码数据。
•交互协议:
￮RESTful API: 用于前后端以及服务器间的数据交换。
￮WebSocket: 实现实时双向通信，可替代轮询，提高效率。
•安全性考虑:
￮签名与验签: 请求头携带签名和时间戳防止重放攻击。
￮HTTPS: 确保所有通信的安全，保护用户数据不被窃听或篡改。
￮限时有效性: 二维码具有有效期，过期后失效，增加安全性。
综上，通过前端与Node.js后端的配合，结合适当的数据库和通信协议，可以实现一个安全高效的扫码登录系统。
90. vue3 或者 react 中 动态组件引入机制，如何优化的？
Vue3 和 React 都有各自的方法来实现动态组件引入，这些机制有助于提升应用性能和用户体验。下面是它们各自的实现原理及优化策略。
Vue3 动态组件引入机制
Vue3 中动态组件主要通过 <component :is="componentName"></component> 实现，其中 componentName 可以是一个计算属性，根据条件改变来切换不同的组件。Vue3 引入了新的 Composition API，这使得动态组件的管理更加灵活。

实现原理：
1.懒加载（Lazy Loading）: Vue 支持使用动态导入（import() 表达式）来实现组件的懒加载。这意味着组件代码只在真正需要时才被加载，减少了初始加载时间。
2.Suspense: Vue3 引入了 <Suspense> 组件，可以用来包裹可能需要异步加载的组件，提供占位符或加载状态，保证用户体验。

优化：
•懒加载减少了应用程序的初始捆绑包大小，提高了首次加载速度。
•使用 Suspense 管理加载状态和错误边界，提升了用户体验。
•Vue 的响应式系统确保只有当依赖的数据变化时，相关的组件才会重新渲染，提高了运行时性能。
React 动态组件引入机制
React 中动态组件可以通过条件渲染或者使用 React.lazy 和 Suspense 来实现。
实现原理
1.React.lazy: 这是React用于代码分割和懒加载的主要方法。通过将组件导入包装在一个动态导入函数中（React.lazy(() => import('./MyComponent'))），React 只有在渲染该组件时才会加载其模块。
2.Suspense: 类似于Vue，React的Suspense组件也可以用来处理异步加载时的UI显示，比如显示加载指示器或错误提示。
优化
•代码分割（Code Splitting）: React.lazy 实现了按需加载，将代码分割成更小的 chunks，这不仅加速了首屏加载时间，还提高了后续交互的加载速度。
•资源预加载与预取（Preloading/Prefetching）: 开发者可以利用浏览器API或第三方库预先加载或预取即将使用的组件资源，进一步减少加载延迟。
•并发模式（Concurrent Mode）: 虽然不直接关联于动态组件引入，但并发模式改进了React对多个任务的处理能力，如Suspense的集成，使得组件加载和渲染过程更为高效和可控。
总结
总结来说，Vue3 和 React 的动态组件引入机制都通过懒加载、代码分割等技术优化了应用性能，减少了页面加载时间，提升了用户体验。同时，通过Suspense组件来管理加载状态，保证了用户在等待异步数据或组件加载时的界面反馈。
91. 说说 SSG 和 SSR ?
SSG (Static Site Generation, 静态站点生成) 和 SSR (Server-Side Rendering, 服务器端渲染) 是现代Web开发中两种不同的渲染技术，主要用于提高Web应用的性能、SEO友好性和用户体验。
SSG (静态站点生成)
SSG 是一种构建流程，在构建时（即部署前），应用的所有页面都会被预先渲染为静态HTML文件。这意味着每个页面的内容在用户请求之前就已经确定并生成完毕，包括路由对应的页面。这些静态文件随后会被部署到CDN（内容分发网络）上，用户访问时直接加载这些静态文件，无需服务器再次动态生成。

特点
- 性能高：因为内容是静态的，加载速度快，首屏渲染时间短。
- SEO友好：搜索引擎爬虫能直接抓取完整的HTML内容，有利于SEO。
- 易于部署：静态文件可以直接部署在任何静态文件托管服务上，如GitHub Pages、Netlify等。
- 开发简单：相比SSR，开发过程更接近SPA（单页应用）的体验。
- 数据更新问题：如果数据频繁变动，需要重新构建部署才能看到最新内容。

SSR (服务器端渲染)
概念：
SSR 是指在服务器端完成组件的渲染工作，服务器接收到HTTP请求后，会执行JavaScript代码，渲染出完整的HTML字符串再发送给浏览器。浏览器接收到的是一个已经包含数据的完整页面，之后客户端的JavaScript会接管，转换为交互式页面。

特点：
- 更好的SEO：与SSG相似，由于服务器返回完整的HTML页面，搜索引擎更容易抓取和索引。
- 数据实时性：页面内容在每次请求时根据最新的数据动态生成，适合内容频繁更新的场景。
- 初始化加载慢：相比于SSG，首次请求需要等待服务器渲染，可能影响用户体验。
- 服务器负载高：每一个用户请求都需要服务器进行渲染，可能会增加服务器资源消耗。
- 复杂度增加：相比纯前端渲染，需要处理服务器端的状态管理、错误处理等问题。

选择SSG还是SSR取决于项目需求：
- 如果你的网站内容相对静态，不需要经常更新，且对SEO有较高要求，SSG可能是更好的选择。
- 对于需要根据用户或实时数据动态生成内容，且能接受更高服务器成本的项目，SSR更合适。
- 还有一种混合方式，即ISG（Incremental Static Regeneration，增量静态生成），结合了SSG和SSR的优点，允许静态页面在部署后根据需要动态更新部分内容，提供了一种折中的解决方案。
92. Js 超过 number最大值如何处理？
•涉及复杂数据，交给后端处理，前端不适合进行大数计算
•如果是 Node 的话， 利用 RPC 框架 让其他服务处理。
•如果一定要在JS 中处理，可以用 ES 2020新出的 bigInt ，数值后面 +n 就是该类型，考虑兼容性问题。
•采用 专门用于数学计算的第三方 js库。
93. 前端如何实现截图功能？
理论
前端实现截图功能主要依靠HTML5的Canvas以及相关的JavaScript API，步骤概要及代码解析如下：
a.创建Canvas元素：
▪在HTML文件中添加<canvas>标签，为其设定ID以便于JavaScript中获取，并可通过CSS设置其样式和位置。例如，将其设置为固定定位并覆盖整个视窗。
b.设置Canvas尺寸：
▪通过JavaScript获取Canvas元素，并设置其宽度和高度与窗口（window.innerWidth和window.innerHeight）相匹配，确保Canvas能够容纳下整个可视区域的内容。
c.绘制内容到Canvas：
▪利用canvas.getContext('2d')获取2D渲染上下文，这是在Canvas上绘图的基础。
▪使用drawImage()方法将需要截图的内容绘制到Canvas上。在这个例子中，document.documentElement代表了整个HTML文档，即绘制整个页面到Canvas。坐标(0, 0)表示从Canvas的左上角开始绘制。
d.转换为Base64图片数据：
▪当用户点击按钮触发截图操作时，调用canvas.toDataURL()方法。这会将Canvas上的内容转换为一个data URL，该URL包含了图片的base64编码形式，可以直接用于显示或传输。
e.处理Base64数据：
▪生成的Base64字符串可以进一步处理，如在本例中只是简单地通过console.log()打印到控制台。实际上，你可以将此数据赋值给一个img元素的src属性来显示图片，或者通过Ajax发送到服务器进行存储。

方案
下面是一个实际的HTML和JavaScript代码示例，演示如何在前端实现截图功能。
这段代码将在用户点击按钮时对当前页面进行截图，并将截图显示在一个图片元素中。
HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>前端截图示例</title>
    <style>
        canvas {
            display: none;
        }
    </style>
</head>
<body>

<h1>前端截图示例</h1>
<p>点击按钮进行截图:</p>
<button id="screenshotBtn">截图</button>
<img id="screenshotImg" src="" alt="Screenshot">

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const screenshotBtn = document.getElementById('screenshotBtn');
        const screenshotImg = document.getElementById('screenshotImg');
        const canvas = document.createElement('canvas');

        screenshotBtn.addEventListener('click', function() {
            // 设置canvas尺寸与当前视口相同
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // 获取2D渲染上下文并在canvas上绘制整个页面
            const ctx = canvas.getContext('2d');
            ctx.drawWindow(window, 0, 0, canvas.width, canvas.height, "rgb(255,255,255)");

            // 将canvas内容转换为data URL
            const imgData = canvas.toDataURL('image/png');

            // 将截图显示在img元素中
            screenshotImg.src = imgData;
        });
    });
</script>

</body>
</html>
注意：上述代码中的ctx.drawWindow(window, 0, 0, canvas.width, canvas.height, "rgb(255,255,255)"); 这一行是假设存在的一个方法，实际上在标准的Canvas API中并不存在这样的方法来直接绘制整个窗口的内容。在现代浏览器中，正确的做法应该是使用ctx.drawImage()方法配合html2canvas库或其他类似技术来捕捉页面内容，因为直接使用drawWindow在大多数环境中是不被支持的。
因此，为了实现真正的前端截图功能，推荐使用html2canvas库，它能够将DOM转换成Canvas，进而生成图片。
HTML
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.3/html2canvas.min.js"></scrip

JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const screenshotBtn = document.getElementById('screenshotBtn');
    const screenshotImg = document.getElementById('screenshotImg');

    screenshotBtn.addEventListener('click', function() {
        html2canvas(document.body).then(function(canvas) {
            // 将canvas内容转换为data URL
            const imgData = canvas.toDataURL('image/png');

            // 将截图显示在img元素中
            screenshotImg.src = imgData;
        });
    });
});
这段代码会在用户点击“截图”按钮后，利用html2canvas将页面内容转换为Canvas，再转换为图片URL，并最终显示在页面上的一个<img>元素里。
94. 前端白屏除了骨架屏还能怎么优化？白屏情况如何及时发现？常见的白屏检测上报方案？
白屏问题优化措施
前端白屏问题通常是由于页面加载过程中资源加载延迟、脚本执行阻塞渲染、网络问题等原因导致的。
针对白屏的优化和及时发现，可以采取以下策略：
1.资源懒加载：对于非首屏需要的图片、视频等大资源，采用懒加载技术，即在用户滚动到可视区域时再进行加载。
2.代码拆分与异步加载：通过webpack等工具对代码进行拆分，实现按需加载。关键JavaScript和CSS应该内联或者优先加载，避免阻塞渲染。
3.使用Preload和Prefetch：<link rel="preload"> 可以提前加载关键资源，而 <link rel="prefetch"> 则用于预加载可能在未来用到的资源，两者都可以减少资源加载时间。
4.优化Critical CSS：确保首屏内容所需的CSS尽快加载并应用，可以通过提取首屏CSS为内联样式来实现。
5.减少JavaScript执行时间：避免在页面初始化时执行耗时的JavaScript操作，可以考虑使用Web Worker进行后台计算。
6.使用Service Worker缓存：通过Service Worker可以缓存静态资源，提高加载速度，减少白屏时间。

及时发现白屏情况
1.日志监控：在代码中关键位置（如页面加载完成、资源加载失败等）添加日志记录，并通过日志系统收集分析。
2.性能监控工具：利用Google Lighthouse、PageSpeed Insights等工具定期检测页面性能，包括白屏时间。
3.真实用户监控(RUM)：通过像Google Analytics、百度统计或自建系统收集用户访问时的性能数据，如First Contentful Paint (FCP)、 Largest Contentful Paint (LCP)等指标，及时发现异常。
4.自动化测试：利用自动化测试工具（如Puppeteer、Selenium）模拟用户访问，定期检查页面加载表现。
常见的白屏检测上报方案
1.Error Reporting Services：集成第三方错误报告服务，如Sentry、LogRocket，它们能自动捕获并报告JavaScript错误，包括可能导致白屏的错误。
2.自定义事件监听：在页面加载的关键生命周期钩子（如DOMContentLoaded、load事件）中添加逻辑，如果预期的渲染时间点后仍无内容显示，则触发一个上报事件给后端或日志系统。
3.Performance API利用：利用浏览器的Performance API（特别是Paint Timing API）来监测首次绘制时间（FCP）、最大内容绘制时间（LCP）等关键性能指标。当这些指标超出阈值时，发送一个上报请求。
4.前端监控SDK：集成如OneAPM、Fundebug等前端监控SDK，它们通常提供了开箱即用的白屏检测及上报功能，简化了开发者的集成工作。
通过上述方法的综合运用，不仅可以有效优化前端页面以减少白屏现象，还可以及时发现并定位问题，持续提升用户体验。
95. mobx redux vuex应用和技术细节
MobX 是一个用于管理应用状态的库，通常与 React 结合使用。
它基于响应式编程的思想，提供了简洁、强大的方式来管理状态变化。
MobX 的核心思想是：任何可观察的状态变化都会自动更新依赖该状态的组件。
mobx用法
Observable State（可观察状态）：
•核心概念是将状态声明为可观察的，这样当状态变化时，所有依赖该状态的计算值和反应都会自动更新。
Computed Values（计算值）：
•基于现有状态的派生值，自动计算并缓存结果，只在依赖的可观察状态变化时重新计算。
Reactions（反应）：
•自动响应状态变化的函数，例如 autorun 和 reaction。autorun 会在其依赖的任何可观察状态变化时自动运行，而 reaction 更灵活，可以精细控制何时重新运行。
Actions（动作）：
•用于修改状态的函数，通过明确的动作来修改状态，确保状态变化的可追踪性和调试性。
•
inject：将 相应的 store 注入到 props，可解构取出
observer：用observer包裹需要观察的组件，mobx的state变化自动渲染组件。
MobXProviderContext：用 useContext 引入 store。

JavaScript
import { observable, computed, action, reaction } from 'mobx';

export class SystemModel {
    @observable
    currentSystemId: number = +defaultAppId || null;// 当前系统信息

    @action
    setCurrentSystemId(id:number) {
        this.currentSystemId = id || null;
    }

    @action
    async setSystemList() {
        this.setCurrentSystemId(+this.systemList[0]?.id);
    }

    @computed
    get authKeysList() { // 权限key集合
        return getAuthKeys(this.authActionList);
    }

}
const systemModel = new SystemModel();

// 监测系统ID，一旦改变，需重新获取并设置授权数据
reaction(() => systemModel.currentSystemId, (systemId) => {
    if (systemId) {
        // 更新权限列表
        systemModel.setAuthActionList(systemId);
        const value = systemId;

        // 更新地址栏
        const { href, search, hash } = window.location;
        const url = href.split('#')[0];
        let newUrl = '';

        if (!url.includes(`${APP_KEY}=`)) { // 地址栏无系统参数，新增
            newUrl = `${url.split('?')[0]}${search ? `${search}${search.endsWith('&') ? '' : '&'}` : '?'}${APP_KEY}=${value}${hash}`;
        } else { // 有系统参数，替换
            newUrl = href.replace(new RegExp(`(${APP_KEY}=)[^&#]*(.*)`), `$1${value}$2`);
        }

        window.history.replaceState({}, '', newUrl);
    }
}, { fireImmediately: true });

export default systemModel;

手写状态组件库
创建一个初始状态和 reducer 函数
JavaScript

const initialState = {
  todos: [],
  completedTodosCount: 0,
};
function reducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      const newTodos = [...state.todos, action.payload];
      return {
        ...state,
        todos: newTodos,
        completedTodosCount: newTodos.filter(todo => todo.completed).length,
      };
    case 'TOGGLE_TODO':
      const updatedTodos = state.todos.map((todo, index) =>
        index === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
      return {
        ...state,
        todos: updatedTodos,
        completedTodosCount: updatedTodos.filter(todo => todo.completed).length,
      };
    default:
      throw new Error('Unknown action type');
  }
}

创建一个 Context 和 Provider 组件
JavaScript
const TodoContext = createContext();
export function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <TodoContext.Provider value={{ state, dispatch }}>
      {children}
    </TodoContext.Provider>
  );
}
export function useTodos() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error('useTodos must be used within a TodoProvider');
  }
  return context;
}

子组件【使用store里的数据，用dispatch更新数据】 + 父组件【用自定义Provider包裹子组件】
JavaScript
import React from 'react';
import { TodoProvider, useTodos } from './TodoContext';

const TodoList = () => {
  const { state, dispatch } = useTodos();
  const { todos, completedTodosCount } = state;
  const addTodo = (text) => {
    dispatch({ type: 'ADD_TODO', payload: { text, completed: false } });
  };
  const toggleTodo = (index) => {
    dispatch({ type: 'TOGGLE_TODO', payload: index });
  };
  return (
    <div>
      <ul>
        {todos.map((todo, index) => (
          <li key={index} onClick={() => toggleTodo(index)}>
            {todo.text} {todo.completed ? '(Completed)' : ''}
          </li>
        ))}
      </ul>
      <button onClick={() => addTodo('New Todo')}>Add Todo</button>
      <div>Completed Todos: {completedTodosCount}</div>
    </div>
  );
};


JavaScript
export default function App() {
  return (
    <TodoProvider>
      <TodoList />
    </TodoProvider>
  );
}
96. 如何解决页面请求接口大规模并发问题？
•除了考虑前端资源的请求并发，还要考虑接口的并发。
•前端代码：实现一个异步请求并发控制器，限制同时请求的个数。
•尤其是对静态资源的打包：webpack 合理拆分页面组件 + 代码懒加载，雪碧图、base64。
•采用服务端渲染，将页面首屏渲染后再返回，尤其是需要的css文件可以一并注入到html。
•使用各种缓存，CDN缓存技术、浏览器缓存、redis缓存、离线状态下缓存，甚至service worker缓存也能考虑。
•BFF 作为聚合层 也是一个常见的操作。
•前端采用微前端方式，拆分项目，每次只加载部分页面的资源。
•升级 http2，使用多路复用特性。

97. cr机器人的实现流程
首先，我们的CR机器人是一套消息机制的，会在项目提出MR到master分支或者develop分支时，发送消息到CR群里，提醒相应人去评审代码。
后来发现，有的项目其实没那么重要，或者代码改动太大，cr的人精力不足，所以引入算法那边的GPT4接口去cr改动的文件内容。
主要讨论点就是改动的地方太多，代码量太多。
有时cr需要全量扫描整个文件更合适，分开cr的话又怕代码逻辑串联不到一起。
输入输出字数限制，较长代码段的拆分，怎么写提示词和该如何录入知识库文档。
98. SSO 单点登录的实现原理。
用户通过一个认证系统登录后，获得一个认证令牌（如JWT或Session ID），
然后每次访问其他关联系统时，这些系统会通过验证该令牌的合法性来进行用户认证，
实现用户只需登录一次即可访问多个系统的目的。
1.统一认证系统：
￮选择并实现一个中央认证服务器（如OAuth2, OpenID Connect）。
￮确保认证系统可以安全、可靠地处理用户认证请求。

2.认证令牌的生成与管理：
￮选择合适的令牌类型（如JWT, SAML）。
￮令牌生成、签发、管理和存储机制。
￮令牌的安全性（加密、签名、有效期等）。

3.用户身份验证：
￮用户登录时在认证服务器上进行身份验证。
￮验证成功后生成并返回认证令牌。

4.令牌的传递与验证：
￮在用户访问其他系统时，通过请求头或Cookie等方式传递认证令牌。
￮关联系统接收到令牌后，验证其合法性（如验证签名、检查有效期等）。

5.系统间信任关系：
￮建立认证服务器与各关联系统之间的信任关系，确保令牌在多个系统间的可信度。
￮使用共享密钥或公钥基础设施（PKI）来验证令牌签名。

6.单点登出（SSO Logout）：
￮实现统一的登出机制，确保用户在一个系统登出后，所有关联系统同步登出。
￮通知所有相关系统销毁会话和令牌。

7.安全性：
￮保护令牌传输安全（使用HTTPS）。
￮防止令牌泄漏和重放攻击。
￮定期审查和更新安全策略。

8.用户体验：
￮提供无缝的登录和使用体验。
￮保证系统间跳转的快速和稳定。

99. 怎么保存单个表单组件的状态，使得用户在路由回退时不用重新填写表单？
•如果表单数据不敏感且希望跨会话保留，可以考虑使用localStorage或短时间内保留使用sessionStorage。
•当用户填写表单时，可以监听表单的输入事件，将表单数据保存到浏览器的历史状态中。这样，在用户点击后退按钮时，可以从历史记录中恢复表单数据。
•还可以放在 状态管理包的 store 里
JavaScript
// 导航离开时
this.props.history.push({
    pathname: '/nextpage',
    state: { formState: this.state.formValues },
});
// 返回时恢复
componentDidMount() {
    if (this.props.location.state && this.props.location.state.formState) {
        this.setState({ formValues: this.props.location.state.formState });
    }
}
100. 写一个 React 组件，展示当前浏览器屏幕宽度、高度、滚动条滚动的距离？
JavaScript
import React, { useState, useEffect } from 'react';
const ScreenInfo = () => {
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  const [windowHeight, setWindowHeight] = useState(window.innerHeight);
  const [scrollTop, setScrollTop] = useState(window.scrollY);
  const handleResize = () => {
    setWindowWidth(window.innerWidth);
    setWindowHeight(window.innerHeight);
  };

  const handleScroll = () => {
    setScrollTop(window.scrollY);
  };

  useEffect(() => {
    window.addEventListener('resize', handleResize);
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);

  return (
    <div>
      <h1>Screen Information</h1>
      <p>Width: {windowWidth}px</p>
      <p>Height: {windowHeight}px</p>
      <p>Scroll Top: {scrollTop}px</p>
    </div>
  );
};
export default ScreenInfo;
101. 同一个链接，如何实现pc打开是web应用、手机打开是一个h5应用？
这个判断逻辑，不管都是在前端还是服务端，一般都是通过 useAgent 来判断请求来源。
JavaScript
服务端：req.headers['user-agent']
浏览器端：window.navigator.userAgent
这种通用判断逻辑，一般我们都是放在一个工具包里去维护。
只要写h5的链接，在 App和小程序里对应的跳转链接都会自动生成。
102. 如何保证或者提升用户的使用体验？
•性能方面的优化
￮首屏渲染速度，页面可交互时间，LCP等浏览器性能指标。
￮提升接口返回速度，优化业务逻辑的时间和空间复杂度。
￮cdn缓存、浏览器缓存、redis缓存等。
•线上问题反馈与告警
￮确保出现 白屏时间过长、接口速度缓慢、系统崩溃等问题时，第一时间告警。
￮上报并统计 JS执行错误、接口500等异常，统计影响的页面数和用户数。
•提升用户体验
￮注重用户的交互体验，通过大量的对照组实验不断优化页面交互，看看哪版UI，提升下单率、转化率最多。
￮提供用户分流、人群圈选、灰度上线等功能，便于做产品实验，出现线上问题时降低影响。
￮确保服务的稳定性，比如出现请求qps过高的情况，会自动扩容，加机器，自动采取流量控制。
103. 动态组件库的设计与实现，包括 app 、小程序、web | 通用组件库的设计与实现 通用 UI迭代 api设计。
动态组件库设计的考虑点
适配与复用
•组件库的每个组件 在不同的环境下都能直接使用，无需组件库的使用者写相关的适配代码。
•保证功能的一致性，API 的设计也应该尽可能统一。
•组件库的代码应该与当前使用环境无关，便于复用代码。
样式隔离与覆盖
•样式隔离：使用 CSS-in-JS（如 Styled Components）或 CSS Modules，以避免样式冲突。
•支持样式覆盖：让用户能自己改组件样式，比如覆盖主题色的变量值，就能改变整个组件库的主题风格。
•动态加载组件的css，避免引入大量css文件。
性能角度
•代码懒加载：无论是css还是js，都只加载当前页面需要的，尤其是在特定环境下的相关代码。
•性能优化：虚拟列表、减少重复渲染，尤其要注意多个组件同时并发加载时的性能问题，要避免页面的回流。
细节问题
•注意兼容性问题，尤其是 一些 CSS属性 在不同端的表现不一样，或者app不支持。
•提供使用文档、代码示例、相关demo组件可以在文档页面展示出来。
•合理引入taro这种跨平台框架，支持多端开发，而不是每个端开发一套代码。
104. 设计一套全站请求耗时统计工具？
基础实现
•针对网络请求，可以利用xhr的load事件，或者自己封装请求函数，记录并上报每次请求的耗时时间。
•对于每个资源的加载时间、LCP、FCP、TTFB等指标，可以通过Performance API 来实现。
•针对TTI 首次可交互时间 这种计算相对复杂的，市面上已有成熟的第三方性能监控库（如WebPageTest、Lighthouse、SpeedCurve等）提供了封装好的TTI计算和上报功能。
考虑细节
•将上述计算耗时的逻辑封装成性能监控指标模块，在应用入口引入模块，可以能通过cdn链接引入。
•需要提供一个启动开关。
•做好问题兜底和异常处理，绝对不能影响线上功能。
•考虑到环境的区分，pc、app、小程序，开发与线上，项目间的区分，项目的版本 等。
•各种指标的计算频率应该有个控制入口或者配置表。
•每次上报的耗时情况，除了有相应的日志系统，还需要落库，便于进一步统计与分析。

105. 前端数据、接口设计，如何解耦，怎么扩展设计
•引入中间层 或者 前端封装通用的数据处理逻辑。
•将数据模型（如对象、类）与数据获取和处理的服务层分离。数据模型定义数据结构和行为，服务层负责数据的获取、处理和存储。
•有了BFF层，可以灵活地扩展和修改应用的行为，后端代码演进可以设计更合理，减少兼容性顾虑。
•单一职责原则：服务专注于单一功能，避免功能耦合和过度复杂化。
•可以通过适配器模式或依赖注入等技术，灵活地切换不同的数据源或接口实现。
•良好的版本控制：对接口和数据模型有版本控制，最好能在未来调整时不影响之前数据。

106. 小程序分包加载的实现原理和优势?
小程序分包加载是一种优化手段，用于将小程序的代码划分为主包和分包，以便更有效地管理和加载代码，特别是对于较大的小程序项目。以下是其实现原理和优势：
实现原理
1.定义分包：
￮开发者可以在小程序的配置文件（如app.json）中定义分包。每个分包可以包含页面和资源文件，有自己的目录结构。
2.分包加载时机：
￮当小程序启动时，首先加载主包，包括主包的配置、页面和资源文件。
￮在需要时，根据用户操作或页面跳转需求，动态加载分包。例如，用户访问分包中的某个页面时，会自动下载和加载该分包的代码。
3.分包的独立性：
￮分包可以有独立的页面和资源，但仍然可以通过主包中的全局配置进行引用和调用。
4.网络请求优化：
￮小程序平台会根据网络条件和设备性能来决定分包的下载和加载策略，以保证用户体验和性能。
优势
1.减少主包体积：
￮将较大的代码和资源分担到分包中，可以显著减少主包的体积，加快小程序的启动速度和页面响应速度。
2.优化用户体验：
￮可以根据用户的实际需求和访问情况，动态加载分包，提升用户访问页面的响应速度和流畅度。
3.模块化管理：
￮通过分包的模块化管理，可以更清晰地组织和维护代码，降低代码的耦合性和复杂度。
4.灵活性和扩展性：
￮允许开发者根据项目需求将代码划分为多个分包，灵活管理和部署项目的各个模块，便于项目的后续扩展和维护。
5.平台优化支持：
￮小程序平台会针对分包加载进行优化，包括下载策略、资源缓存和管理，提升小程序的整体性能和稳定性。
注意事项
•分包加载虽然带来了很多优势，但在使用时也需要考虑合理划分和管理分包，避免过度划分或不必要的分包，导致管理和维护的复杂性增加。
•对于小程序启动速度和用户体验较为敏感的场景，合理使用分包加载可以明显改善用户的体验感知。
总之，小程序分包加载通过合理划分和动态加载代码，可以有效优化小程序的性能和用户体验，是大型小程序项目开发中的一项重要优化策略。

107. 持续交付、流水线的实现策略
持续交付（Continuous Delivery）和流水线（Pipeline）是非常重要的实践，能够显著提升软件开发的效率和质量。
1.自动化构建和测试：
￮代码管理和版本控制：使用版本控制系统（如Git），确保代码的可追溯性和协作性。
￮自动化构建：配置自动化构建系统（如Jenkins、GitLab CI/CD等），以触发代码的自动编译、打包和发布。
2.持续集成（Continuous Integration, CI）：
￮开发者提交代码后，触发自动化构建和单元测试。
￮集成测试：包括功能测试、性能测试、安全测试等，确保新功能和修改不会破坏现有系统。
3.持续交付（Continuous Delivery, CD）：
￮将通过集成测试的代码自动部署到预生产环境（Staging Environment）。
￮自动化部署：使用容器化技术（如Docker、Kubernetes）或虚拟化技术，确保环境一致性和可重复性。
4.流水线设计和管理：
￮流程定义：定义整个交付流程，包括从代码提交到生产环境部署的各个阶段和动作。
￮流水线工具：选择合适的CI/CD工具，并通过流水线定义DSL（Domain-Specific Language）或配置文件来描述流程。
5.环境管理和版本控制：
￮环境隔离：确保开发、测试、预生产和生产环境的隔离性，避免不同环境中的配置和数据混淆。
￮版本控制：使用配置管理工具（如Ansible、Chef、Puppet）来管理和自动化环境配置的变更。
6.监控和反馈机制：
￮实时监控：在每个部署阶段和生产环境中实施监控和日志记录，以便及时发现和解决问题。
￮反馈循环：建立团队内部和跨团队的反馈循环，从用户反馈、运维团队和测试团队的反馈中获取改进建议和问题报告。
7.安全和合规性考虑：
￮安全审计：确保流水线的各个阶段和工具链的安全性，包括代码审查、漏洞扫描和权限管理。
￮合规性：遵循公司和行业的安全标准和法规，如GDPR、HIPAA等。
108. 可编辑、动态表头的表格如何设计和实现？
•initialData 和 initialHeaders 分别初始化表格的数据和表头。
•使用 useState 钩子来管理表格数据和表头的状态。
•handleHeaderChange 函数处理表头的编辑，当用户在表头输入框中更改文本时调用，更新表头数组。
•handleCellChange 函数处理表格单元格的编辑，根据用户在单元格输入框中的输入更新表格数据。
•在渲染时，使用两层循环分别生成表头行和数据行，每个表头和单元格都是一个可编辑的<input>元素，通过事件监听器与状态更新函数绑定。
•对于复杂的数据操作和验证（如数据合法性校验、排序、过滤等），可能还需要引入额外的状态管理和逻辑处理。考虑到性能，如果表格数据量非常大，可以采用虚拟滚动等技术优化。
JavaScript
import React, { useState } from 'react';

const EditableTable = () => {
  // 初始化表格数据和表头状态
  const initialData = [
    { id: 1, name: '张三', age: 28 },
    { id: 2, name: '李四', age: 24 },
  ];
  const initialHeaders = ['id', 'name', 'age'];

  // 使用useState管理表格数据和表头
  const [headers, setHeaders] = useState(initialHeaders);
  const [data, setData] = useState(initialData);

  // 添加处理表头编辑的功能
  const handleHeaderChange = (index, value) => {
    // 更新表头状态
    const newHeaders = [...headers];
    newHeaders[index] = value;
    setHeaders(newHeaders);
  };

  // 添加处理单元格编辑的功能（这里简化处理，实际应用中可能需要更复杂的逻辑处理）
  const handleCellChange = (rowIndex, colIndex, value) => {
    // 更新表格数据状态
    const newData = [...data];
    newData[rowIndex][headers[colIndex]] = value;
    setData(newData);
  };

  return (
    <table>
      {/* 表头 */}
      <thead>
        <tr>
          {headers.map((header, index) => (
            <th key={index}>
              {/* 可编辑表头单元格 */}
              <input
                type="text"
                value={header}
                onChange={(e) => handleHeaderChange(index, e.target.value)}
              />
            </th>
          ))}
        </tr>
      </thead>
      {/* 表格内容 */}
      <tbody>
        {data.map((row, rowIndex) => (
          <tr key={row.id}>
            {headers.map((header, colIndex) => (
              <td key={colIndex}>
                {/* 可编辑单元格 */}
                <input
                  type="text"
                  value={row[header]}
                  onChange={(e) => handleCellChange(rowIndex, colIndex, e.target.value)}
                />
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default EditableTable;
109. 跨端页面的跳转方式的实现，包括 app、小程序间的相互调用。
使用Scheme协议
•定义: Scheme是一种URI（统一资源标识符）方案，允许在APP内部定义一种URL格式，用于从其他应用（如浏览器、另一个APP）启动该APP并执行特定操作。
•实现:
￮Android：在AndroidManifest.xml中为APP添加Intent Filter。
Plaintext
Xml
1<activity ...>
2    <intent-filter>
3        <action android:name="android.intent.action.VIEW" />
4        <category android:name="android.intent.category.DEFAULT" />
5        <category android:name="android.intent.category.BROWSABLE" />
6        <data android:scheme="yourapp" android:host="path" />
7    </intent-filter>
8</activity>

Plaintext
Xml
1<key>CFBundleURLTypes</key>
2<array>
3    <dict>
4        <key>CFBundleURLSchemes</key>
5        <array>
6            <stringyourapp</string>
7        </array>
8    </dict>
9</array>
•唤起方式（H5调用）:
Plaintext
Html
<a href="yourapp://path?param=value"打开APP</a>
Universal Links（iOS）与App Links（Android）
这两个技术允许用户点击链接时直接打开APP，如果APP未安装，则在浏览器中打开链接。
•Universal Links (iOS): 需要在你的服务器上放置一个apple-app-site-association文件，定义APP支持的链接。
•App Links (Android): 类似于Universal Links，但使用的是assetlinks.json文件，并且需要上传到你的网站的.well-known目录下。
小程序间的相互调用
小程序之间的跳转主要依赖于各平台提供的API，例如微信小程序的navigateToMiniProgram接口，可以实现从小程序跳转到另一个小程序。
JavaScript
jiazheng-aunt-sdk
window.wx.miniProgram.postMessage({
    data: {
        title: window.pageJson.shareTitle || '邀请好友得40元',
        desc: window.pageJson.shareKeyword || '保洁限时大促，解放双手乐享生活！',
        path: `${that.formatSharePageUrl(item)}&shareId=${that.wx}`,
        imgUrl: '', // 分享图标
    },
});
110. fps帧率如何检测？前端如何模拟fps判断页面是否卡顿？如何检测一秒内的事件循环？
FPS（Frames Per Second，每秒传输帧数）是衡量动画或视频流畅度的一个重要指标，尤其在游戏开发和Web性能优化中经常被提及。在前端领域，检测FPS、模拟FPS判断页面是否卡顿以及检测一秒内的事件循环，可以通过以下方法实现：
检测FPS-使用requestAnimationFrame
JavaScript
let lastTime = performance.now();
let frame = 0;
const fpsList = [];

function loop() {
  const now = performance.now();
  const delta = now - lastTime;
  frame++;

  if (delta >= 1000) { // 每隔1秒计算一次FPS
    const fps = Math.round((frame * 1000) / delta);
    fpsList.push(fps);
    console.log(`Current FPS: ${fps}`);
    frame = 0;
    lastTime = now;
  }

  requestAnimationFrame(loop);
}

loop();
这段代码利用requestAnimationFrame循环执行动画帧，并在每一秒结束时计算FPS，将其记录在数组fpsList中以供后续分析。
模拟FPS判断页面是否卡顿
基于上面的FPS检测，你可以设定一个阈值来判断页面是否卡顿，比如如果FPS低于30，可以认为是卡顿的。
JavaScript
function isPageLagging(currentFps) {
  const FPS_THRESHOLD = 30;
  return currentFps < FPS_THRESHOLD;
}

// 在计算FPS的地方使用
if (isPageLagging(fps)) {
  console.log('页面可能卡顿了！');
}
检测一秒内的事件循环
要检测JavaScript事件循环的繁忙程度，可以通过监听performance API中的eventLoopUtilization（如果有支持的话）。但请注意，这个API目前在大多数浏览器中还未得到广泛支持。
对于更通用的方法，可以通过定时器对比实际执行时间与预期时间的差距来间接判断事件循环的占用情况：
JavaScript
let startTime, endTime;

function checkEventLoopDelay() {
  startTime = performance.now();
  setTimeout(() => {
    endTime = performance.now();
    const delay = endTime - startTime;
    console.log(`事件循环延迟: ${delay}ms`);
    // 如果延迟过大，可能表示事件循环较忙
  }, 0);
}

setInterval(checkEventLoopDelay, 1000); // 每秒检查一次
这种方法通过设置一个零延时的定时器，并比较其实际执行时间与计划执行时间的差值，来评估事件循环的繁忙程度。
需要注意的是，这种方法只能提供一个大致的参考，因为事件循环的具体行为受到很多因素的影响，包括但不限于浏览器实现、当前页面的其他脚本执行等。
使用Date.now()结合for循环来判断是否达到一秒内的逻辑本身没有问题，但是这种方式通常用来做计时控制而不是直接检测事件循环或FPS。如果你想要在一秒钟后执行某些操作或判断循环是否持续了一秒，这种方法是可行的。
对于检测页面是否卡顿或者精确测量FPS，还是推荐使用requestAnimationFrame结合性能API（如上所述），这样的方法更加高效且对用户界面影响小。而事件循环的检测，虽然没有直接测量的简单方法，但可以通过上述提到的setTimeout技巧来间接评估。
111. 设计模式：策略模式、发布订阅、代理模式、装饰模式、异步单例 的适用场景和实现
策略模式
适用场景: 当你的组件需要根据不同的条件执行不同的业务逻辑时，可以使用策略模式来动态选择算法或行为。例如，根据用户类型展示不同内容，或是根据不同的支付方式进行处理。
实现方式:
•定义一个策略接口，声明所有支持的策略或行为需要实现的方法。
•实现多个策略类，每个类对应一种具体策略。
•创建上下文类（或在MobX Store中），用于持有一个策略对象，并提供一个方法来根据条件设置或切换策略。
•在React组件中，根据Store的状态调用相应的策略方法。
发布订阅模式
适用场景: MobX本身就是基于观察者模式（发布订阅的一种形式）实现的，非常适合状态管理。当一个组件需要监听Store中的状态变化时，可以利用MobX的自动追踪和通知机制。
实现方式:
•使用MobX的@observer装饰器标记需要响应数据变化的React组件。
•在MobX Store中定义@observable状态属性。
•组件内部通过@computed计算属性或直接访问这些状态属性，当Store中的状态改变时，相关组件会自动重新渲染。
代理模式
适用场景: 当需要为某个对象提供一个替代的接口，以控制对这个对象的访问时，可以使用代理模式。在React+MobX中，它可以用在优化性能或延迟加载等场景，比如图片懒加载。
实现方式:
•创建一个代理对象，该对象包含对真实对象（如图片组件）的引用。
•代理对象在必要时（如图片滚动到可视区域）才实例化并返回真实对象。
•在React组件中，直接使用代理对象，由代理决定何时加载实际组件。
装饰器模式
适用场景: 装饰器模式用于在不修改原有类的基础上，给类添加新的功能。在React中，可以通过高阶组件(HOC)来实现装饰器模式，为组件增加额外的功能，如权限验证、日志记录等。
实现方式:
•定义一个函数作为装饰器，该函数接收一个组件作为参数，并返回一个新的组件。
•新组件在原有的基础上添加或修改功能，然后渲染传入的组件。
•我们系统的权限按钮就是这样实现的，可以采用 ts的装饰器语法或者 react自身的HOC实现。
JavaScript
export default function WithAuthHOC<P = {}>(WrappedComp:ComponentType<P>, actionKey?:ActionKey, type:AuthType = 'btn'):ComponentType<P & WithAuthProps> {
    return observer((props) => {
        const { actionKey: propsActionKey, ...baseProps } = props;
        const key = actionKey || propsActionKey;// actionKey既可以在HOC调用时传，也可以给返回的新组件传
        const { systemModel } = useContext(MobXProviderContext);

        if (systemModel.isAuthStateLoading) { // 权限获取中
            return null;
        }

        const hasAuth = systemModel.authKeysList.includes(String(key));// 有权限

        if (!hasAuth) { // 无权限处理
            if (type === 'page') {
                return <Navigate to="/404" replace />;
            }

            if (type === 'btn') {
                return null;
            }
        }

        return <WrappedComp {...baseProps as P} />;
    });
}

/**
 * @description 自带权限控制的Button组件，很方便的用于按钮级的控制
 */
export const WithAuthButton = WithAuthHOC(Button);

异步单例模式
适用场景: 当你需要确保一个异步操作（如从服务器获取数据）在整个应用程序生命周期内只执行一次，并且结果被所有需要的地方共享时，可以使用异步单例模式。
实现方式:
•在MobX Store中创建一个异步动作(@action.bound)来处理数据获取逻辑。
•使用MobX的@computed属性来缓存结果，首次调用时触发异步获取，之后直接返回缓存的结果。
•在React组件中，直接读取这个@computed属性来获取数据，确保数据获取是单例且高效的。
112. 不同场景下的sdk实现
1.性能问题：确保SDK在执行效率、内存占用等方面表现良好，避免成为应用的性能瓶颈。对于耗时操作，考虑步处理机制。
2.兼容性问题：确保SDK能够在多种操作系统（如iOS、Android、Windows、Linux等）和开发环境（如Web、React Native、Flutter等）上运行，可能需要为不同的平台提供特定的实现或接口。
3.api的统一性：代码尽量保证对外api的统一
4.用户代理(User-Agent)判断与环境区分
￮不建议仅依赖User-Agent来判断环境，因为User-Agent可以被修改，且不同的浏览器和设备对User-Agent的格式没有统一标准。
￮考虑使用特性检测(feature detection)而非浏览器嗅探(browser sniffing)，来确定当前环境支持哪些功能，从而决定如何执行代码。
￮对于需要区分环境的情况（如开发、测试、生产环境），可以考虑通过配置项或环境变量来动态调整行为。
JavaScript
// 微信小程序环境
/* eslint no-underscore-dangle: 0 */
export const isMiniprogram = (navigator.userAgent.match(/micromessenger/i) && navigator.userAgent.match(/miniprogram/i)) || window.__wxjs_environment === 'miniprogram';

5.模块化与可配置性：设计时应采用模块化结构，允许用户按需加载所需功能，减少不必要的资源消耗。同时，提供丰富的配置选项，让开发者能够根据具体场景调整SDK的行为。
6.错误处理与日志记录：提供清晰、有用的错误信息，帮助开发者快速定位问题。同时，提供日志记录功能，允许用户控制日志级别，以便在不同环境下调整详细度。
113. 考察对 业界流行方案 框架 库的了解，比如 表单校验组件的功能设计和包的选择。
Formik vs React Hook Form
•在Formik和React Hook Form之间选择时，主要看项目需求和个人偏好。
•Formik提供了更全面的表单管理功能，适合复杂表单场景。
•React Hook Form则更侧重于性能和简洁性，特别适合现代React应用。
•如果表单逻辑简单且重视性能优化，React Hook Form可能是更好的选择；反之，若需要更强大的表单管理和复杂的验证逻辑，Formik+Yup的组合更为合适。
JavaScript
在这个示例中，我们使用了register函数来自React Hook Form来注册表单输入字段，并直接在Ant Design的Input组件上应用。ref属性用于将输入字段绑定到表单状态和验证逻辑上。错误信息则根据errors对象动态显示。handleSubmit函数用于处理表单提交事件，当用户点击提交按钮时触发。

import React from 'react';
import { useForm } from 'react-hook-form';
import { Button, Form, Input } from 'antd';

function App() {
  // 初始化React Hook Form
  const { register, handleSubmit, errors } = useForm();

  // 提交处理函数
  const onSubmit = (data) => {
    console.log('提交的数据:', data);
    // 在这里执行提交表单逻辑，例如发送到服务器
  };

  return (
    <div className="App">
      <Form layout="inline" onFinish={handleSubmit(onSubmit)}>
        {/* 姓名输入框 */}
        <Form.Item label="姓名">
          <Input
            name="name"
            placeholder="请输入姓名"
            ref={register({ required: true, minLength: 2 })}
          />
          {errors.name && <span style={{ color: 'red' }}>姓名是必填项，且至少2个字符</span>}
        </Form.Item>

        {/* 电子邮件输入框 */}
        <Form.Item label="电子邮件">
          <Input
            name="email"
            placeholder="请输入电子邮件"
            ref={register({
              required: true,
              pattern: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            })}
          />
          {errors.email && <span style={{ color: 'red' }}>请输入有效的电子邮件地址</span>}
        </Form.Item>

        {/* 提交按钮 */}
        <Form.Item>
          <Button type="primary" htmlType="submit">
            提交
          </Button>
        </Form.Item>
      </Form>
    </div>
  );
}

export default App;
3. 手写题
题目
1. 防抖节流hook
JavaScript
import { useState, useCallback, useEffect, useRef } from 'react';
export default function useDebounce(fn, delay = 1000, dep = []) {
    const { current } = useRef({ fn, timer: null });
    useEffect(function () {
        current.fn = fn;
    }, [fn]);

    useEffect(() => {
        return () => {
            clearTimeout(current.timer);
        } 
    }, [])
    
    return useCallback(function (...args) {
        if (current.timer) {
            clearTimeout(current.timer);
        }
        current.timer = setTimeout(() => {
            current.fn.call(this, ...args);
        }, delay);
    }, dep)
}


JavaScript
import { useState, useCallback, useEffect, useRef } from 'react';

export default function useThrottle(fn, delay = 1000, dep = []) {
    const { current } = useRef({ fn, timer: null });
    useEffect(function () {
        current.fn = fn;
    }, [fn]);

    useEffect(() => {
        return () => {
            clearTimeout(current.timer);
        }
    }, [])

    return useCallback(function f(...args) {
        if (!current.timer) {
            current.timer = setTimeout(() => {
                current.fn.call(this, ...args);
                delete current.timer;
            }, delay);
        }
    }, dep);
}

JavaScript
const debounce = (fn , wait = 1000) => {
    let timer = null;
    let flag = true;
    return function (...args) {
        if (flag) {
            clearTimeout(timer);
        }
        flag = true;
        timer = setTimeout(() => {
            fn.apply(this, args);
            flag = false;
        }, wait);
    };
};

const debounce2 = (fn , wait = 1000) => {
    let timer = null;
    return function (...args) {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            fn.apply(this, args);
            timer = null;
        }, wait);
    };
};

const throttle = (fn, wait = 1000) => {
    let timer = null
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args)
                timer = null
            }, wait)
        }
    }
}
const throttle2 = (fn, wait = 1000) => {
    let lastTime = 0;
    return function (...args) {
        let curTime = Date.now();
        if (curTime - lastTime >= wait) {
            lastTime = Date.now();
            return fn.apply(this, args);
        }
    }
}

2. 手写Instanceof
JavaScript
function instanceOf(father, child) {
  const fp = father.prototype;
  let cp = Object.getPrototypeOf(child);
  if (cp == null || fp == null) {
    return false;
  } else if (cp === fp) {
    return true;
  } else {
    return instanceOf(fp, cp);
  }
}
function myinstanceof(father, child) {
  const fp = father.prototype;
  var cp = Object.getPrototypeOf(child);
  while (cp) {
    if (cp === fp) {
      return true;
    }
    cp = Object.getPrototypeOf(cp);
  }
  return false;
}
class Father {
  constructor(name) {
    this.name = name;
  }
}
let p = new Father("hhh");
console.log(instanceOf(Father, p));

3. 数据类型判断
JavaScript
1. Array.isArray
2. typeof 
3 [] instanceof Array
4. Object.prototype.toString.call([]) // 返回 "[object Array]" // .slice(8,-1) 注意所有类型都能用，不过是大写开头String
6. [].constructor.name // 返回 "Array"
7. function isArray(variable) {
  return variable.constructor === Array;
}

4. 引用类型数据的比较
JavaScript
function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
        return true;
    }

    if (typeof obj1 !== "object" || obj1 === null ||
        typeof obj2 !== "object" || obj2 === null) {
        return false;
    }

    let keys1 = Object.keys(obj1);
    let keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) {
        return false;
    }

    for (let key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }

    return true;
}

5. 图片限制加载数量
JavaScript
function downloadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      setTimeout(() => {
        resolve(url)
      }, 2000);
    };
    img.onerror = () => reject(url);
    img.src = url;
  });
}
function downloadImagesConcurrently(imageUrls, maxConcurrent) {
  const downloadQueue = [...imageUrls];
  const results = [];
  function startDownload() {
    if (downloadQueue.length === 0) {
      return Promise.resolve();
    }
    const currentBatch = downloadQueue.splice(0, maxConcurrent);
    const batchPromises = currentBatch.map((url) => {
      return downloadImage(url).then(() => {
        console.log('url', url);
        results.push(url);
      });
    });
    return Promise.all(batchPromises).then(startDownload);
  }
  return startDownload().then(() => results);
}

const imageUrls = [
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v3625ad45744d545cd919aa10ef7385bf3.png",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v37d1355ed836047d7a6ff1b445da4890d.png",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v380affb79ff4b480b90c3a1b8902c5f0b.png",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v3fb06001dc40b4f05bdbdc69d6606de60.png",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v3b7b8d90d52aa4ab1acdf1cb2ec656aad.png",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v3681b7b4c8e20436fb3a45211a585ddc2.ico",
  "https://pic4.58cdn.com.cn/nowater/lbgfe/image/n_v3fb06001dc40b4f05bdbdc69d6606de60.png",
];

const maxConcurrentDownloads = 2;

downloadImagesConcurrently(imageUrls, maxConcurrentDownloads)
  .then((downloadedUrls) => {
    console.log("Downloaded images:", downloadedUrls);
  })
  .catch((error) => {
    console.error("Error downloading images:", error);
  });


JavaScript
// Node 版本
// 下载json文件里的所有图片，存储到xxx文件夹下
const fetch = require('node-fetch');
const fs = require('fs-extra');
const { readJson , readJsonArr, writeJson} = require('../utils')
const path = require('path');

class Scheduler {
    constructor(max) {
        this.count = 0;
        this.max = max || 2;
        this.tasks = [];
    }

    add(task) {
        return new Promise((resolve, reject) => {
            task.resolve = resolve; // 修正：直接将 resolve 函数赋值给 task.resolve，不调用
            task.reject = reject;
            if (this.count < this.max) {
                this.start(task);
            } else {
                this.tasks.push(task);
            }
        });
    }

    async start(task) {
        this.count++;
        try {
            const result = await task(); // 修正：直接 await task，因为它是一个异步函数
            task.resolve(result); // 将解析后的结果传递给 resolve 函数
        } catch (error) {
            task.reject(error);
        }
        this.count--;
        if (this.tasks.length > 0) {
            this.start(this.tasks.shift());
        }
    }
}

// 保存图片
function saveImgs(out, jsonData) {
    try {
        const oldList = readJson(out);
        oldList.push(jsonData);
        fs.writeFileSync(out, JSON.stringify(oldList, null, 4), 'utf8');
    } catch (err) {
        console.log('保存图片出错')
    }
}
// 下载并存储 图片信息
async function downloadAndSave({
    img = {},
    source = './metadata.json',
    base = '/base',
}) {
    const metadata = {};
    const sourcePath = path.join(__dirname, source);
    try {
        const response = await fetch(img.url);
        // 检查响应状态码
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const filename = path.basename(img.url);
        const pathName = path.join(__dirname, base + '/' + filename);
        const blob = await response.blob();
        // 创建可写流
        const writer = fs.createWriteStream(pathName);
        // 将Blob转换为可读流
        blob.stream().pipe(writer);
        // 监听完成事件
        writer.on('finish', () => {
            metadata[filename] = { gender: img.gender, workType: img.workType, age: img.age };
            // 将元数据写入到json文件中
            saveImgs(sourcePath, metadata);
            console.log(`保存成功：${pathName}.`);
        });
    } catch (error) {
        console.error(`Error downloading ${img.url}:`, error.message);
    }
}

const requestList = async (jsonData, limit = 2) => {
    let scheduler = new Scheduler(limit);
    let promises = jsonData.map((item, i) => {
        return scheduler.add(() => {
            return downloadAndSave({
                img: item,
                base: '/base2'
            })
        });
    });
    try {
        const list = await Promise.all(promises);
        return list;
    } catch (err) {
        console.log('err', err);
    }
}
const main = async () => {
    const path_1 = path.join(__dirname, './split_json_2.json');
    const jsonData = readJsonArr([path_1]);
    await requestList(jsonData, 15);
    console.log('任务完成')
}
main()
6. 异步请求并发控制器
JavaScript
class Scheduler {
  constructor(max) {
    this.count = 0;
    this.max = max || 2;
    this.tasks = [];
  }

  add(task) {
    return new Promise((resolve, reject) => {
      task.resolve = resolve; // 修正：直接将 resolve 函数赋值给 task.resolve，不调用
      task.reject = reject;
      if (this.count < this.max) {
        this.start(task);
      } else {
        this.tasks.push(task);
      }
    });
  }

  async start(task) {
    this.count++;
    try {
      const result = await task(); // 修正：直接 await task，因为它是一个异步函数
      task.resolve(result); // 将解析后的结果传递给 resolve 函数
    } catch (error) {
      task.reject(error);
    }
    this.count--;
    if (this.tasks.length > 0) {
      this.start(this.tasks.shift());
    }
  }
}

let urlList = [
  'https://jsonplaceholder.typicode.com/todos/1',
  'https://jsonplaceholder.typicode.com/todos/2',
  'https://jsonplaceholder.typicode.com/todos/3',
  'https://jsonplaceholder.typicode.com/todos/1',
  'https://jsonplaceholder.typicode.com/todos/2',
  'https://jsonplaceholder.typicode.com/todos/3',
  'https://jsonplaceholder.typicode.com/todos/1',
  'https://jsonplaceholder.typicode.com/todos/2',
];
const fetch = async function (url) {
  return new Promise((resolve, reject) => {
    const result = {
      json: () => {
        return {
          url
        }
      }
    }
    setTimeout(() => {
      console.log('fetch', result.json());
      resolve(result);
    }, 1000)
  })
}
const requestList = async (urlList, limit = 2) => {
  let scheduler = new Scheduler(limit);
  let promises = urlList.map((url, i) => {
    return scheduler.add(() => fetch(url).then(res => res.json()));
  });
  try{
    const list = await Promise.all(promises);
    return list;
  }catch(err){
    console.log('err', err);
  }
}
const main = async () => {
  const list = await requestList(urlList);
  console.log('list', list);
}
main()
7. 数组去重
JavaScript
function quchong1(arr) {
    const newArr = [];
    arr.reduce((pre, next) => {
        if (pre[next] == null) {
            pre[next] = 1;
            newArr.push(next);
        }
        return pre;
    }, {})
    return newArr;
}
function quchong2(arr) {
    return [...new Set(arr)];
}
function quchong3(arr) {
    let map = new Map();
    arr = arr.filter((item) => {
        if (map.has(item)) {
            return false;
        } else {
            map.set(item, 1);
            return true;
        }
    })
    return arr;
}
function quchong4(arr) {//原地去重
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j]) {
                arr.splice(j, 1);
            }
        }
    }
    return arr;
}
function quchong5(arr) {//indexof第一个索引值
    return arr.filter((item, index, arr) => {
        return arr.indexOf(item, 0) === index;
    })
}
function quchong6(arr) {//includes
    return arr.reduce((pre, cur) => {
        if (pre.includes(cur)) {
            return pre;
        } else {
            return [...pre, cur];
        }
    }, [])
}
console.log(quchong6([1, 2, 3, 3, 5, 4, 2, 1]))
8. 数组扁平化
JavaScript
function flatten(arr) {
    return arr.reduce(function (prev, item) {
        return prev.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}

function flatten2(arr) {
    while (arr.some(Array.isArray)) {
        arr = [].concat(...arr);
    }
    return arr;
}
function flatten3(arr) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] instanceof Array) {
            res = res.concat(flatten3(arr[i]));
        } else {
            res.push(arr[i])
        }
    }
    return res;
}
function flatten4(arr) {
    return arr.flat(Infinity);
}

const flat = (arr, depth = 1) => {
    const res = [];
    for (const item of arr) {
        if (Array.isArray(item) && depth > 0) {
            res.push(...flat(item, depth - 1));
        } else {
            res.push(item);
        }
    }
    return res;
};

console.log(flatten4([1, 2, [3, 4, [5, 6]]]));

9. 柯里化函数
JavaScript

(function () {
  function sum(...args) {
    if (args.length === 0) {
      return 0;
    } else {
      const total = args.reduce((acc, curr) => acc + curr, 0);
      return function (...nextArgs) {
        if (nextArgs.length === 0) {
          return total;
        } else {
          return sum(total, ...nextArgs);
        }
      };
    }
  }
  const result = sum(1, 2)(2, 2)(3)(4)();
  console.log(result);
})();

function a() {
  const add = function (a, b, c) {
    return a + b + c;
  };
  // 只支持固定个数的科里化
  const curry = function (fn) {
    return function curried(...args) {
      if (args.length >= fn.length) {
        return fn(...args);
      } else {
        return function (...args2) {
          return curried(...args, ...args2);
        };
      }
    };
  };
  const addCurry = curry(add);
  console.log(addCurry(1, 2)(3));
  console.log(addCurry(1)(3)(4));
}
a();

10. 树的操作
JavaScript
const nodeList = [
    {
        id: 1,
        children: [{
            id: 10,
            children: [
                { id: 1212 },
                { id: 323 }
            ]
        }, { id: 3 }]
    },
    {
        id: 7,
        children: [{ id: 6 }, { id: 2 }]
    },
    {
        id: 5,
        children: [{ id: 4 }]
    }
]
const output = [
    {
        id: 1,
        children: [{ id: 10 }, { id: 3 }]
    },
    {
        id: 7,
        children: [{ id: 6 }, { id: 2 }]
    },
]
function fn(input) {
    const depthFirstSearchIterative = (rootNode) => {
        let stack = [rootNode];
        let res = [];
        while (stack.length > 0) {
            const currentNode = stack.pop();
            if (input.includes(currentNode.id)) {
                return true;
            }
            res.push(currentNode.id); // 处理当前节点
            // 将子节点逆序推入栈中，以保证深度遍历
            if (currentNode.children) {
                for (let i = currentNode.children.length - 1; i >= 0; i--) {
                    stack.push(currentNode.children[i]);
                }
            }
        };
        return false;
    }
    let res = [];
    for (let i = 0; i < nodeList.length; i++) {
        if (depthFirstSearchIterative(nodeList[i])) {
            res.push(nodeList[i])
        }
    }
    return res;
}
console.log(fn([1212, 2]))
11. fork进程，自动重启
JavaScript
const { fork } = require('child_process');
const path = require('path');

const startChildProcess = () => {
    const forkPath = path.resolve(__dirname, './fork/fork_compute.js');
    const compute = fork(forkPath, ['true'], {
        stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
    });
    /**
     * stdio: ['pipe', 'pipe', 'pipe', 'ipc']:
stdio配置了子进程的标准输入、标准输出、标准错误以及IPC通道的设置。
'pipe'表示将这些流管道化，使得父进程和子进程能够读写这些流。
'ipc'是Inter-Process Communication的缩写，用于在父进程和子进程之间发送消息。
     */
    compute.send('开启一个新的子进程');
    // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件
    compute.on('message', sum => {
        console.log('sum', sum)
    });
    compute.on('close', (code, signal) => {
        console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);
        compute.kill();
    })
    compute.on('error', (code) => {
        console.log('code', code);
        startChildProcess();
    })
    compute.stdout.on('data', (data) => {
        // 将Buffer转换为UTF-8编码的字符串
        const log = data.toString('utf8');
        console.log('子进程 stdout:', log);
    });
    compute.stderr.on('data', (data) => {
        // 将Buffer转换为UTF-8编码的字符串
        const errorLog = data.toString('utf8');
        console.error('子进程 stderr:', errorLog);
        startChildProcess();
    });
}
startChildProcess();


// fork_compute.js 代码
const computation = () => {
    let sum = 0
    console.info('计算开始')
    console.time('计算耗时')

    for (let i = 0; i < 1e4; i++) {
        sum += i
    }

    console.info('计算结束')
    console.timeEnd('计算耗时')
    return sum
}

process.on('message', (msg) => {
    console.log(msg, 'process.pid', process.pid) // 子进程id
    const sum = computation()
    // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息
    process.send(sum)
})
12. web worker复杂计算
JavaScript
// worker.js
self.onmessage = function(event) {
    let result = performComplexCalculation(event.data);
    self.postMessage(result);
};

function performComplexCalculation(data) {
    // 在这里执行你的复杂计算
    // 这只是一个示例，实际的计算可能会更复杂
    let result = 0;
    for (let i = 0; i < data; i++) {
        for (let j = 0; j < data; j++) {
            result += i * j;
        }
    }
    return result;
}

// main.js
let worker = new Worker('worker.js');

worker.postMessage(1000);  // 发送数据给worker

worker.onmessage = function(event) {
    console.log('Received result from worker:', event.data);
};

13. 发布订阅模式
JavaScript
class EventEmitter {
    constructor() {
        this.events = {};
    }
    on(eventName, callback) {
        const res = this.events[eventName] || [];
        this.events[eventName] = [...res, callback];
    }
    off(eventName, callback) {
        if (this.events[eventName]) {
            this.events[eventName] = this.events[eventName].filter(e => e !== callback);
        }
    }  
    emit(eventName, ...args) {
        if (this.events[eventName]) {
            this.events[eventName].forEach(fn => {
                fn(...args);
            })
        }
    }
    once(eventName, callback) {
        const cb = (...args) => {
            callback(...args);
            this.off(eventName, cb);
        }
        this.on(eventName, cb);
    }
}
const eventEmitter = new EventEmitter();
const f = (p) => {
    console.log('1', p);
}
eventEmitter.on(
    'message', f
)

eventEmitter.once(
    'message', (p) => {
        console.log('2', p);
    }
)
eventEmitter.emit('message', 1)
eventEmitter.emit('message', 2)

eventEmitter.emit('message', 3)
eventEmitter.off('message', f)
eventEmitter.emit('message', 4)
14. 空格去重+单词倒序
JavaScript
const str = 'apple         is             right';

const fn = (s) => {
    let res = '';
    let ans = '';
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== ' ') {
            ans += s[i];
        }
        if (i === s.length - 1) {
            res = ans + ' ' + res;
        }
        if (s[i] === ' ' && s[i - 1] !== ' ') {
            res = ans + ' ' + res;
            ans = '';
        }
    }
    return res;
}
console.log(fn(str));
15. promise输出题
JavaScript

console.log('start');

const p = new Promise((resolve, reject) => {
    console.log('promise start');
    resolve();
    console.log('promise end');
}).then(()=>{
    console.log('promise1');
}).then(()=>{
    console.log('promise2');
})
const fn2 = async function(){
    console.log('fn2');
    await fn3();
    console.log('fn2 end')
}
const fn3 = async function(){
    console.log('fn3')
}
const fn = async function(){
    console.log('async');
    await fn2(); 
    console.log('end2');
}
fn();
console.log('end');
16. toTree
JavaScript
function arrayTree(array) {
  function toTree(node) {
    let children = [];
    for (let item of array) {
      if (item.pid === node.id) {
        const res = toTree(item);
        if (res.length > 0) {
          children.push({
            id: item.id,
            val: item.val,
            children: res,
          });
        } else {
          children.push({
            id: item.id,
            val: item.val,
          });
        }
      }
    }
    return children;
  }
  let root;

  person = person.filter(item => {
    if (item.pid == null) {
      root = item;
      return false;
    } else {
      return true;
    }
  });

  return {
    id: root.id,
    val: root.val,
    children: toTree(root),
  };
}

let person = [
  { id: 2, pid: 1, val: "班级1" },
  { id: 3, pid: 1, val: "班级2" },
  { id: 4, pid: 2, val: "学生1" },
  { id: 5, pid: 3, val: "学生2" },
  { id: 6, pid: 3, val: "学生3" },
  { id: 1, pid: null, val: "学校" },
];

console.log(JSON.stringify(arrayTree(person)));
17. 链表实现 + 反转链表 + 删除节点
JavaScript
function ListNode(val = undefined, next = undefined) {
  this.val = val;
  this.next = next;
}
function createList(arr = []) {
  let head = new ListNode(-1);
  let tail = head;
  for (let item of arr) {
    let node = new ListNode(item);
    tail.next = node;
    tail = tail.next;
  }
  return head.next;
}
const list = createList([1, 2, 3]);

const reverseList = (root) => {
  let pre = null;
  let cur = root;
  while (cur) {
    let next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
  }
  return pre;
};
console.log(reverseList(list));

18. 实现一个状态管理hook
创建一个初始状态和 reducer 函数
JavaScript

const initialState = {
  todos: [],
  completedTodosCount: 0,
};
function reducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      const newTodos = [...state.todos, action.payload];
      return {
        ...state,
        todos: newTodos,
        completedTodosCount: newTodos.filter(todo => todo.completed).length,
      };
    case 'TOGGLE_TODO':
      const updatedTodos = state.todos.map((todo, index) =>
        index === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
      return {
        ...state,
        todos: updatedTodos,
        completedTodosCount: updatedTodos.filter(todo => todo.completed).length,
      };
    default:
      throw new Error('Unknown action type');
  }
}

创建一个 Context 和 Provider 组件
JavaScript
const TodoContext = createContext();
export function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <TodoContext.Provider value={{ state, dispatch }}>
      {children}
    </TodoContext.Provider>
  );
}
export function useTodos() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error('useTodos must be used within a TodoProvider');
  }
  return context;
}

子组件【使用store里的数据，用dispatch更新数据】 + 父组件【用自定义Provider包裹子组件】
JavaScript
import React from 'react';
import { TodoProvider, useTodos } from './TodoContext';

const TodoList = () => {
  const { state, dispatch } = useTodos();
  const { todos, completedTodosCount } = state;
  const addTodo = (text) => {
    dispatch({ type: 'ADD_TODO', payload: { text, completed: false } });
  };
  const toggleTodo = (index) => {
    dispatch({ type: 'TOGGLE_TODO', payload: index });
  };
  return (
    <div>
      <ul>
        {todos.map((todo, index) => (
          <li key={index} onClick={() => toggleTodo(index)}>
            {todo.text} {todo.completed ? '(Completed)' : ''}
          </li>
        ))}
      </ul>
      <button onClick={() => addTodo('New Todo')}>Add Todo</button>
      <div>Completed Todos: {completedTodosCount}</div>
    </div>
  );
};


JavaScript
export default function App() {
  return (
    <TodoProvider>
      <TodoList />
    </TodoProvider>
  );
}
19. 最小频数字符串剔除
JavaScript
function removeLeastFrequentChars(str) {
    let charCounts = {};
    for (let char of str) {
        if (charCounts[char]) {
            charCounts[char]++;
        } else {
            charCounts[char] = 1;
        }
    }
    let minCount = Math.min(...Object.values(charCounts));
    let leastFrequentChars = new Set();
    for (let char in charCounts) {
        if (charCounts[char] === minCount) {
            leastFrequentChars.add(char);
        }
    }
    let result = '';
    for (let char of str) {
        if (!leastFrequentChars.has(char)) {
            result += char;
        }
    }
    return result;
}

console.log(removeLeastFrequentChars('aaaddebbcc'));
20. sleep函数【100ms】
JavaScript
function sleep(wait = 1000) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, wait)
    });
}

function sleep2(wait = 200) {
    let time = Date.now();
    return new Promise((resolve) => {
        while (Date.now() - time < wait) { }
        resolve();
    });
}
async function fn() {
    let last = Date.now();
    console.log(1);
    await sleep2(200);
    console.log(2, Date.now() - last);
}

fn()

function preciseSetInterval(callback, delay) {
    let expected = Date.now() + delay;
    let timeout;
    function tick() {
        const drift = Date.now() - expected;
        callback();
        expected += delay;
        timeout = setTimeout(tick, delay - drift);
    }
    timeout = setTimeout(tick, delay);
}

function sleepForAnimationFrame(ms) {
  const start = performance.now();
  const end = start + ms;
  const loop = (currentTime) => {
    if (currentTime < end) {
      requestAnimationFrame(loop);
    } else {
      console.log("Raf-based sleep done");
    }
  };
  requestAnimationFrame(loop);
}

sleepForAnimationFrame(100);
21. 输出题
JavaScript
let a = {};
let b = {};

a[b] = 1;

let c = { d: 2 };
a[c] = 2;
console.log(a[c],a[b],a[{}]);
22. new 函数原理及实现代码，与 Object.create的区别？
Object.create() 和 new 关键字是JavaScript中创建新对象的两种主要方式，它们在用途、内部机制和使用场景上有明显的区别。下面是这两种方法的对比总结：
Object.create()
•用途：Object.create() 主要用于创建一个具有特定原型链的新对象。这允许开发者直接定制对象的原型，从而实现更灵活的继承模式或原型链管理。
•内部机制：
￮创建一个空的基本对象。
￮将该对象的内部 [[Prototype]] 属性指向由 Object.create() 第一个参数指定的对象。
￮如果提供了第二个参数（属性描述符对象的集合），则使用 Object.defineProperties() 方法将这些描述符应用到新对象上，定义其自身属性。
•不涉及构造函数：Object.create() 不会调用任何构造函数，因此对象的初始化完全依赖于属性描述符。

new 关键字
•用途：new 关键字用于创建一个特定构造函数的实例。这通常涉及到构造函数的执行，以便初始化对象的属性和行为。
•内部机制：
￮创建一个空对象。
￮设置该对象的 [[Prototype]] 为构造函数的 prototype 属性所指向的对象。
￮将构造函数的 this 上下文设置为新创建的对象，并执行构造函数。
￮构造函数执行完成后，返回新创建的对象实例（如果构造函数没有显式返回一个对象，则返回新创建的对象）。
•涉及构造函数：new 关键字的核心在于执行一个构造函数，该函数负责对象的初始化，包括定义属性和行为。

总结
•原型链设置：Object.create() 可以直接设置对象的原型，而 new 关键字则会设置对象的原型为构造函数的 prototype。
•构造函数调用：Object.create() 不涉及构造函数的调用，而 new 关键字则总是伴随着构造函数的执行。
•属性定义：Object.create() 允许通过第二个参数定义属性及其特性，而 new 关键字中的属性定义通常在构造函数内部进行。
两者各有优势，选择使用哪一个取决于具体的应用场景和需求。
Object.create() 提供了更细粒度的原型链控制，适合原型继承或复杂的对象构建。而 new 关键字则更适合面向对象编程，当需要构造函数来初始化对象时使用。
JavaScript
function mynew(fn, ...args) {
  let obj = {};
  Object.setPrototypeOf(obj, fn.prototype);
  let res = fn.apply(obj, args);
  return res instanceof Object ? res : obj;
}
// function myNew(constructor, ...args) {
//   const obj = Object.create(constructor.prototype);
//   obj.constructor = constructor;
//   let res = constructor.apply(obj, args);
//   return res instanceof Object ? res : obj;
// }
function mycreate(obj) {
  function c() {}
  c.prototype = obj;
  return new c();
}

23. codingman 
JavaScript
function CodingMan(name) {
  this.name = name;
  this.tasks = [];

  this.sleep = function (seconds) {
    const task = () => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log(`Wake up after ${seconds} seconds`);
          resolve();
        }, seconds * 1000);
      });
    };
    this.tasks.push(task);
    return this;
  };

  this.sleepFirst = function (seconds) {
    const task = () => {
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log(`Wake up after ${seconds} seconds`);
          resolve();
        }, seconds * 1000);
      });
    };
    this.tasks.unshift(task);
    return this;
  };

  this.eat = function (meal) {
    const task = () => {
      console.log(`Eat ${meal}`);
      return Promise.resolve();
    };
    this.tasks.push(task);
    return this;
  };

  this.next = async function () {
    if (this.tasks.length === 0) return;
    const fn = this.tasks.shift();
    await fn();
    this.next();
  };

  this.run = function () {
    const runTasks = async () => {
      for (const task of this.tasks) {
        await task();
      }
    };
    runTasks();
  };
  return this;
}

// 使用示例

const p = new CodingMan("Peter");
p.eat("a")
  .eat("b")
  .sleep(1)
  .eat("supper")
  .sleep(2)
  .eat("apple")
  .sleepFirst(1)
  .next();

24. 深拷贝
JavaScript
// 真精简版
function deepClone(obj, map = new WeakMap()) {
  if (obj == null || typeof obj !== "object") {
    return obj;
  }
  if (map.has(obj)) {
    return map.get(obj);
  }
  let cloneObj;
  if (Array.isArray(obj)) {
    cloneObj = [];
  } else if (obj instanceof Date) {
    cloneObj = new Date(obj);
  } else if (obj instanceof RegExp) {
    cloneObj = new RegExp(obj.source, obj.flags);
  } else if (obj instanceof Map) {
    cloneObj = new Map();
    for (const [key, value] of obj) {
      cloneObj.set(key, deepClone(value, map));
    }
  } else if (obj instanceof Set) {
    cloneObj = new Set();
    for (const value of obj) {
      cloneObj.add(deepClone(value, map));
    }
  } else {
    cloneObj = Object.create(Object.getPrototypeOf(obj));
  }

  map.set(obj, cloneObj);

  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloneObj[key] = deepClone(obj[key], map);
    }
  }

  return cloneObj;
}
// const timer = new Date();
// const res = deepClone(timer);
// console.log(timer)
// console.log(res)

let a = [1, 3, 5];
for (let key in a) {
  if (Object.prototype.hasOwnProperty.call(a, key)) {
    console.log(key)
  }
}
25. 优化定时器
JavaScript
unction sleepForAnimationFrame(ms) {
  const start = performance.now();
  const end = start + ms;
  const loop = (currentTime) => {
    if (currentTime < end) {
      requestAnimationFrame(loop);
    } else {
      console.log("Raf-based sleep done");
    }
  };
  requestAnimationFrame(loop);
}

sleepForAnimationFrame(100);

JavaScript
function preciseSetInterval(callback, delay) {
    let expected = Date.now() + delay;
    let timeout;
    function tick() {
        const drift = Date.now() - expected;
        callback();
        expected += delay;
        timeout = setTimeout(tick, delay - drift);
    }
    timeout = setTimeout(tick, delay);
}
26. LRU算法
LRU（Least Recently Used）算法是一种常用的缓存淘汰策略。当缓存满时，它会优先淘汰最近最少使用的数据。下面是一个使用JavaScript实现的LRU缓存算法，基于链表实现。
JavaScript
class Node {
    constructor(key, value) {
        this.key = key;
        this.value = value;
        this.prev = null;
        this.next = null;
    }
}

class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.hashMap = new Map(); // 用于快速查找节点
        this.head = new Node(); // 头节点，实际不存储数据
        this.tail = new Node(); // 尾节点，实际不存储数据
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }

    get(key) {
        if (this.hashMap.has(key)) {
            const node = this.hashMap.get(key);
            this.moveToHead(node); // 将访问的节点移动到头部
            return node.value;
        }
        return -1; // 如果key不存在，返回-1
    }

    put(key, value) {
        if (this.hashMap.has(key)) { // 如果key已存在，则更新其值并移到头部
            const node = this.hashMap.get(key);
            node.value = value;
            this.moveToHead(node);
        } else {
            const newNode = new Node(key, value);
            this.hashMap.set(key, newNode);
            this.addToHead(newNode);

            if (this.hashMap.size > this.capacity) { // 如果超过容量，删除尾部节点
                const tailNode = this.removeTail();
                this.hashMap.delete(tailNode.key);
            }
        }
    }

    moveToHead(node) {
        this.removeNode(node);
        this.addToHead(node);
    }

    addToHead(node) {
        node.prev = this.head;
        node.next = this.head.next;
        this.head.next.prev = node;
        this.head.next = node;
    }

    removeNode(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    removeTail() {
        const tailNode = this.tail.prev;
        this.removeNode(tailNode);
        return tailNode;
    }
}

// 测试数据
const cache = new LRUCache(2);

cache.put(1, 1);
cache.put(2, 2);
console.log(cache.get(1)); // 返回 1
cache.put(3, 3); // 逐出 key 2
console.log(cache.get(2)); // 返回 -1 (未找到)
cache.put(4, 4); // 逐出 key 1
console.log(cache.get(1)); // 返回 -1 (未找到)
console.log(cache.get(3)); // 返回 3
console.log(cache.get(4)); // 返回 4

这段代码首先定义了一个Node类来表示链表中的节点，每个节点包含键、值以及指向前一个和后一个节点的指针。然后定义了LRUCache类，实现了get和put方法，分别对应获取缓存值和设置缓存值的操作。当缓存达到容量限制时，自动移除最久未使用的项。测试数据部分展示了如何使用这个LRU缓存进行一些基本操作。

JavaScript
/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {
    this.capacity = capacity;
    this.stack = new Map();
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {
    if(this.stack.has(key)){
        let res = this.stack.get(key);
        this.stack.delete(key);
        this.stack.set(key,res);
        return res;
    }else{
        return -1;
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {
    if(this.stack.has(key)){
        this.stack.delete(key)
    }
    this.stack.set(key,value);
    if(this.stack.size > this.capacity){
        this.stack.delete(this.stack.keys().next().value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
27. 图片懒加载
JavaScript
<!DOCTYPE html>
<html>
<head>
    <title>图片懒加载</title>
    <style type="text/css">
        .imgUnitContainer{
            height: 300px; /* 固定一个高度 */
            width: 500px; /* 固定一个宽度 */
            overflow: hidden; /* 图片超出容器则隐藏 */
            border: 1px solid #eee; /* 边框 */
            margin: 10px; /* 外边距 */
            display: flex; /* 弹性布局 此处主要目的为使图片居中 */
            align-items: center; /* 垂直居中 */
            justify-content: center; /* 水平居中 */
        }
    </style>
</head>
<body>
    <div id="container"></div> <!-- 图片容器 -->
</body>
    <script type="text/javascript">
        var imgNodeList = []; // 所有懒加载图片的引用
        (function(){ // 初始化操作
            var imgUrlArr = [ // 所有需要加载的图片链接
 "http://www.sdust.edu.cn/__local/9/7A/B1/F29B84DEF72DD329997E8172ABA_664BA3EF_32466.jpg",             "http://www.sdust.edu.cn/__local/B/F3/E4/693AB931C9FFB84646970D53BFE_C506394A_4282CA.jpg",            "http://www.sdust.edu.cn/__local/F/7A/AA/E1459849AA8AB0C89854A41BD41_BF3BD857_BC0D8.jpg",             "http://www.sdust.edu.cn/__local/1/95/CB/EDC1450B8FD1B8A25FAAC726AA4_A36D4253_16C91.jpg",
 "http://www.sdust.edu.cn/__local/9/7A/B1/F29B84DEF72DD329997E8172ABA_664BA3EF_32466.jpg",            "http://www.sdust.edu.cn/__local/B/F3/E4/693AB931C9FFB84646970D53BFE_C506394A_4282CA.jpg",            "http://www.sdust.edu.cn/__local/F/7A/AA/E1459849AA8AB0C89854A41BD41_BF3BD857_BC0D8.jpg",
"http://www.sdust.edu.cn/__local/1/95/CB/EDC1450B8FD1B8A25FAAC726AA4_A36D4253_16C91.jpg",
"http://www.sdust.edu.cn/__local/9/7A/B1/F29B84DEF72DD329997E8172ABA_664BA3EF_32466.jpg",
"http://www.sdust.edu.cn/__local/B/F3/E4/693AB931C9FFB84646970D53BFE_C506394A_4282CA.jpg",
"http://www.sdust.edu.cn/__local/F/7A/AA/E1459849AA8AB0C89854A41BD41_BF3BD857_BC0D8.jpg",
"http://www.sdust.edu.cn/__local/1/95/CB/EDC1450B8FD1B8A25FAAC726AA4_A36D4253_16C91.jpg",
            ];
            var innerContainer = document.createElement("div"); // 最小化操作DOM 全部图片首先加载到此节点 最后一并挂载到图片容器
            imgUrlArr.forEach(v => { // 遍历图片的引用
                var imgUnitContainer = document.createElement("div"); // 图片外层div 主要为统一图片尺寸
                imgUnitContainer.className = "imgUnitContainer"; // 设置class
                var img = new Image(); // new一个img节点
                img.src = "https://cdn.jsdelivr.net/gh/sentsin/layui@15d7241/dist/css/modules/layer/default/loading-2.gif"; // 显示loading
                img.setAttribute("data-src", v); // 存储真实需要加载的url
                img.setAttribute("loaded","no"); // 存储图片是否加载完成
                imgNodeList.push(img); // 将节点引用加入数组
                imgUnitContainer.appendChild(img); // 将img加入外层div
                innerContainer.appendChild(imgUnitContainer); // 将外层div加入内部容器
            })
            document.getElementById("container").appendChild(innerContainer); // 一次性加入文档container节点
        })();

        function lazyLoad(){
            var height = window.innerHeight; // 可视区域高度
            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动区域高度
            imgNodeList.forEach(v => { // 遍历
                if(v.getAttribute("loaded") === "yes") return ; // 如果已经加载完成 便不再重复加载
                if((height + scrollTop) > v.offsetTop){ // 如果已经出现在屏幕内
                    v.setAttribute("loaded", "yes"); // 首先设置已加载避免重复加载
                    var tmp = new Image(); // new一个缓存img节点 主要是为了实现隐式加载
                    tmp.src = v.getAttribute("data-src"); // 设置缓存节点的src 使其开始加载
                    tmp.onload = function(){ // 缓存img加载完成事件
                        v.src = v.getAttribute("data-src"); // 缓存img加载完成后将真实url赋值文档显示的图片节点 浏览器会直接读取缓存
                    }
                }
            })
        }

        window.onscroll = function(){ // 浏览器滚动事件
            lazyLoad();
        }

        window.onload = function(){ // 文档加载完成事件
            lazyLoad();
        }

    </script>
</html>

28. generator函数模拟async
JavaScript
function fetchData(url) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(`Data from ${url}`);
        }, 1000); // 模拟异步操作
    });
}

function* asyncGenerator() {
    const data1 = yield fetchData('url1');
    console.log(data1); // 输出：Data from url1
    const data2 = yield fetchData('url2');
    console.log(data2); // 输出：Data from url2
    const data3 = yield fetchData('url3');
    console.log(data3); // 输出：Data from url3
}

// 执行生成器的异步操作
function run(generator) {
    const iterator = generator();
    function process(result) {
        if (result.done) return;
        result.value.then(data => {
            process(iterator.next(data));
        });
    }
    process(iterator.next());
}
run(asyncGenerator);

29. pipe
JavaScript中，"pipe" 和 "compose" 是两个常用的函数式编程概念，它们用于组合多个函数以创建更复杂的函数。这些概念可以帮助您编写更具可维护性和可重用性的代码。

1. Pipe（管道）：Pipe 是一种函数组合方式，它按照从左到右的顺序依次执行一系列函数，
将前一个函数的输出作为下一个函数的输入。这有助于将复杂的操作分解成一系列简单的步骤。

2. Compose（组合）：Compose 与 Pipe 相似，但是执行函数的顺序是从右到左的，
即将最右边的函数的输出作为下一个函数的输入。Compose 更符合数学中的函数组合定义。

JavaScript

const pipe = (...functions) => (input) =>
  functions.reduce((result, func) => func(result), input);

const add = (x) => x + 5;
const multiply = (x) => x * 2;
const subtract = (x) => x - 3;

const pipeline = pipe(add, multiply, subtract);
const result = pipeline(10); // 先加5，然后乘以2，最后减3
console.log(result); // 输出 27

Compose（组合）

// 简单的 Compose 实现
const compose = (...functions) => (input) =>
  functions.reduceRight((result, func) => func(result), input);

// 示例用法
const add = (x) => x + 5;
const multiply = (x) => x * 2;
const subtract = (x) => x - 3;

const composition = compose(subtract, multiply, add); // 有右向左
const result = composition(10); 
console.log(result); // 17


在上述示例中，`pipe` 和 `compose` 函数分别创建了管道和组合，可以将多个函数连接在一起，
按照指定的顺序执行它们。这样的抽象允许您以一种更清晰和模块化的方式组织函数调用，提高代码的可读性和可维护性。
30. lodash.get
JavaScript
function get(source, path, defaultValue = undefined) {
    // a[3].b -> a.3.b -> [a,3,b]
    // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组
    const paths = path.replace(/\[(\d+)\]/g, ".$1").split(".");
    console.log(paths) // ["a", "0", "b"]
    let result = source; //这个result一直都是for循环中下一个key的上个节点
    //循环字符串中的数组取最后一个
    for (const p of paths) {
        result = Object(result)[p];
        if (result == undefined) {
            return defaultValue;
        }
    }
    return result;
}
// 测试用例
console.log(get({ a: [{ b: 1 }] }, "a[0].b", 3)); // output: 1
31. setTimeout实现setInterval ｜ setInterval 实现 setTimeout？
JavaScript
// setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。
// 针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。
// 实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果

function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true,
  };
  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }
  // 启动定时器
  setTimeout(interval, timeout);
  // 返回控制器
  return timer;
}

const myinterval = (fn, delay) => {
  const timer = {
    flag: true,
  };
  const interval = () => {
    if (timer.flag) {
      fn();
      setTimeout(() => {
        interval();
      }, delay);
    }
  };
  setTimeout(() => {
    interval();
  }, delay);
  return timer;
};

let a = setInterval(() => {
  console.log("1-00");
}, 1000);
let b = myinterval(() => {
  console.log("1-00");
}, 1000);

console.log(a);
console.log(b);


JavaScript
const mySetTimeout = (fn, delay) => {
  const timer = () => {
    setInterval(() => {
      clearInterval(timer);
      fn();
    }, delay);
  };
};

32. call、apply、bind 代码实现和区别
JavaScript
Function.prototype.call = function (context) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    let args = [...arguments].slice(1);
    context = context || window;
    context.fn = this;
    let res = context.fn(...args);
    delete context.fn;
    return res;
    // return 'hello'
}
Function.prototype.apply = function (context) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    context = context || window;
    context.fn = this;
    let res = null;
    if (arguments[1]) {
        res = context.fn(...arguments[1]);
    } else {
        res = context.fn();
    }
    delete context.fn;
    return res;
}
Function.prototype.bind = function (context) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    let fn = this;
    let args = [...arguments].slice(1);
    return function Fn() {
        return fn.apply(this instanceof Fn ?
            this : context, args.concat(...arguments))
    }
}
/**
 * call、apply、bind是JavaScript中的三个函数，它们都可以用来改变函数的this指向。
call和apply的作用是一样的，都是用来调用函数并改变函数的this指向。它们的区别在于传参的方式不同。call的参数是一个一个传递的，而apply的参数是以数组的形式传递的。
bind函数则是用来创建一个新的函数，并且将原函数的this指向绑定到指定的对象上。bind函数不会立即执行原函数，而是返回一个新的函数，需要手动调用才会执行。
另外，call、apply、bind函数都可以用来实现函数的继承。通过改变函数的this指向，可以让子类继承父类的方法。

bind函数返回的是一个新的函数，如果使用new关键字调用这个新函数，那么this指向的是新创建的对象。
如果不使用new关键字调用这个新函数，那么this指向的是指定的对象或者调用bind函数时传入的this值。
 */
console.log(Object.prototype.toString.call({}))
console.log(Object.prototype.toString.call(() => { }))
console.log(Object.prototype.toString.apply(() => { }))
console.log(Object.prototype.toString.apply(() => { }))
33. 手写promise
JavaScript
class myPromise {
  static PENDING = "pending";
  static FULFILLED = "fulfilled";
  static REJECTED = "rejected";

  constructor(func) {
    this.PromiseState = myPromise.PENDING;
    this.PromiseResult = null;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    try {
      func(this.resolve.bind(this), this.reject.bind(this));
    } catch (error) {
      this.reject(error);
    }
  }

  resolve(result) {
    if (this.PromiseState === myPromise.PENDING) {
      this.PromiseState = myPromise.FULFILLED;
      this.PromiseResult = result;
      this.onFulfilledCallbacks.forEach((callback) => {
        callback(result);
      });
    }
  }

  reject(reason) {
    if (this.PromiseState === myPromise.PENDING) {
      this.PromiseState = myPromise.REJECTED;
      this.PromiseResult = reason;
      this.onRejectedCallbacks.forEach((callback) => {
        callback(reason);
      });
    }
  }
  then(onFulfilled, onRejected) {
    function resolvePromise(promise2, x, resolve, reject) {
      if (x === promise2) {
        throw new TypeError("Chaining cycle detected for promise");
      }

      if (x instanceof myPromise) {
        x.then((y) => {
          resolvePromise(promise2, y, resolve, reject);
        }, reject);
      } else {
        resolve(x);
      }
    }

    let promise2 = new myPromise((resolve, reject) => {
      if (this.PromiseState === myPromise.FULFILLED) {
        setTimeout(() => {
          try {
            if (typeof onFulfilled !== "function") {
              resolve(this.PromiseResult);
            } else {
              let x = onFulfilled(this.PromiseResult);
              resolvePromise(promise2, x, resolve, reject);
            }
          } catch (e) {
            reject(e);
          }
        });
      } else if (this.PromiseState === myPromise.REJECTED) {
        setTimeout(() => {
          try {
            if (typeof onRejected !== "function") {
              reject(this.PromiseResult);
            } else {
              let x = onRejected(this.PromiseResult);
              resolvePromise(promise2, x, resolve, reject);
            }
          } catch (e) {
            reject(e);
          }
        });
      } else if (this.PromiseState === myPromise.PENDING) {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              if (typeof onFulfilled !== "function") {
                resolve(this.PromiseResult);
              } else {
                let x = onFulfilled(this.PromiseResult);
                resolvePromise(promise2, x, resolve, reject);
              }
            } catch (e) {
              reject(e);
            }
          });
        });
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              if (typeof onRejected !== "function") {
                reject(this.PromiseResult);
              } else {
                let x = onRejected(this.PromiseResult);
                resolvePromise(promise2, x, resolve, reject);
              }
            } catch (e) {
              reject(e);
            }
          });
        });
      }
    });

    return promise2;
  }

  static resolve(value) {
    if (value instanceof myPromise) {
      return value;
    } else {
      return new myPromise((resolve) => {
        resolve(value);
      });
    }
  }

  static reject(reason) {
    return new myPromise((resolve, reject) => {
      reject(reason);
    });
  }

  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(callBack) {
    return this.then(callBack, callBack);
  }

  static all(promises) {
    return new myPromise((resolve, reject) => {
      if (Array.isArray(promises)) {
        let result = []; // 存储结果
        let count = 0; // 计数器
        if (promises.length === 0) {
          return resolve(promises);
        }

        promises.forEach((item, index) => {
          myPromise.resolve(item).then(
            (value) => {
              count++;
              result[index] = value;
              count === promises.length && resolve(result);
            },
            (reason) => {
              reject(reason);
            }
          );
        });
      } else {
        return reject(new TypeError("Argument is not iterable"));
      }
    });
  }

  static allSettled(promises) {
    return new myPromise((resolve, reject) => {
      if (Array.isArray(promises)) {
        let result = []; // 存储结果
        let count = 0; // 计数器
        if (promises.length === 0) return resolve(promises);
        promises.forEach((item, index) => {
          myPromise.resolve(item).then(
            (value) => {
              count++;
              result[index] = {
                status: "fulfilled",
                value,
              };
              count === promises.length && resolve(result);
            },
            (reason) => {
              count++;
              result[index] = {
                status: "rejected",
                reason,
              };
              count === promises.length && resolve(result);
            }
          );
        });
      } else {
        return reject(new TypeError("Argument is not iterable"));
      }
    });
  }
  static any(promises) {
    return new myPromise((resolve, reject) => {
      if (Array.isArray(promises)) {
        let errors = []; //
        let count = 0; // 计数器

        if (promises.length === 0)
          return reject(new AggregateError([], "All promises were rejected"));

        promises.forEach((item) => {
          myPromise.resolve(item).then(
            (value) => {
              resolve(value);
            },
            (reason) => {
              count++;
              errors.push(reason);
              count === promises.length &&
                reject(
                  new AggregateError(errors, "All promises were rejected")
                );
            }
          );
        });
      } else {
        return reject(new TypeError("Argument is not iterable"));
      }
    });
  }

  static race(promises) {
    return new myPromise((resolve, reject) => {
      if (Array.isArray(promises)) {
        if (promises.length > 0) {
          promises.forEach((item) => {
            myPromise.resolve(item).then(resolve, reject);
          });
        }
      } else {
        return reject(new TypeError("Argument is not iterable"));
      }
    });
  }
}

myPromise.deferred = function () {
  let result = {};
  result.promise = new myPromise((resolve, reject) => {
    result.resolve = resolve;
    result.reject = reject;
  });
  return result;
};

const promise = new myPromise((resolve, reject) => {
  const randomNumber = Math.random();
  if (randomNumber > 0.5) {
    resolve("Success");
  } else {
    reject("Failure");
  }
}).then(
  (result) => console.log(result), // Success
  (error) => console.error(error) // Failure
);

module.exports = myPromise;

Promise.prototype.myAll = function (promises) {
  return new Promise((resolve, reject) => {
    if (Array.isArray(promises)) {
      let res = [];
      let count = 0;
      if (promise.length === 0) {
        return resolve(promises);
      } else {
        promises.forEach((item, inx) => {
          Promise.resolve(item).then(
            (value) => {
              count++;
              res[inx] = value;
              count === promise.length && resolve(res);
            },
            (reason) => {
              reject(reason);
            }
          );
        });
      }
    } else {
      return reject(new TypeError("Argument is not iterable"));
    }
  });
};
Promise.prototype.myRace = function (promises) {
  return new Promise((resolve, reject) => {
    if (Array.isArray(promises)) {
      if (promise.length === 0) {
        return resolve(promises);
      } else {
        promises.forEach((item, inx) => {
          Promise.resolve(item).then(resolve, reject);
        });
      }
    } else {
      return reject(new TypeError("Argument is not iterable"));
    }
  });
};

34. 二叉树的遍历
JavaScript
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
// 二叉树的层次遍历
var levelOrder = function (root) {
  if (!root) {
    return [];
  }
  let queue = [root];
  let res = [];
  while (queue.length) {
    let len = queue.length;
    res.push([]);
    while (len--) {
      const node = queue.shift();
      res[res.length - 1].push(node.val);
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
  }
  return res;
};

// 根据层次遍历创建二叉树
function createTree(arr) {
  if (!arr.length) return null;
  const root = new TreeNode(arr[0]);
  const queue = [root];
  for (let i = 1; i < arr.length; i += 2) {
    const currentNode = queue.shift();
    if (arr[i] !== null) {
      currentNode.left = new TreeNode(arr[i]);
      queue.push(currentNode.left);
    }
    if (i + 1 < arr.length && arr[i + 1]) {
      currentNode.right = new TreeNode(arr[i + 1]);
      queue.push(currentNode.right);
    }
  }
  return root;
}
const tree = createTree([1, 2, 3, 4, 5]);
// console.log(tree, levelOrder(tree));

// 只根据先序遍历创建不了唯一的二叉树
function createBinaryTreeFromPreorder(preorder) {
  let index = 0; // 用于追踪字符序列的索引
  function buildTree() {
    if (index >= preorder.length) {
      index++; // 移动到下一个字符
      return null;
    }
    const root = new TreeNode(preorder[index]);
    index++; // 移动到下一个字符
    root.left = buildTree();
    root.right = buildTree();
    return root;
  }

  return buildTree();
}
// console.log(createBinaryTreeFromPreorder([1, 2, 3]));

// 先序遍历
const preOrder = (root, res) => {
  if (!root) return;
  res.push(root.val);
  preOrder(root.left, res);
  preOrder(root.right, res);
};
let result = [];
// 中序遍历
const inOrder = (root, res) => {
  if (!root) return;
  inOrder(root.left, res);
  res.push(root.val);
  inOrder(root.right, res);
};

// 后序遍历
const endOrder = (root, res) => {
  if (!root) return;
  endOrder(root.left, res);
  endOrder(root.right, res);
  res.push(root.val);
};

result = [];
preOrder(tree, result);
console.log("先序[递归]", result);

result = [];
inOrder(tree, result);
console.log("中序[递归]", result);

result = [];
endOrder(tree, result);
console.log("后序[递归]", result);

function preOrder2(root) {
  let res = [];
  let queue = [root];
  while (queue.length) {
    let node = queue.pop();
    res.push(node.val);
    if (node.right) {
      queue.push(node.right);
    }
    if (node.left) {
      queue.push(node.left);
    }
  }
  return res;
}
function inOrder2(root) {
  let stack = [];
  let res = [];
  while (root || stack.length) {
    while (root) {
      stack.push(root);
      root = root.left;
    }
    let node = stack.pop();
    res.push(node.val);
    root = node.right;
  }
  return res;
}
function endOrder2(root) {
  let res = [];
  let queue = [root];
  while (queue.length) {
    let node = queue.pop();
    res.push(node.val);
    if (node.left) {
      queue.push(node.left);
    }
    if (node.right) {
      queue.push(node.right);
    }
  }
  return res.reverse();
}
console.log("先序遍历【非递归版】", preOrder2(tree));
console.log("中序遍历【非递归版】", inOrder2(tree));
console.log("后序遍历【非递归版】", endOrder2(tree));

35. 深度优先 DFS 、广度优先 BFS
JavaScript
const dom = {
  val: 1,
  children: [
    {
      val: 2,
      children: [
        {
          val: 3,
          children: [],
        },
      ],
    },
    {
      val: 4,
      children: [],
    },
  ],
};

// dfs: 深度优先
function depthFirstSearch(node) {
  if (node) {
    console.log(node); // 处理当前节点
    for (let i = 0; i < node.children.length; i++) {
      depthFirstSearch(node.children[i]); // 递归处理子节点
    }
  }
}
// dfs: 深度优先，非递归版
function depthFirstSearchIterative(rootNode) {
  const stack = [rootNode];
  while (stack.length > 0) {
    const currentNode = stack.pop();
    console.log(currentNode); // 处理当前节点

    // 将子节点逆序推入栈中，以保证深度遍历
    for (let i = currentNode.children.length - 1; i >= 0; i--) {
      stack.push(currentNode.children[i]);
    }
  }
}

// bfs：广度优先
function breadthFirstSearch(node) {
  const queue = [node];

  while (queue.length > 0) {
    const currentNode = queue.shift();
    console.log(currentNode); // 处理当前节点

    for (let i = 0; i < currentNode.children.length; i++) {
      queue.push(currentNode.children[i]); // 将子节点添加到队列
    }
  }
}

// 调用广度遍历，从根节点开始
const rootNode = document.documentElement;
breadthFirstSearch(rootNode);

36. 检查循环引用
JavaScript
function isHasCircle(obj) {
    let hasCircle = false
    const map = new Map()
    function loop(obj) {
        const keys = Object.keys(obj)
        keys.forEach(key => {
            const value = obj[key]
            if (typeof value == 'object' && value !== null) {
                if (map.has(value)) {
                    hasCircle = true
                    return
                } else {
                    map.set(value)
                    loop(value)
                }
            }
        })
    }
    loop(obj)
    return hasCircle
}

let obj = {
    a: 1,
    b: 2,
}
obj['c'] = obj;
console.log('1', isHasCircle(obj));
37. 手写jsonp 
手动创建一个简单的 JSONP（JSON with Padding）请求，你需要编写一个 JavaScript 函数来执行请求并处理响应。JSONP 是一种绕过同源策略的技术，通常用于从不同域的服务器获取数据。
JavaScript
// 创建一个全局的回调函数
function handleJSONPResponse(data) {
    console.log("JSONP Response Data: ", data);
    // 在这里处理获取到的数据
}
// 动态创建一个 <script> 元素来加载 JSONP 数据
function makeJSONPRequest(url) {
    // 生成一个唯一的回调函数名
    const callbackName = "jsonpCallback" + Math.round(Math.random() * 100000);
    // 将回调函数名添加到请求的 URL 中
    const script = document.createElement("script");
    script.src = url + "?callback=" + callbackName;
    // 将 <script> 元素添加到页面中
    document.body.appendChild(script);
    // 创建一个全局的回调函数来处理响应
    window[callbackName] = function(data) {
        handleJSONPResponse(data);
        // 响应处理完成后，删除回调函数和 <script> 元素
        delete window[callbackName];
        document.body.removeChild(script);
    };
}

// 发起 JSONP 请求
const jsonpUrl = "https://example.com/api/data";
makeJSONPRequest(jsonpUrl);
38. 简版 vue2 实现
JavaScript
let data = {
    name: "hdf",
    age: 19,
    friend: {
        name: "张纹龙",
    },
};

//变成响应式数据
observer(data);

function observer(target) {
    function defineReactive(target, key, value) {
        //深度观察
        observer(value);

        Object.defineProperty(target, key),
        {
            get() {
                return value;
            },
            set(newValue) {
                observer(newValue);
                if (newValue !== value) {
                    value = newValue;
                    console.log("更新视图");
                }
            },
        };
    }
    
    if (!target || typeof target == "object") {
        return target;
    }

    for (let key in target) {
        defineReactive(target, key, target[key]);
    }
}

39. 手写vue3 响应式
JavaScript
// 判断是否为对象 ，注意 null 也是对象
const isObject = val => val !== null && typeof val === 'object'
// 判断key是否存在
const hasOwn = (target, key) => Object.prototype.hasOwnProperty.call(target, key)

function reactive(target) {
    // 首先先判断是否为对象
    if (!isObject(target)) return target

    const handler = {
        get(target, key, receiver) {
            console.log(`获取对象属性${key}值`)
            // 这里还需要收集依赖，先空着
            track(target, key)

            const result = Reflect.get(target, key, receiver)
            // 递归判断的关键, 如果发现子元素存在引用类型，递归处理。
            if (isObject(result)) {
                return reactive(result)
            }
            return result
        },

        set(target, key, value, receiver) {
            console.log(`设置对象属性${key}值`)

            // 首先先获取旧值
            const oldValue = Reflect.get(target, key, reactive)

            // set 是需要返回 布尔值的
            let result = true
            // 判断新值和旧值是否一样来决定是否更新setter
            if (oldValue !== value) {
                result = Reflect.set(target, key, value, receiver)
                trigger(target, key)
            }
            return result
        },

        deleteProperty(target, key) {
            console.log(`删除对象属性${key}值`)

            // 先判断是否有key
            const hadKey = hasOwn(target, key)
            const result = Reflect.deleteProperty(target, key)

            if (hadKey && result) {
                // 删除时，是否需要 响应式触发trigger
                trigger(target, key)
            }

            return result
        },
    }
    return new Proxy(target, handler)
}

// activeEffect 表示当前正在走的 effect
let activeEffect = {}
const effectStack = [];

function effect(fn,options = {}) {
  const effectFn = () => {
      cleanup(effectFn)
      activeEffect = effectFn
      effectStack.push(effectFn);
      const res = fn()
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
      return res;
  }
  effectFn.deps = []
  effectFn.options = options;
  if(!options.lazy){
     effectFn()
  }
  // computed
  return effectFn
}

function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
        const deps = effectFn.deps[i]
        deps.delete(effectFn)
    }
    effectFn.deps.length = 0
}

// targetMap 表里每个key都是一个普通对象 对应他们的 depsMap
let targetMap = new WeakMap()

function track(target, key) {
    if (!activeEffect) return
    // 获取当前对象的依赖图
    let depsMap = targetMap.get(target)
    // 不存在就新建
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()))
    }
    // 根据key 从 依赖图 里获取到到 effect 集合
    let dep = depsMap.get(key)
    // 不存在就新建
    if (!dep) {
        depsMap.set(key, (dep = new Set()))
    }
    // 如果当前effectc 不存在，才注册到 dep里
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect)
        activeEffect.deps.push(dep)
    }
}

// trigger 响应式触发
function trigger(target, key) {
    // 拿到 依赖图
    const depsMap = targetMap.get(target)
    if (!depsMap) {
        // 没有被追踪，直接 return
        return
    }
    // 拿到了 视图渲染effect 就可以进行排队更新 effect 了
    const dep = depsMap.get(key)
    // 遍历 dep 集合执行里面 effect 副作用方法
    // 避免 副作用的依赖数组 无限增删依赖问题
    const effectsToRun = new Set(dep);
    effectsToRun.forEach(effectFn => {
        if(effectFn.options.scheduler){
            effectFn.options.scheduler(effectFn)
        }else{
            effectFn()
        }
    })
}

function computed(fn) {
    let dirty = true;
    let val;
    const effectFn = effect(fn,{
        lazy: true,
        scheduler(fn){
            if(!dirty) {
                dirty = true
                trigger(obj, 'value');
            }
        }
    });
    const obj = {
        get value(){
            if(dirty){
                val = effectFn();
                dirty = false;
                // console.log('重新计算',val);
            }else{
                // console.log('旧值',val);
            }
            track(obj, 'value');
            return val;
        }
    }
    return obj
}

// 遍历读取对象的每个值
function traverse(value,seen = new Set()){
    if(value !== 'object' || value === null || seen.has(value)){
        return;
    }
    seen.add(value);
    for(const k in value){
        traverse(value[k],seen);
    }
    return value;
}

function watch(source,cb,options={}){
    let getter;
    let newValue,oldValue;
    if(typeof source === 'function'){
        getter = source;
    }else{
        getter = traverse(source);
    }
    const job = ()=>{
        newValue = effectFn();
        cb(oldValue,newValue);
        oldValue = newValue;
    }
    const effectFn = effect(()=> getter(),{
        lazy: true,
        scheduler: job
    })
    if(options.immediate){
        job()
    }else{
        oldValue = effectFn();
    }
}

40. localStorage存的值设置过期时间
JavaScript
const store = {
  setExpireMap: (key, expire) => {
    const expireMap = JSON.parse(localStorage.getItem('EXPIRE_MAP') || '{}');
    localStorage.setItem('EXPIRE_MAP', JSON.stringify({ ...expireMap, [key]: expire }));
  },
  setItem: (key, value, expire) => {
    store.setExpireMap(key, expire);
    localStorage.setItem(key, value);
  },
  getItem: (key) => {
    const expireMap = JSON.parse(localStorage.getItem('EXPIRE_MAP') || '{}');
    if (expireMap[key] && expireMap[key] < Date.now()) {
      return localStorage.getItem(key);
    } else {
      localStorage.removeItem(key);
      return null;
    }
  },
  // ... 其他方法
};

41. 对象实现 for of 遍历？
要使一个对象可通过for...of遍历，该对象必须实现一个迭代器（iterator）。迭代器是一个带有next方法的对象，该方法在每次迭代时返回一个包含value和done属性的对象，其中value表示当前迭代的值，done表示是否遍历完成。
JavaScript
const customIterable = {
  data: [1, 2, 3, 4, 5],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          const value = this.data[index];
          index++;
          return { value, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (const item of customIterable) {
  console.log(item);
}

42. ajax请求
JavaScript
function ajax(url) {
    // 创建一个 promise 对象
    let promise = new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      // 新建一个 http 请求
      xhr.open("GET", url, true);
      // 设置状态的监听函数
      xhr.onreadystatechange = function() {
        if (this.readyState !== 4) return;
        // 当请求成功或失败时，改变 promise 的状态
        if (this.status === 200) {
          resolve(this.response);
        } else {
          reject(new Error(this.statusText));
        }
      };
      // 设置错误监听函数
      xhr.onerror = function() {
        reject(new Error(this.statusText));
      };
      // 设置响应的数据类型
      xhr.responseType = "json";
      // 设置请求头信息
      xhr.setRequestHeader("Accept", "application/json");
      // 发送 http 请求
      xhr.send(null);
    });
    return promise;
  }
 
43. 路由实现
HTML
<!DOCTYPE html>
<html lang="en">
<body>
<ul>
    <ul>
        <!-- 定义路由 -->
        <li><a href="#/home">home</a></li>
        <li><a href="#/about">about</a></li>
        <!-- 渲染路由对应的 UI -->
        <div id="routeView"></div>
    </ul>
</ul>
</body>
<script>
    let routerView = routeView
    window.addEventListener('hashchange', ()=>{
        let hash = location.hash;
        routerView.innerHTML = hash
    })
    window.addEventListener('DOMContentLoaded', ()=>{
        if(!location.hash){//如果不存在hash值，那么重定向到#/
            location.hash="/"
        }else{//如果存在hash值，那就渲染对应UI
            let hash = location.hash;
            routerView.innerHTML = hash
        }
    })
</script>
</html>

JavaScript
<!DOCTYPE html>
<html lang="en">
<body>
<ul>
    <ul>
        <li><a href='/home'>home</a></li>
        <li><a href='/about'>about</a></li>
        <div id="routeView"></div>
    </ul>
</ul>
</body>
<script>
    let routerView = routeView
    window.addEventListener('DOMContentLoaded', onLoad)
    window.addEventListener('popstate', ()=>{
        routerView.innerHTML = location.pathname
    })
    function onLoad () {
        routerView.innerHTML = location.pathname
        var linkList = document.querySelectorAll('a[href]')
        linkList.forEach(el => el.addEventListener('click', function (e) {
            e.preventDefault()
            history.pushState(null, '', el.getAttribute('href'))
            routerView.innerHTML = location.pathname
        }))
    }

</script>
</html>
44. 千分位分割符
JavaScript

let computedNumStr = String(computedNum);
let hasPoint = computedNumStr.includes('.');
if (!hasPoint) {//没有小数点需要末尾添加一个小数点
    computedNumStr += '.';
}
computedNumStr = computedNumStr.replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
computedNum = hasPoint ? computedNumStr : computedNumStr.slice(0, -1);


Number(12321312321).toLocaleString()
                  
45. 滚动加载
HTML
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>滚动加载-3种实现方式</title>
    <style>
        /* 样式可以根据你的需求进行调整 */
        #content {
            height: 100px;
            background-color: #bfa;
            overflow-y: scroll;
        }
    </style>
</head>

<body>
    <div id="content">
        <!-- 初始内容 -->
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
        <p>这是初始内容。</p>
    </div>

    <script>
        const contentDiv = document.getElementById('content');
        let count = 0;
        // 模拟加载更多内容的函数
        function loadMoreContent() {
            const newContent = document.createElement('p');
            newContent.textContent = '这是新加载的内容。' + count++;
            contentDiv.appendChild(newContent);
        }
        // 监听滚动事件
        contentDiv.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = contentDiv;
            if (scrollTop + clientHeight >= scrollHeight - 10) {
                // 当滚动到底部时加载更多内容
                loadMoreContent();
            }
        });

        // 监听滚动事件
        // contentDiv.addEventListener('scroll', () => {
        //     // 获取容器的可视区域高度
        //     const containerHeight = contentDiv.clientHeight;
        //     // 遍历每个项目
        //     const items = document.querySelectorAll('#content p')
        //     items.forEach((item) => {
        //         // 获取项目的位置信息
        //         const rect = item.getBoundingClientRect();
        //         // 如果项目进入了可视区域，加载更多内容
        //         if (rect.bottom <= containerHeight) {
        //             loadMoreContent()
        //         }
        //     });
        // });
        // window窗口
        // window.addEventListener('scroll', function () {
        //     console.log(window.scrollY, window.innerHeight, document.documentElement.scrollHeight);
        //     if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 10) {
        //         loadMoreContent();
        //     }
        // })

    </script>
</body>

</html>


46. 瀑布流格局
HTML
<!DOCTYPE html>
<html>

<head>
    <title>瀑布流布局</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1" />
    <div contenteditable>
        ```css
        .container {
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
        height: 800px; /* 适当的高度 */
        }

        .container {
        column-count: 5;
        /* 列数 */
        column-gap: 10px;
        /* 列间距 */
        }
        ```
    </div>
    <style type="text/css">
        #container {
            position: relative;
            /* 父容器relative */
        }

        .item {
            position: absolute;
            /* 成员设置为absolute */
            display: flex;
            /* 主要为显示字居中 */
            justify-content: center;
            /* 水平居中 */
            align-items: center;
            /* 垂直居中 */
            color: #fff;
            /* 字体颜色白色 */
        }
    </style>
</head>

<body>
    <div id="container"></div>
</body>
<script type="text/javascript">
    var column = 3; // 制作三列布局
    var counter = 0; // 计数器 为显示当前块计数
    var columnHeight = Array(column).fill(0); // 记录每列高度
    var container = document.getElementById("container"); // 父容器对象
    var colorList = ["#EAA78C", "#F9CD82", "#9ADEAD", "#9CB6E9", "#E49D9B", "#97D7D7", "#ABA0CA", "#9F8BEC", "#ACA4D5", "#6495ED", "#7BCDA5", "#76B4EF", "#E1C38F", "#F6C46A", "#B19ED1", "#F09B98", "#87CECB", "#D1A495", "#89D196", "#FE9E9F", "#93BAFF", "#D999F9", "#81C784", "#FFCA62", "#FFA477"]; // 颜色列表

    function random(min = 0, max = 1) { // 生成随机数
        return min + ~~((max - min) * Math.random()) // min <= random < max 
    }

    function findMinColumn(arr) { // 找到高度最小的列
        var min = arr[0];
        var index = 0;
        arr.forEach((v, i) => {
            if (v < min) {
                min = v;
                index = i;
            }
        })
        return [index, min];
    }

    function appendImg() {
        var gap = 3; // 间隙设为3px
        for (let i = 0; i < 12; ++i) { // 每次加载12个成员
            var unit = {
                height: random(100, 500), //随机一个不定高度
                width: 300, // 定宽
                color: colorList[random(0, colorList.length)] // 随机颜色
            }
            var [minIndex, min] = findMinColumn(columnHeight); // 获取高度最小列以及下标
            var d = document.createElement("div");  // 创建一个节点
            d.className = "item"; // 设置class
            d.style.background = unit.color; // 设置背景颜色
            d.style.height = `${unit.height}px`; // 设置宽度
            d.style.width = `${unit.width}px`; // 设置宽度
            d.style.top = `${min + gap}px`; // 设置上偏移
            d.style.left = `${(300 + gap) * minIndex}px`; // 设置左偏移
            d.innerText = `${++counter}#${unit.height}X${unit.width}`; // 设置文字
            columnHeight[minIndex] += (unit.height + gap); // 更新选中列的高度
            container.appendChild(d); // 添加节点
        }
    }

    function init() {
        appendImg(); // 初始加载
        var endLoad = columnHeight.some(v => v > window.innerHeight); // 获取是否有某列高度大于屏幕高度
        if (!endLoad) init(); // 如果没有则递归调用继续加载
    }

    (function () {
        init(); // 打开页面自动加载
    })();

    window.onscroll = function () { // 浏览器触底事件
        // if (document.documentElement.scrollTop) {
        //     var scrollHeight = document.documentElement.scrollHeight;
        //     var scrollTop = document.documentElement.scrollTop + document.body.scrollTop;
        //     var clientHeight = document.documentElement.clientHeight;
        //     marginBottom = scrollHeight - scrollTop - clientHeight;
        // } else {
        //     var scrollHeight = document.body.scrollHeight;
        //     var scrollTop = document.body.scrollTop;
        //     var clientHeight = document.body.clientHeight;
        //     marginBottom = scrollHeight - scrollTop - clientHeight;
        // }
        // if (marginBottom <= 0) appendImg();
        if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight) {
            appendImg();
        }
    }

</script>

</html>
47. promise请求失败，需在1s后重新请求，最多重试n次？
JavaScript
const promiseRetry = (fn, times, delay) => {
  return new Promise((resolve, reject) => {
    const innerFn = () => {
      fn()
        .then(() => {
          resolve();
        })
        .catch((e) => {
          console.log(`还有${times}次尝试`);
          if (times == 0) {
            reject(e);
          } else {
            times--;
            setTimeout(() => {
              innerFn();
            }, delay);
          }
        });
    };
    innerFn();
  });
};

//test函数
function getData() {
  let p = new Promise(function (resolve, reject) {
    setTimeout(function () {
      var num = Math.ceil(Math.random() * 20); //生成1-10的随机数
      console.log("随机数生成的值：", num);
      if (num <= 10) {
        console.log("符合条件，值为" + num);
        resolve(num);
      } else {
        reject("数字大于10了执行失败");
      }
    }, 2000);
  });
  return p;
}

promiseRetry(getData, 5, 1000);

48. Promise有一个5s的时间限制？
JavaScript
// 1.先写一题promise,封装一个工具函数输入一个promiseA
// 返回一个promiseB如果超过1s没返回则抛出异常如果正常则输出正确的值。
const promiseA = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("111");
  }, 200);
});

const timing = () => {
  return new Promise((reject) => {
    setTimeout(() => {
      reject("timeout");
    }, 199);
  });
};

const raceTiming = (promiseA) => {
  const arr = [timing(), promiseA];
  return Promise.race(arr);
};

const PromiseB = raceTiming(promiseA);
PromiseB.then((res) => {
  console.log(res);
}).catch((e) => {
  console.log(e);
});

49. promise 红绿灯实现？ 
JavaScript
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function changeLight(color, duration) {
  console.log(`Light is ${color}`);
  return sleep(duration);
}

function trafficLight() {
  const cycle = async () => {
    while (true) {
      await changeLight("Red", 3000);
      await changeLight("Yellow", 1000);
      await changeLight("Green", 2000);
      await changeLight("Yellow", 1000);
    }
  };
  cycle()
    .catch((error) => {
      console.error(`Error: ${error}`);
    });
}
trafficLight();

// 写法2
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}

function light(timer, callback) {
    return new Promise((resolve) => {
        setTimeout(() => {
            callback();
            resolve();
        }, timer)
    })
}

const step = () => {
    Promise.resolve().then(() => {
        return light(1000, red);
    }).then(() => {
        return light(1000, green);
    }).then(() => {
        return light(1000, yellow);
    }).then(() => {
        step();
    })
}
// step();

const asynStep = async () => {
    await light(1000,red)
    await light(1000,green)
    await light(1000, yellow)
    asynStep()
}

asynStep()

// 方法3
const list = ['red', 'yellow', 'green']
list.reduce(async (pre, cur) => {
     return pre.then(() => {
         return new Promise(resolve => {
             setTimeout(() => {
                 console.log(cur);
                 resolve();
             }, 2000)
         })
     })
 }, Promise.resolve())
50. 大数相加
在JavaScript中，由于数字精度的限制，处理大数相加可能会导致精度丧失。
为了解决这个问题，通常使用字符串来表示大数，然后编写一个函数来执行大数相加操作。
JavaScript
function addLargeNumbers(num1, num2) {
  // 将两个大数转换为字符串
  const strNum1 = num1.toString();
  const strNum2 = num2.toString();

  let carry = 0; // 进位初始化为0
  let result = []; // 存储最终结果的数组

  // 计算两个字符串数字的长度
  const len1 = strNum1.length;
  const len2 = strNum2.length;

  // 找到最大长度
  const maxLen = Math.max(len1, len2);

  for (let i = 0; i < maxLen; i++) {
    // 从右往左逐位相加，如果某一位已经超出字符串长度则用0代替
    const digit1 = i < len1 ? parseInt(strNum1[len1 - 1 - i]) : 0;
    const digit2 = i < len2 ? parseInt(strNum2[len2 - 1 - i]) : 0;

    // 计算当前位的和以及进位
    const sum = digit1 + digit2 + carry;

    // 计算当前位的结果值和进位值
    const currentDigit = sum % 10;
    carry = Math.floor(sum / 10);

    // 将当前位的结果值插入到结果数组的开头
    result.unshift(currentDigit);
  }

  // 如果最后还有进位，添加到结果数组
  if (carry > 0) {
    result.unshift(carry);
  }

  // 将结果数组转换为字符串
  return result.join('');
}

// 示例用法
const num1 = "123456789012345678901234567890";
const num2 = "987654321098765432109876543210";

const sum = addLargeNumbers(num1, num2);
console.log(sum);
这个函数可以处理大数相加，并返回结果作为一个字符串，保持了高精度。请注意，此方法仅适用于整数相加，不支持小数。如果需要支持小数，可以对输入的字符串进行分割并分别处理整数部分和小数部分。
51. 驼峰命名法
JavaScript
function camelToUnderscore(str) {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase();
}

function camelToUnderscore(str) {
  return str
    .split(/(?=[A-Z])/)
    .join('_')
    .toLowerCase();
}


function underscoreToCamel(str) {
  return str.replace(/_(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
}

function underscoreToCamel(str) {
  const words = str.split('_');
  const camelCaseString = words[0] + words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
  return camelCaseString;
}

52. 数组的并集交集差集
JavaScript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

//并集
let union = new Set([...a, ...b]);

//交集
let inset = new Set([...a].filter((x) => b.has(x)));

//差集
let difference = new Set([...a].filter((x) => !b.has(x)));

53. rem适配 | vw/vh 兼容性问题
JavaScript
// 物理像素与逻辑像素不一致问题
const htmlEl = document.getElementByTagName('html')[0];
htmlEl.style.fontSize = window.innerWidth / 750  * 100  + 'px'



// 无论设备的屏幕大小如何，网页的布局都会保持一致。
const meta = document.querySelector('meta[name="viewport"]');
const dpr = window.devicePixelRatio; // 2
const scaleRatio = 1 / dpr; // 假设为 0.5
meta.setAttribute(`initial-scale=0.5, maximum-scale=0.5;mininum-scale=0.5`)


// 根据屏幕宽度自适应文字
window.resize = function(){
   var clientWidth = document.documentElement.clientWidth;
   if (!clientWidth) return;
   html.style.fontSize = 100 * (clientWidth / 750) + 'px';
}

54. 常见的排序算法和时间复杂度
快速排序
JavaScript
var sortArray = function (nums) {
    function partition(l, r) {
        let pivot = nums[l];
        while (l < r) {
            while (l < r && pivot <= nums[r]) {
                r--;
            }
            nums[l] = nums[r];
            while (l < r && nums[l] <= pivot) {
                l++;
            }
            nums[r] = nums[l];
        }
        nums[l] = pivot;
        return l;
    }
    function quickSort(l, r) {
        if (l < r) {
            let pivot = partition(l, r);
            quickSort(l, pivot - 1);
            quickSort(pivot + 1, r);
        }
    }
    quickSort(0, nums.length - 1)
    return nums
};
堆排序
JavaScript
// 数组的第K个最大元素
var findKthLargest = function (nums, k) {
    const swap = (i, j) => {
        let t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    const buildHeap = (i, len) => {
        let l = 2 * i + 1;
        let r = 2 * i + 2;
        let max = i;
        if (l < len && nums[l] > nums[max]) {
            max = l;
        }
        if (r < len && nums[r] > nums[max]) {
            max = r;
        }
        if (max !== i) {
            swap(i, max);
            buildHeap(max, len);
        }
    }
    let len = nums.length;
    for (let i = Math.floor(len / 2) ; i >= 0; i--) {
        buildHeap(i, len);
    }
    // k - 1 次 与 0 交换 再从0开始挪动, 条件为 i > nums.length - k
    // (nums.length -k , nums.length - 1] === k - 1 次
    // 如果是完整的堆排序，则为 nums.length - 1次交换，条件为 i > 0
    for (let i = nums.length - 1; i > nums.length - k; i--) {
        swap(0, i);
        buildHeap(0, --len);
    }
    return nums[0];
}

冒泡排序
冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行的，直到没有再需要交换的元素为止。
JavaScript
function bubbleSort(arr) {
    let len = arr.length;
    for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

插入排序
插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
JavaScript
function insertionSort(arr) {
    let len = arr.length;
    for (let i = 1; i < len; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}

选择排序
选择排序的基本思想是在未排序的序列中找到最小（或最大）的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
JavaScript
function selectionSort(arr) {
    let len = arr.length;
    for (let i = 0; i < len - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }
    return arr;
}
归并排序
归并排序是一种分而治之的算法，它将数组分成两半，对每一半递归地应用归并排序，然后将结果合并在一起。
JavaScript
function mergeSort(arr) {
    if (arr.length < 2) {
        return arr;
    }
    const mid = Math.floor(arr.length / 2);
    const left = arr.slice(0, mid);
    const right = arr.slice(mid);

    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
    let result = [];
    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
    return result.concat(left, right);
}

希尔排序
希尔排序是插入排序的一种更高效的版本，它通过将原始数据分割成若干子序列来改进插入排序的性能。
JavaScript
function shellSort(arr) {
    let n = arr.length;
    let gap = Math.floor(n / 2);
    while (gap > 0) {
        for (let i = gap; i < n; i++) {
            let temp = arr[i];
            let j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
        gap = Math.floor(gap / 2);
    }
    return arr;
}
基数排序
是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位上的数字大小进行排序。这种排序算法适合于数据范围不大的整数排序，特别是每一位数字分布较为均匀时更为有效。
基数排序的基本步骤如下：
1.分配：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，根据数值的最低位进行分配，建立桶。
2.收集：将上一步得到的桶中的数值按照次低位的值进行分配，收集到新的桶中。
3.重复：重复上述分配与收集过程，直至最高位。
4.合并：将所有桶中的数值依次取出，即得到了排序完成的结果。
JavaScript
function radixSort(arr) {
    const maxNum = Math.max(...arr);
    const maxDigits = Math.floor(Math.log10(maxNum)) + 1;

    for (let digit = 0; digit < maxDigits; digit++) {
        const buckets = Array.from({length: 10}, () => []);

        // 按照当前位的数字分配到对应的桶中
        arr.forEach(num => {
            const bucketIndex = Math.floor((num / Math.pow(10, digit)) % 10);
            buckets[bucketIndex].push(num);
        });

        // 将桶中的数字收集回原数组，准备下一轮分配
        arr = [].concat(...buckets);
    }

    return arr;
}
这段代码首先计算出数组中的最大数以及它有多少位，然后针对每一位（从最低位到最高位）进行排序。对于每一位，它创建了10个桶（对应0-9），将所有元素根据该位的值分配到相应的桶中，之后再将所有桶中的元素按顺序合并回原数组。这个过程重复进行，直到处理完最高位，最终得到一个完全排序的数组。

55. 字符串连续重复出现次数最多的字符，打印该字符的起始位置和结束位置。
JavaScript
function findMaxRepeatCharWithPositionOptimized(str) {
  if (!str) return null;

  let maxChar = str[0];
  let maxStart = 0;
  let maxEnd = 0;
  let currentChar = str[0];
  let currentCount = 1;
  let currentStart = 0;

  for (let i = 1; i < str.length; i++) {
    if (str[i] === currentChar) {
      currentCount++;
    } else {
      if (currentCount > maxEnd - maxStart) {
        maxChar = currentChar;
        maxStart = currentStart;
        maxEnd = i - 1;
      }
      currentChar = str[i];
      currentCount = 1;
      currentStart = i;
    }
  }

  // 检查最后一个字符的连续重复序列是否为最长
  if (currentCount > maxEnd - maxStart) {
    maxChar = currentChar;
    maxStart = currentStart;
    maxEnd = str.length - 1;
  }

  console.log(
    `字符 '${maxChar}' 重复次数最多，起始位置: ${maxStart}, 结束位置: ${maxEnd}`
  );
}

// 示例
findMaxRepeatCharWithPositionOptimized("aabbbccddddddddeeeeee");

56. 实现一个类，类中有两个函数。第一个函数接收一个url，取出所有参数并提取出来，有重复的属性需转化为数组。第二个函数是接收一个url 和 一个键值对 对象，将其转化为查询参数字符串返回 | 解析URL_Params为对象 | url 动态增加或者替换参数
JavaScript
class UrlParamProcessor {
  constructor() {}

  // 第一个函数：接收URL，解析并返回包含所有参数的对象，重复的属性值将被放入数组中
  extractParamsFromUrl(url) {
    const [main, params] = url.split("?");
    const resObj = {};
    for (const str of params.split("&")) {
      let [key, value] = str.split("=");
      value = decodeURIComponent(value); // 解码
      if (resObj.hasOwnProperty(key)) {
        resObj[key] = [].concat(resObj[key], value);
      } else {
        resObj[key] = value;
      }
    }
    return resObj;
  }

  // 第二个函数：接收URL和一个键值对对象，根据该对象更新URL的查询参数并返回新的URL
  addOrReplaceParamsInUrl(url, paramsObj) {
    const parsedParams = this.extractParamsFromUrl(url);
    url = url.split("?")[0];
    Object.assign(parsedParams, paramsObj);

    let queryStr = "";
    for (let key in parsedParams) {
      const value = parsedParams[key];
      if (Array.isArray(value)) {
        for (let item of value) {
          queryStr += `${key}=${encodeURIComponent(item)}&`;
        }
      } else if (value !== undefined) {
        queryStr += `${key}=${encodeURIComponent(value)}&`;
      }
    }

    return queryStr ? url + "?" + queryStr.slice(0, -1) : url;
  }
}

// 使用示例
const urlProcessor = new UrlParamProcessor();
let url = "http://example.com/?param1=value1&param2=value2&param5=&param6=undefined";

console.log(urlProcessor.addOrReplaceParamsInUrl(url, {
  param3: "hhhh",
  param4: undefined, // 注意：undefined值不会被添加到URL中
  param2: [1, 2, 3],
}));
57. this指针相关的输出题
在JavaScript中，this关键字是一个非常重要且有时可能引起混淆的概念，因为它根据函数的调用方式不同而有不同的指向。以下是一些常见的面试中关于this指针的考察点及解释：
全局上下文或非严格模式下的普通函数调用
在全局作用域中或者非严格模式下，普通函数调用时，this指向全局对象（在浏览器中是window，Node.js中是global）。
JavaScript
function sayHello() {
    console.log(this); // 在浏览器中输出window，在Node.js中输出global
}

sayHello();
对象方法中的this
当函数作为某个对象的方法被调用时，this指向该对象。
JavaScript
const person = {
    name: 'Alice',
    sayHello: function() {
        console.log(this.name); // 输出'Alice'，因为this指向person对象
    }
};

person.sayHello();
构造函数中的this
在构造函数中，this指向新创建的对象实例。
JavaScript
function Person(name) {
    this.name = name;
    this.sayHello = function() {
        console.log(this.name);
    };
}

const alice = new Person('Alice');
alice.sayHello(); // 输出'Alice'
箭头函数中的this
箭头函数不会创建自己的this，它会捕获其所在上下文的this值作为自己的this。
JavaScript
const person = {
    name: 'Bob',
    sayHello: () => {
        console.log(this); // 如果在全局作用域定义，这里this指向window或global，而不是person对象
    }
};

person.sayHello();
call, apply, bind方法
这些方法可以改变函数调用时this的指向。
•call(thisArg, arg1, arg2, ...): 调用一个函数，并指定函数内部的this值和参数。
•apply(thisArg, [argsArray]): 同样用于改变函数的调用上下文，但第二个参数需要是一个数组或类数组对象。
•bind(thisArg, arg1, arg2, ...): 返回一个新的函数，其this值被绑定到了传给bind()的第一个参数。
JavaScript
function greet(greeting) {
    console.log(greeting + ', ' + this.name);
}

const person1 = {name: 'Charlie'};
greet.call(person1, 'Hello'); // 输出'Hello, Charlie'
理解this的关键在于识别函数是如何被调用的，这决定了this的指向。面试中常考的也是这些不同的调用情境下this的指向变化。
58. 主从hook？
JavaScript
import React, { useState, useEffect } from 'react';

// 主从Hook
function useMasterSlave(initialMaster, initialSlave) {
    const [master, setMaster] = useState(initialMaster);
    const [slave, setSlave] = useState(initialSlave);

    useEffect(() => {
        // 当master变化时，更新slave
        setSlave(master);
    }, [master]);

    return [master, setMaster, slave];
}

// 组件
function MasterSlaveComponent() {
    const [master, setMaster, slave] = useMasterSlave('Master', 'Slave');

    return (
        <div>
            <input value={master} onChange={e => setMaster(e.target.value)} />
            <p>Master: {master}</p>
            <p>Slave: {slave}</p>
        </div>
    );
}

export default MasterSlaveComponent;

59. JS 继承
原型链继承
JavaScript
function Person() {
  this.name = "why";
}
Person.prototype.eating = function () {
  console.log(this.name + "正在吃饭");
};
function Student() {
  this.sno = 111;
}
Student.prototype = new Person(); //核心语句
Student.prototype.sleepting = function () {
  console.log(this.name + "正在睡觉");
};
let stu = new Student();
stu.eating();

// 缺点
// 1.打印子类实例，子类继承到的属性是永远看不见得
// 2.多个实例对引用类型的操作会被篡改。
// 比如创建出来了两个实例。两个实例的属性中 有引用数据类型，一方的改变可能会影响另外一个实例上的引用数据类型。
// 3.前端实现类的过程中都没有传递参数。
构造函数继承
JavaScript
function Person(name, age, phone, friends) {
  this.name = name;
  this.age = age;
  this.phone = phone;
  this.friends = friends;
}

Person.prototype.eating = function () {
  console.log(this.name + "很爱吃饭");
};

function Student(name, age, phone, friends, Number) {
  Person.call(this, name, age, phone, friends); //核心语句
  //其实也是就是偷偷调用和下面代码是同等效应
  // this.name = name;
  // this.age = age;
  // this.phone = phone;
  this.Number = Number;
}

//继承
//调用这个就是为了继承父元素的内容
Student.prototype = new Person();

var stu = new Student("hdf", 20, 18906918002, ["小明，小红"], 251902112);
var stu2 = new Student("hdf", 20, 18906918002, ["小刚，小李"], 251902112);

// stu.eating();
// console.log(stu);
console.log(stu.friends);
stu.friends.push("why");
console.log(stu.friends);
console.log(stu2.friends);

// 1.引用对象不会互相影响。传参问题解决
// 缺点:父类构造函数被调用了两次，给子类元素上造成了一些没必要存在的元素。
组合式继承： 两者结合
JavaScript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function() {
  console.log("Hello, I'm " + this.name);
};

let person1 = new Person("Alice", 20);
let person2 = new Person("Bob", 21);

console.log(person1 instanceof Person); // true
console.log(person2 instanceof Person); // true

console.log(person1.sayHello === person2.sayHello); // true

父类原型赋值给子类
JavaScript
// 父类: 公共属性和方法
function Person(name, age, friends) {
  // this = stu
  this.name = name;
  this.age = age;
  this.friends = friends;
}

Person.prototype.eating = function () {
  console.log(this.name + " eating~");
};

// 子类: 特有属性和方法
function Student(name, age, friends, sno) {
  Person.call(this, name, age, friends);
  // this.name = name
  // this.age = age
  // this.friends = friends
  this.sno = 111;
}

// 直接将父类的原型赋值给子类, 作为子类的原型
Student.prototype = Person.prototype;

Student.prototype.studying = function () {
  console.log(this.name + " studying~");
};

// name/sno
var stu = new Student("why", 18, ["kobe"], 111);
console.log(stu);
stu.eating();

// 1.引用对象不会互相影响。传参问题解决
// 缺点:父类构造函数被调用了两次，给子类元素上造成了一些没必要存在的元素。
原型式继承
JavaScript
//原型式继承
// 利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。
function create(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}

// Object.create
// 缺点:
// ● 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。
// ● 无法传递参数
动态原型模式：这是一种将所有信息封装在构造函数中的创建对象的方式，就是在构造函数中根据条件来初始化原型对象，并将所有实例共有的属性和方法添加到原型对象上。这样可以简化代码和保持封装性。例如：
JavaScript
function Person(name, age) {
  this.name = name;
  this.age = age;

  // 只在第一次调用时初始化原型对象
  if (typeof this.sayHello != "function") {
    Person.prototype.sayHello = function() {
      console.log("Hello, I'm " + this.name);
    };
  }
}

let person1 = new Person("Alice", 20);
let person2 = new Person("Bob", 21);

console.log(person1 instanceof Person); // true
console.log(person2 instanceof Person); // true

console.log(person1.sayHello === person2.sayHello); // true

寄生式继承
JavaScript
// var personObj = {
//   running: function () {
//     console.log("running");
//   },
// };

// function createStudent(name) {
//   var stu = Object.create(personObj);
//   stu.name = name;
//   stu.studying = function () {
//     console.log("studying~");
//   };
//   return stu;
// }

// var stuObj = createStudent("why");
// var stuObj1 = createStudent("kobe");
// var stuObj2 = createStudent("james");

var obj1 = {
  eating: function () {
    console.log("吃饭中Ing");
  },
};

function createPerson(name) {
  var newobj1 = Object.create(obj1);
  newobj1.name = name;
  newobj1.running = function () {
    console.log("跑步中");
  };
  return newobj1;
}

var t1 = createPerson("why");
var t2 = createPerson("hdf");
t1.eating();
t2.eating();
t1.running();
t2.running();
寄生组合继承
JavaScript
// 整体思路
// 1.盗用构造函数 .call
// 2.原型赋值   Object.create()
// 3.修改constructor
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function () {
  console.log("我会跑");
};

function Student(name, age, Number) {
  Person.call(this, name, age); //核心代码
  this.Number = Number;
}

inheritPrototype(Student, Person);

//原型赋值+修改constructor
function inheritPrototype(children, parent) {
  children.prototype = Object.create(parent.prototype);
  // children.prototype.constructor = children;
  Object.defineProperty(children.prototype, "constructor", {
    value: children,
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

var stu1 = new Student("hdf", 20, 123456);
console.log(stu1);
stu1.running();

JavaScript
// 对象继承的方式
/**
 * 1. 原型链方式：
 * 缺点明显，创建子类时无法传递参数
 * 只能继承父类的原型对象中的属性和方法，而不能继承父类的构造函数中的属性和方法。
 * 对于引用类型的数据，所有的实例对象都会共享数据，容易出现意外修改
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() { }
Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 2. 构造函数模式，无法实现方法的复用
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}

var child = new Child();
child.sayName(); // TypeError: child.sayName is not a function

/**
 * 3. 组合继承：通过将原型链继承和构造函数继承结合起来，
 * 既能继承父类原型上的属性和方法，又能继承父类构造函数中的属性和方法。
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 4.原型式继承 ，它的实现方式是创建一个临时构造函数，然后将一个对象作为这个构造函数的原型，最后返回这个构造函数的一个实例。
 * 这种方式可以在不必预先定义构造函数的情况下实现继承，但是它也会导致对象间的共享问题。
 */
function createAnother(original) {
    var clone = Object.create(original);
    return clone;
}

var person = {
    name: 'Tom',
    age: 20
};

/**
 * 5. 寄生式继承 它的实现方式是创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后返回这个对象。
 */
function createAnother(original) {
    var clone = Object.create(original);
    clone.sayHi = function () {
        console.log('hi');
    };
    return clone;
}

var person = {
    name: 'Tom',
    age: 20
};

/**
 * 6. 寄生组合继承：通过使用Object.create()方法来优化组合继承，
 * 避免了在子类构造函数中创建父类实例。
 * 超类型原型作为副本，这样就避免了创建不必要的属性。
 */
function Parent() {
    this.name = 'parent';
}
Parent.prototype.sayName = function () {
    console.log(this.name);
};

function Child() {
    Parent.call(this);
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

var child = new Child();
child.sayName(); // 'parent'

/**
 * 7. ES6的class继承：通过使用class和extends关键字来实现继承。
 */

4. react相关
react调度器实现原理
https://segmentfault.com/a/1190000039101758#item-4

5. LeetCode 热题 HOT 100
1.  两数之和
JavaScript
var twoSum = function (nums, target) {
    let map = new Map();
    for (let [key, value] of nums.entries()) {
        if (map.has(target - value)) {
            return [map.get(target - value), key]
        } else {
            map.set(value, key);
        }
    }
};
2. 两数相加
JavaScript
 // 链表结构
 function ListNode(val, next) {
     this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
 }

JavaScript
var addTwoNumbers = function(l1, l2) {
    let add = 0;
    let head = new ListNode(-1);
    let tail = head;
    while(l1 || l2){
        let a = l1 ? l1.val : 0;
        let b = l2 ? l2.val : 0;
        let sum = a + b + add;
        add = Math.floor(sum / 10);
        let node = new ListNode(sum % 10);
        tail.next = node;
        tail = tail.next;
        l1 = l1 && l1.next;
        l2 = l2 && l2.next;
    }
    if(add > 0){
        tail.next = new ListNode(1);
    }
    return head.next;
};

3.  无重复字符的最长子串
JavaScript
var lengthOfLongestSubstring = function (s) {
    const occ = new Set();
    let max = 0;
    let rk = 0;
    for (let i = 0; i < s.length; i++) {
        if(i > 0){
            occ.delete(s[i - 1]);
        }
        while(rk < s.length && !occ.has(s[rk])){
            occ.add(s[rk++]);
        }
        max = Math.max(max,rk - i);
    }
    return max;
};
4. 寻找两个正序数组的中位数
思路
JavaScript
var findMedianSortedArrays = function (nums1, nums2) {
    // 取较小值
    let len1 = nums1.length, len2 = nums2.length;
    if (len1 > len2) return findMedianSortedArrays(nums2, nums1);
    let sum = len1 + len2;
    let start = 0, end = len1;
    let a, b;
    while (start <= end) {
        // 较短段a的二分位置
        a = Math.floor((start + end) / 2);
        // 较长段的二分位置
        b = Math.floor((sum + 1) / 2) - a;
        // 最左边为-Infinity，最右边为 + Infinity
        const aLeft = a <= 0 ? -Infinity : nums1[a - 1];
        const bLeft = b <= 0 ? -Infinity : nums2[b - 1];
        const aRight = a >= len1 ? +Infinity : nums1[a];
        const bRight = b >= len2 ? +Infinity : nums2[b];
        // 需要符合交叉小于等于
        if (aLeft > bRight) {
            end = a - 1;
        } else if (bLeft > aRight) {
            start = a + 1;
        } else {
            //aleft <= bright && bleft <= aright
            return sum % 2 ?
                // 奇数- 左侧较大值
                Math.max(aLeft, bLeft) :
                // 偶数- （左侧较大值 + 右侧较小值） / 2
                (Math.max(aLeft, bLeft) + Math.min(aRight, bRight)) / 2
                ;
        }
    }
};Ï
5. 最长回文子串
思路
动态规划
dp[i +1][j - 1] 能根据 s[i] 是否等于s[j] 推出 dp[i][j]的结果
j - i <= 1 时，中间距离为 1 或者 0，则 dp[i][j] = j - i + 1
JavaScript
var longestPalindrome = function (s) {
    let len = s.length;
    let maxi = 0, maxj = 0;
    let max = 0;
    let dp = Array.from(Array(len + 1), () => Array(len + 1).fill(0));
    // [i + 1][j - 1]->[i][j]
    for (let i = len - 1; i >= 0; i--) {
        for (let j = i; j <= len - 1; j++) {
            if (s[i] === s[j]) {
                if (j - i <= 1) {
                    dp[i][j] = j - i + 1;
                } else {
                    dp[i][j] = dp[i + 1][j - 1] > 0 ? dp[i + 1][j - 1] + 2 : 0;
                }
            }
            if (dp[i][j] > max) {
                max = dp[i][j];
                maxi = i;
                maxj = j;
            }
        }
    }
    return s.slice(maxi, maxj + 1);
};
中心扩展法
回文串分为两种：...x...、...xy...两种形式，每个点统一两次扩展后得到的两条回文串，最长的就是答案。
JavaScript
var longestPalindrome = function (s) {
    function Palindrome(s, L, R) {
        while (L >= 0 && R < s.length && s[L] === s[R]) {
            L--;
            R++;
        }
        return s.slice(L + 1, R);
    }
    let res = '';
    for (let i = 0; i < s.length; i++) {
        let res1 = Palindrome(s, i, i);
        let res2 = Palindrome(s, i, i + 1);
        res = res1.length > res.length ? res1 : res;
        res = res2.length > res.length ? res2 : res;
    }
    return res;
};
6. 正则表达式匹配
思路
动态规划：
JavaScript
var isMatch = function (s, p) {
    if (s == null || p === null) return false;
    const m = s.length, n = p.length;
    let dp = Array.from(Array(m + 1), () => Array(n + 1).fill(false));
    dp[0][0] = true;
    // 第一轮考虑s为空串的情况，作为基础数据
    for (let j = 1; j <= n; j++) {
        if (p[j - 1] === '*') {
            // 一个*，代表一切，不用遍历
            if (j === 1) {
                return true;
            } else {
                 // * 和 a* 都可以表示空字符串，因为*前面的字符串可以是0次
                // j = 2时，p[1] = '*', 
                dp[0][j] = dp[0][j - 2];
            }
        }
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s[i - 1] === p[j - 1] || p[j - 1] === '.') {
                dp[i][j] = dp[i - 1][j - 1]
            } else if (p[j - 1] === '*') {
                if (s[i - 1] === p[j - 2] || p[j - 2] === '.') {
 //这行代码处理的是模式字符串p的第j个字符是*的情况，它对应了以下三种情况：
//dp[i][j - 2]：这种情况对应于*操作符使得前面的元素出现0次。例如，对于字符串s="a"和模式p="ab*"，我们可以忽略b*，使得模式匹配空字符串。
//dp[i - 1][j - 2]：这种情况对应于*操作符使得前面的元素出现1次。例如，对于字符串s="ab"和模式p="ab*"，我们可以匹配一个b，使得模式匹配ab。
// dp[i - 1][j]：这种情况对应于*操作符使得前面的元素出现多次。例如，对于字符串s="abbb"和模式p="ab*"，我们可以匹配多个b，使得模式匹配abbb。
   
                 dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j];
                } else {
                // 忽略前面的字符串，次数为0
                    dp[i][j] = dp[i][j - 2];
                }
            }

        }
    }
    return dp[m][n]
};
7. 盛最多水的容器
JavaScript
var maxArea = function(height) {
    let res = 0;
    let l = 0, r = height.length - 1;
    while(l <= r){
        res = Math.max(res, Math.min(height[l],height[r]) * (r - l));
        if(height[l] < height[r]){
            l++;
        }else{
            r--;
        }
    }
    return res;
};
8. 三数之和
JavaScript
var threeSum = function (nums) {
    if (nums == null || nums.length < 3) {
        return []
    }
    let res = []
    nums.sort((a, b) => a - b)
    for (let i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i - 1] === nums[i]) {
            continue;
        }
        if (nums[i] > 0) {
            break;
        }
        let l = i + 1, r = nums.length - 1;
        while (l < r) {
            let sum = nums[l] + nums[r] + nums[i];
            if (sum === 0) {
                res.push([nums[i], nums[l], nums[r]]);
                while (l < r && nums[l] === nums[++l]) {
                    continue;
                }
                while (l < r && nums[r] === nums[--r]) {
                    continue;
                }
            } else if (sum > 0) {
                r--;
            } else {
                l++;
            }
        }
    }
    return res;
};
9.  电话号码的字母组合
JavaScript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
    if (digits.length == 0) {
        return [];
    }
    let map = new Map([
        ['2', 'abc'],
        ['3', 'def'],
        ['4', 'ghi'],
        ['5', 'jkl'],
        ['6', 'mno'],
        ['7', 'pqrs'],
        ['8', 'tuv'],
        ['9', 'wxyz']
    ])
    let res = [];
    const dfs = (inx, path) => {
        if (inx === digits.length) {
            res.push(path)
            return;
        }
        let str = map.get(digits[inx]);
        for (let ch of str) {
            dfs(inx + 1, path + ch);
        }
    }
    dfs(0, '')
    return res;
};
10. 删除链表的倒数第 N 个结点
JavaScript
var removeNthFromEnd = function(head, n) {
    let newhead = new ListNode(-1,head);
    let slow = fast = newhead;
    while(n--){
        fast = fast.next;
    }
    while(fast && fast.next){
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return newhead.next;
};

11. 有效的括号
JavaScript
var isValid = function (s) {
    let stack = [];
    let map = new Map([
        ["(", ")"],
        ["{", "}"],
        ["[", "]"],
    ])
    for (let ch of s) {
       if(map.has(ch)){
           stack.push(ch);
       }else{
           if(stack.length && map.get(stack[stack.length - 1]) === ch){
               stack.pop();
           }else{
               return false;
           }
       }
    }
    return !stack.length;
};
12. 合并两个有序链表
JavaScript
var mergeTwoLists = function (list1, list2) {
    let head = new ListNode(-1);
    let tail = head;
    let p1 = list1;
    let p2 = list2;
    while (p1 && p2) {
        if (p1.val < p2.val) {
            tail.next = p1;
            p1 = p1.next;
            tail = tail.next;
        } else {
            tail.next = p2;
            p2 = p2.next;
            tail = tail.next;
        }
    }
    if (p1) {
        tail.next = p1;
    } else {
        tail.next = p2;
    }
    return head.next;
};
13. 括号生成
JavaScript
var generateParenthesis = function (n) {
    let res = []
    const dfs = (path, l, r) => {
        if (path.length === 2 * n) {
            res.push(path);
            return;
        }
        if (l > 0) {
            dfs(path + '(', l - 1, r);
        }
        if (l < r) {
            dfs(path + ')', l, r - 1);
        }
    }
    dfs('', n, n);
    return res;
};
14.  合并 K 个升序链表
JavaScript
function mergeTwoLists(p1, p2) {
    let head = new ListNode(-1);
    let tail = head;
    while (p1 && p2) {
        if (p1.val < p2.val) {
            tail.next = p1;
            p1 = p1.next;
        } else {
            tail.next = p2;
            p2 = p2.next;
        }
        tail = tail.next;
    }
    tail.next = p1 ? p1 : p2;
    return head.next;
}
var mergeKLists = function (lists) {
    function dfs(i, j) {
        const m = j - i;
        if (m === 0) {
            return null;
        } else if (m === 1) {
            return lists[i];
        } else {
            const l = dfs(i, i + (m >> 1));
            const r = dfs(i + (m >> 1), j);
            return mergeTwoLists(l, r);
        }
    }
    return dfs(0, lists.length);
};
15.  下一个排列
JavaScript
var nextPermutation = function (nums) {
    let i = nums.length - 2;
    // 找到第一个较小值
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    if (i >= 0) {
        let j = nums.length - 1;
        // 找到第一个大于i的值
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]]
    }
    // i + 1 后面逆序
    let l = i + 1, r = nums.length - 1;
    while (l < r) {
        [nums[l++], nums[r--]] = [nums[r], nums[l]];
    }
    return nums;
};
16.  最长有效括号
JavaScript
var longestValidParentheses = (s) => {
    let stack = [-1];
    let res = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.length) {
                res = Math.max(res, i - stack[stack.length - 1])
            } else {
                stack.push(i);
            }
        }
    }
    return res;
}
17. 搜索旋转排序数组
JavaScript
var search = function (nums, target) {
    if (!nums || nums.length == 0) {
        return -1;
    }
    let l = 0;
    let r = nums.length - 1;
    while (l <= r) {
        let mid = Math.floor((r - l) / 2) + l;
        if (nums[mid] === target) {
            return mid;
        } else {
            if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target <= nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] <= target && target <= nums[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
    }
    return -1;
};
18. 在排序数组中查找元素的第一个和最后一个位置
JavaScript
const binarySearch = (nums, target, lower) => {
    let left = 0, right = nums.length - 1, ans = nums.length;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (lower) {
            if (nums[mid] >= target) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            }
        }

    }
    return ans;
}

var searchRange = function (nums, target) {
    let ans = [-1, -1];
    const leftIdx = binarySearch(nums, target, true);
    const rightIdx = binarySearch(nums, target, false);
    if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] === target && nums[rightIdx] === target) {
        ans = [leftIdx, rightIdx];
    }
    return ans;
};Î
19.  组合总和
JavaScript
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 * 输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
 */
var combinationSum = function (candidates, target) {
    const res = []
    const dfs = (path, sum, i) => {
        if (sum === target) {
            res.push(path);
            return;
        } else if (sum > target) {
            return;
        } else {
            for (let j = i; j < candidates.length; j++) {
                dfs(path.concat(candidates[j]), sum + candidates[j], j);
            }
        }
    }
    dfs([], 0, 0);
    return res;
};
20. 接雨水
JavaScript
var trap = function (height) {
  let lMax = (rMax = 0);
  let l = 0,
    r = height.length - 1;
  let sum = 0;
  while (l < r) {
    lMax = Math.max(lMax, height[l]);
    rMax = Math.max(rMax, height[r]);
    // 矮墙的高度 - 当前高度 = 水
    if (lMax < rMax) {
      sum += lMax - height[l++];
    } else {
      sum += rMax - height[r--];
    }
  }
  return sum;
};
21. 全排列
JavaScript
var permute = function (nums) {
    let res = []
    const dfs = (path,visited) =>{
        if(path.length === nums.length){
            res.push(Array.from(path))
        }
        for(let i = 0;i < nums.length;i++){
            if(visited[i]){
                continue;
            }
            visited[i] = true;
            dfs([...path,nums[i]],visited)
            visited[i] = false;
        }
    }
    dfs([],[])
    return res
};
22. 旋转图像
JavaScript
var rotate = function (nums) {
    let m = nums.length, n = nums[0].length;
    for (let i = 0; i < Math.floor(m / 2); i++) {
        for (let j = 0; j < n; j++) {
            let temp = nums[i][j];
            nums[i][j] = nums[m - 1 - i][j];
            nums[m - 1 - i][j] = temp;
        }
    }
    for(let i = 0;i < m;i++){
        for(let j = i;j < n;j++){
            let temp = nums[i][j];
            nums[i][j] = nums[j][i];
            nums[j][i] = temp;
        }
    }
    return nums;
};
23. 字母异位词分组
JavaScript
var groupAnagrams = function(strs) {
    const map = new Map();
    for (let str of strs) {
        let array = Array.from(str);
        array.sort();
        let key = array.toString();
        let list = map.has(key) ? map.get(key) : new Array();
        list.push(str);
        map.set(key, list);
    }
    return Array.from(map.values());
};
24. 最大子数组和
JavaScript
var maxSubArray = function (nums) {
    let max = nums[0];
    for (let i = 1; i <= nums.length - 1; i++) {
        if (nums[i - 1] > 0) {
            nums[i] += nums[i - 1]
        }
        max = Math.max(nums[i], max)
    }
    return max;
    
};
25. 跳跃游戏
JavaScript
var canJump = function (nums) {
    let len = nums.length;
    if (len <= 1) {
        return true;
    }
    let end = 0;
    for (let i = 0; i < len; i++) {
        end = Math.max(end, nums[i] + i);
        if(end >= len - 1){
            return true;
        }
        if(end === i){
            break;
        }
    }
    return false;
};
26. 合并区间
JavaScript

var merge = function(intervals) {
    if(!intervals){
        return [];
    }
    intervals.sort((a,b)=>a[0]-b[0])
    let res = [];
    let i = 0,len = intervals.length;
    while(i < len){
        let j = i + 1;
        let cur = intervals[i];
        while(j < len && cur[1] >= intervals[j][0]){
            cur[1] = Math.max(intervals[j][1],cur[1]);
            j++;
        }
        res.push(cur);
        i = j
    }
    return res;
}
27. 不同路径
JavaScript
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0).map(() => Array(n).fill(0));
    for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (let j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[m - 1][n - 1]
};
28. 最小路径和
JavaScript
var minPathSum = function(grid) {
    let m = grid.length,n = grid[0].length;
    let f = Array(m).fill(0).map(()=>{
        return Array(n).fill(0)
    })
    f[0][0] = grid[0][0];
    for(let i = 1;i < m;i++){
        f[i][0] = f[i-1][0] + grid[i][0];
    }
    for(let j = 1;j < n;j++){
        f[0][j] = f[0][j-1] + grid[0][j];
    }
    for(let i = 1;i < m;i++){
        for(let j = 1;j < n;j++){
         f[i][j] = Math.min(f[i-1][j],f[i][j-1])+grid[i][j]
        }
    }
    return f[m-1][n-1]
};
29. 爬楼梯
JavaScript
var climbStairs = function (n) {
    let pre = 1;
    let cur = 1;
    let sum = 0;
    while(n--){
        sum = pre + cur;
        pre = cur;
        cur = sum;
    }
    return pre;
};
30. 编辑距离
JavaScript
var minDistance = function (word1, word2) {
    let m = word1.length;
    let n = word2.length;
    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    // dp[i][0]表示word2为空串，word1有多长，就需要删除多少次
    for (let i = 1; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 1; j <= n; j++) {
        dp[0][j] = j;
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i - 1] === word2[j - 1]) {
                // 相等的情况 === 替换
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // dp[i][j - 1] 插入 dp[i - 1][j] 删除 dp[i - 1][j - 1] 替换
                dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
            }
        }
    }
    return dp[m][n];
};
31. 颜色分类
JavaScript
//  0、 1 和 2 分别表示红色、白色和蓝色。
// 我们可以设置 3 个指针，一个指向头部，一个指向尾部，还有一个指向当前遍历的元素。
// 我们从头部开始遍历数组，如果遇到 0（红色）就把它放到头部指针的位置，
// 如果遇到 2（蓝色）就把它放到尾部指针的位置。
// 如果遇到 1（白色），就跳过它，继续遍历。
var sortColors = function (nums) {
    let l = 0;
    let r = nums.length - 1;
    for (let i = 0; i <= r; i++) {
        if (nums[i] === 0) {
            [nums[l++], nums[i]] = [nums[i], nums[l]]
        } else if (nums[i] === 2) {
            [nums[r--], nums[i--]] = [nums[i], nums[r]]
        }
    }
    return nums;
};
32. 最小覆盖子串
JavaScript
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
    let l = 0, r = 0;
    let map = new Map();
    for (let ch of t) {
        map.set(ch, map.has(ch) ? map.get(ch) + 1 : 1);
    }
    let size = map.size;
    let res = '';
    while (r < s.length) {
        if (map.has(s[r])) {
            map.set(s[r], map.get(s[r]) - 1);
            if (map.get(s[r]) === 0) {
                size--;
            }
        }
        while (size === 0) {
            const newRes = s.slice(l, r + 1)
            if (!res || newRes.length < res.length) res = newRes
            if (map.has(s[l])) {
                map.set(s[l], map.get(s[l]) + 1);
                if (map.get(s[l]) === 1) {
                    size++;
                }
            }
            l++;
        }
        r++;
    }
    return res;
};
33. 子集
JavaScript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    let res = []
    function backtrack(path, start) {
        res.push([...path])
        for (let i = start; i < nums.length; i++) {
            backtrack([...path, nums[i]], i + 1)
        }
    }
    backtrack([], 0)
    return res
};
console.log(subsets([1, 2, 3]))
34. 单词搜索
JavaScript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    const m = board.length, n = board[0].length;
    const dfs = (i, j, k) => {
        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== word[k]) {
            return false;
        }
        if (k === word.length - 1) {
            return true;
        }
        board[i][j] = '';
        const res = dfs(i, j - 1, k + 1) || dfs(i, j + 1, k + 1) || dfs(i - 1, j, k + 1) || dfs(i + 1, j, k + 1);
        board[i][j] = word[k];
        return res;
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (board[i][j] === word[0] && dfs(i, j, 0)) {
                return true;
            }
        }
    }
    return false;
};
35. 柱状图中最大的矩形
JavaScript
/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {
    let arr = [0, ...heights, 0];
    let stack = [];
    let res = 0;
    for (let i = 0; i < arr.length; i++) {
        while (stack.length && arr[stack[stack.length - 1]] > arr[i]) {
            let peek = stack.pop();
            res = Math.max(res, (i - stack[stack.length - 1] - 1) * arr[peek])
        }
        stack.push(i);
    }
    return res;
};
36. 最大矩形
JavaScript
/**
 * @param {character[][]} matrix
 * @return {number}
 */

function calculateMaxArea(dp) {
    let m = dp.length;
    let n = dp[0].length;
    let maxArea = 0;
    for (let j = 0; j < n; j++) {
        let heights = [0];
        for (let i = 0; i < m; i++) {
            heights.push(dp[i][j]);
        }
        heights.push(0);
        let stack = [];
        let cur = 0;
        while (cur < heights.length) {
            while (stack.length && heights[stack[stack.length - 1]] > heights[cur]) {
                let peek = stack.pop();
                let w = cur - stack[stack.length - 1] - 1;
                let h = heights[peek];
                maxArea = Math.max(maxArea, w * h);
            }
            stack.push(cur);
            cur++;
        }
    }
    return maxArea;
}

var maximalRectangle = function (matrix) {
    const m = matrix.length, n = matrix[0].length;
    let dp = Array.from(Array(m), () => Array(n).fill(0));
    let res = 0;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (matrix[i][j] === '1') {
                dp[i][j] = j == 0 ? 1 : (dp[i][j - 1] + 1);
            }
        }
    }
    res = Math.max(calculateMaxArea(dp), res);
    return res;
}
37. 二叉树的中序遍历
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let stack = [];
    let res = [];
    while (root || stack.length) {
        while (root) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        res.push(root.val);
        root = root.right;
    }
    return res;
};
var inorderTraversal = function (root) {
    const res = []
    const traversal = (root) => {
        if (root) {
            traversal(root.left);
            res.push(root.val);
            traversal(root.right);
        }
    }
    traversal(root);
    return res;
}
38. 不同的二叉搜索树
JavaScript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
    const G = new Array(n + 1).fill(0);
    G[0] = 1;
    G[1] = 1;
    for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            G[i] += G[j - 1] * G[i - j];
        }
    }
    return G[n];
};
39. 验证二叉搜索树
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
    // 二叉搜索树：中序遍历是递增的
    let stack = []
    let pre = -Infinity
    while (root || stack.length) {
        while (root) {
            stack.push(root);
            root = root.left;
        }
        const node = stack.pop();
        if (node.val <= pre) {
            return false;
        }
        pre = node.val;
        root = node.right;
    }
    return true;
};
// 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val
// var isValidBST = function (root, min = -Infinity, max = Infinity) {
//     // 如果是空节点
//     if (!root) return true;
//     // 当前节点的值大于最小值，小于最大值；（换句话说，当前节点的值大于左子树所有节点的值，小于右子树中所有节点的值 ）
//     // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
//     return (
//         root.val > min &&
//         root.val < max &&
//         isValidBST(root.left, min, root.val) &&
//         isValidBST(root.right, root.val, max)
//     );
// };
40. 对称二叉树
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    const dfs = (left, right) => {
        if (left && right) {
            return left.val === right.val && dfs(left.left, right.right) && dfs(left.right, right.left);
        } else if(!left && !right){
            return true;
        } else {
            return false;
        }
    }
    return dfs(root, root);
};
41. 二叉树的层序遍历
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let res = []
    if (!root) return res;
    let queue = [root];
    while (queue.length) {
        res.push([])
        let len = queue.length;
        for (let i = 0; i < len; i++) {
            let node = queue.shift();
            res[res.length - 1].push(node.val);
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
    }
    return res;
};
42. 二叉树的最大深度
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    const getHeight = (root) => {
        if (root) {
            return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
        } else {
            return 0;
        }
    }
    return getHeight(root);
};
43. 从前序与中序遍历序列构造二叉树
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
// let buildTree = (preorder, inorder) => {

//   //当preorder和inorder均为空的时候说明已经到了空节点
//   if (preorder.length == 0 || inorder.length == 0) return null;
//   //创建根节点 -> preorder[0]
//   let node = new TreeNode(preorder[0]);
//   //找到preoder[0]对应inorder中的位置
//   let index = inorder.indexOf(preorder.shift());
//   //左右子树递归
//   node.left = buildTree(preorder, inorder.slice(0, index));
//   node.right = buildTree(preorder, inorder.slice(index + 1));
//   //返回根节点
//   return node;
// };



let buildTree = (preorder, inorder) => {
    if(preorder.length == 0 || inorder.length == 0){
        return null;
    }
    let node = new TreeNode(preorder[0])
    let index = inorder.indexOf(preorder.shift());
    node.left = buildTree(preorder,inorder.slice(0,index))
    node.right = buildTree(preorder,inorder.slice(index+1))
    return node;
};
44. 二叉树展开为链表
JavaScript
var flatten = function(root) {
    var list = [];
    preorderTraversal(root,list);
    for(let i = 1;i < list.length;i++){
        var pre = list[i-1],cur = list[i];
        pre.left = null;
        pre.right = cur;
    }
    // return root;
};

const preorderTraversal = (root, list) => {
    if (root != null) {
        list.push(root);
        preorderTraversal(root.left, list);
        preorderTraversal(root.right, list);
    }
}
45. 买卖股票的最佳时机
JavaScript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    let min = prices[0];
    let max = 0;
    for (let price of prices) {
        min = Math.min(price, min);
        max = Math.max(max, price - min);
    }
    return max;
};
46. 二叉树中的最大路径和
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function (root) {
    let max = -Number.MAX_VALUE;
    const dfs = (root) => {
        if (root) {
            let l = dfs(root.left);
            let r = dfs(root.right);
            let sum = l + r + root.val;
            max = Math.max(sum, max);
            const res = Math.max(l, r) + root.val
            return res > 0 ? res : 0;
        } else {
            return 0;
        }
    }
    dfs(root);
    return max;
};
47. 最长连续序列
JavaScript
var longestConsecutive = function(nums){
    let set = new Set(nums);
    let long = 0;
    for(const num of nums){
        if(!set.has(num - 1)){
            let curNum = num;
            let size = 1;
            while(set.has(curNum + 1)){
                curNum++;
                size++;
            }
            long = Math.max(long,size)
        }
    }
    return long
};
48. 只出现一次的数字
JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let num = nums[0];
    for(let i = 1;i < nums.length;i++){
        num ^= nums[i];
    }
    return num;
};
49. 单词拆分
JavaScript
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    let dp = new Array(s.length + 1).fill(false);
    dp[0] = true;
    for (let i = 1; i <= s.length; i++){
        for (let word of wordDict) {
            let len = word.length;
            if (i >= len) {
                if (dp[i - len] && s.slice(i - len, i) === word) {
                    dp[i] = true;
                }
            }
        }
    }
    return dp[s.length];
};
50. 环形链表
JavaScript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
    let pre = new ListNode(-1);
    pre.next = head;
    let cur = head;
    while (cur && cur.next) {
        if (pre === cur) {
            return true;
        }
        pre = pre.next;
        cur = cur.next.next;
    }
    return false;
};
51. 环形链表 II
JavaScript
var detectCycle = function(head) {
    if(head == null || head.next == null){
        return null;
    }
    let slow = fast = head;
    while(fast && fast.next){
        fast = fast.next.next;
        slow = slow.next;
        if(slow === fast){
            while(head !== slow){
                slow = slow.next;
                head = head.next;
            }
            return head;
        }
    }
    return null;
};
52. LRU 缓存
HTML
/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {
    this.capacity = capacity;
    this.stack = new Map();
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {
    if(this.stack.has(key)){
        let res = this.stack.get(key);
        this.stack.delete(key);
        this.stack.set(key,res);
        return res;
    }else{
        return -1;
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {
    if(this.stack.has(key)){
        this.stack.delete(key)
    }
    this.stack.set(key,value);
    if(this.stack.size > this.capacity){
        this.stack.delete(this.stack.keys().next().value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */

HTML
/*
 * @lc app=leetcode.cn id=146 lang=javascript
 * @lcpr version=30119
 *
 * [146] LRU 缓存
 */

// @lc code=start
/**
 * @param {number} capacity
 */
// 单链表
function ListNode(key, val, next) {
    this.key = key
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
}

var LRUCache = function (capacity) {
    this.count = 0
    this.capacity = capacity
    // 头指针指非活跃节点，尾指针指活跃节点
    this.head = this.tail = new ListNode()
    this.hash = Object.create(null)
};

LRUCache.prototype.get = function (key) {
    const preNode = this.hash[key]
    if (preNode) {
        // 将最新访问的节点放入尾指针位置
        if (this.tail !== preNode.next) {
            const node = preNode.next
            // 将节点拆出来
            preNode.next = node.next
            //preNode.next && (this.hash[preNode.next.key] = preNode)
            this.hash[preNode.next.key] = preNode

        
            // 拆出来的节点放入尾指针末尾，表示活跃节点
            this.tail.next = node
            this.hash[key] = this.tail // 更新哈希前置节点
            this.tail = this.tail.next
            this.tail.next = null
        }

        return this.tail.val
    }

    return -1
};

LRUCache.prototype.put = function (key, value) {
    // 若存在相同的key，直接更新value
    if (this.hash[key]) {
        this.hash[key].next.val = value
        this.get(key) // 更新位置，使其为活跃节点
        return
    }

    // 如果容量满了，释放头指针指向的节点
    if (this.count >= this.capacity) {
        const release = this.head.next
        this.head.next = release.next
        release.next && (this.hash[release.next.key] = this.head)
        delete this.hash[release.key]
        if (this.tail === release) this.tail = this.head
        this.count -= 1   
    }
    
    this.tail.next = new ListNode(key, value)
    this.hash[key] = this.tail // 存储的是前置节点
    this.tail = this.tail.next // 指向末尾
    this.count += 1
};
// @lc code=end

53. 排序链表
JavaScript
var sortList = function (head) {
    if (!head || !head.next) {
        return head;
    }
    let slow = head, fast = head.next;
    while (fast && fast.next) {
        fast = fast.next.next;
        slow = slow.next;
    }
    let midList = slow.next;
    slow.next = null;
    let left = new sortList(head);
    let right = new sortList(midList);
    let newHead = new ListNode(-1);
    let tail = newHead;
    while (left && right) {
        if (left.val < right.val) {
            tail.next = left;
            left = left.next;
        } else {
            tail.next = right;
            right = right.next;
        }
        tail = tail.next;
    }
    tail.next = left == null ? right : left;
    return newHead.next;

}
54. 乘积最大子数组
JavaScript
var maxProduct = function (nums) {
   let res = nums[0];
   let min = max = nums[0];
   if (nums.length == 0) return 0;
   for(let i = 1;i < nums.length;i++){
       let t1 = nums[i];
       let t2 = nums[i] * max;
       let t3 = nums[i] * min;
       min = Math.min(t1,t2,t3);
       max = Math.max(t1,t2,t3);
       res = Math.max(res,max);
   }
   return res;
};
55. 相交链表
JavaScript
var getIntersectionNode = function (headA, headB) {
    let p = headA,q = headB;
    while(p !== q){
        p = p ? p.next : headB;
        q = q ? q.next : headA;
    }
    return p;
};
56. 多数元素
JavaScript
const majorityElement = nums => {
    let count = 1;
    let majar = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (count === 0) {
            majar = nums[i];            
        }
        if (nums[i] === majar) {
            count++;
        } else {
            count--;
        }
    }
    return majar;
};
57. 打家劫舍
JavaScript
var rob = function (nums) {
    let dp = new Array(nums.length + 1).fill(0);
    dp[1] = nums[0];
    for (let i = 2; i <= nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1])
    }
    return dp[nums.length]
};
58. 岛屿数量
JavaScript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    let m = grid.length;
    let n = grid[0].length;
    const dfs = (i, j) => {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === '0') {
            return;
        }
        grid[i][j] = '0'
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    }
    let count = 0;
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === '1') {
                count++;
                dfs(grid, i, j)
            }
        }
    }
    return count;
};
59. 反转链表
JavaScript
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur){
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};
60. 课程表
JavaScript
const canFinish = (numCourses, prerequisites) => {
    const inDegree = new Array(numCourses).fill(0);
    const map = {};
    for(let i = 0;i <prerequisites.length;i++){
        inDegree[prerequisites[i][0]]++;
        if(map[prerequisites[i][1]]){
        map[prerequisites[i][1]].push(prerequisites[i][0]);
        }else{
         map[prerequisites[i][1]] = [prerequisites[i][0]];
        }
    }
    const queue = [];
    for(let i = 0;i < inDegree.length;i++){
        if(inDegree[i]===0){
            queue.push(i);
        }
    }
    let count = 0;
    while(queue.length){
        const selected = queue.shift();
        count++;
        const toEnQueue = map[selected];
        if(toEnQueue && toEnQueue.length){
            for(let i = 0;i < toEnQueue.length;i++){
                inDegree[toEnQueue[i]]--;
                if(inDegree[toEnQueue[i]] == 0){
                    queue.push(toEnQueue[i]);
                }
            }
        }
    }
    return count === numCourses;
}
61. 前缀树
HTML
function Node(val, isEnd) {
    this.val = val;
    this.child = {};
    this.isEnd = isEnd || false;
}

var Trie = function () {
    this.root = new Node();
};

Trie.prototype.insert = function (word) {
    let cur = this.root;
    for (let ch of word) {
        if (!cur.child[ch]) {
            cur.child[ch] = new Node(ch);
        }
        cur = cur.child[ch];
    }
    cur.isEnd = true;
};

Trie.prototype.search = function (word) {
    let cur = this.root;
    for (let ch of word) {
        if (!cur.child[ch]) {
            return false;
        }
        cur = cur.child[ch];
    }
    return cur.isEnd;
};

Trie.prototype.startsWith = function (prefix) {
    let cur = this.root;
    for (let ch of prefix) {
        if (!cur.child[ch]) {
            return false;
        }
        cur = cur.child[ch];
    }
    return true;
};
62. 数组中的第K个最大元素
JavaScript
var findKthLargest = function (nums, k) {
    const swap = (i, j) => {
        let t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    const buildHeap = (i, len) => {
        let l = 2 * i + 1;
        let r = 2 * i + 2;
        let max = i;
        if (l < len && nums[l] > nums[max]) {
            max = l;
        }
        if (r < len && nums[r] > nums[max]) {
            max = r;
        }
        if (max !== i) {
            swap(i, max);
            buildHeap(max, len);
        }
    }
    let len = nums.length;
    for (let i = Math.floor(len / 2) ; i >= 0; i--) {
        buildHeap(i, len);
    }
    // k - 1 次 与 0 交换 再从0开始挪动
    for (let i = nums.length - 1; i > nums.length - k; i--) {
        swap(0, i);
        buildHeap(0, --len);
    }
    return nums[0];
}
63. 最大正方形
JavaScript
var maximalSquare = function (matrix) {
    let max_len = 0;
    let dp = Array.from(Array(matrix.length), () => Array(matrix[0].length).fill(0));
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            if (matrix[i][j] === '1') {
                if (i === 0 || j === 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
                }
                max_len = Math.max(max_len, dp[i][j]);
            }
        }
    }
    return max_len * max_len;
};
64. 翻转二叉树
JavaScript
var invertTree = function(root) {
    if (!root) {
        return null;
    }
    const left = invertTree(root.left);
    const right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};
65.  回文链表
JavaScript
const reverseList = (head) => {
    let pre = null;
    let cur = head;
    while (cur) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}

const endOfFirstHalf = (head) => {
    let slow = fast = head;
    while (fast.next && fast.next.next) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}

var isPalindrome = function (head) {
    if (head == null) return true;
    const firstHalfEnd = endOfFirstHalf(head);
    const secondHalfStart = reverseList(firstHalfEnd.next);
    let p1 = head;
    let p2 = secondHalfStart;
    let result = true;
    while (result && p2 && p1) {
        if (p1.val != p2.val) result = false;
        p1 = p1.next;
        p2 = p2.next;
    }
    return result;
};

66.  二叉树的最近公共祖先
JavaScript
var lowestCommonAncestor = function (root, p, q) {
    const findAncestor = (root, p, q) => {
        if(!root || root == p || root == q){
            return root
        }
        let left = findAncestor(root.left,p,q)
        let right = findAncestor(root.right,p,q)
        if(left && right){
            return root;
        }else if(left && !right){
            return left;
        }else{
            return right;
        }
    }
    return findAncestor(root,p,q)
};
67. 除自身以外数组的乘积
JavaScript
const productExceptSelf = nums => {
    const len = nums.length;
    let left = new Array(len);
    let right = new Array(len);
    left[0] = 1;
    for(let i = 1;i < len;i++){
        left[i] = left[i-1] * nums[i-1];
    }
    right[len-1] = 1;
    for(let j = len-2;j >= 0;j--){
        right[j] = right[j+1] * nums[j+1];
    }
    let res = []
    for(let i in nums){
        res.push(left[i] * right[i]);
    }
    return res;

};
68. 滑动窗口最大值
JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
    // 局部最小栈- 栈顶是最大值，因为一遇到大的就出栈
    const stack = [];
    for (let i = 0; i < k; i++) {
        while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {
            stack.pop();
        }
        stack.push(i);
    }
    let ans = [nums[stack[0]]];
    for (let i = k; i < nums.length; i++) {
        while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {
            stack.pop();
        }
        stack.push(i);
        while (stack[0] <= i - k) {
            stack.shift();
        }
        ans.push(nums[stack[0]]);
    }
    return ans;
};
69. 搜索二维矩阵 II
JavaScript
var searchMatrix = function(matrix, target) {
   const m = matrix.length,n = matrix[0].length;
   let x = 0,y = n - 1;
   while(x < m && y >= 0){
       if(matrix[x][y] == target){
           return true;
       }else if(matrix[x][y] > target){
           y--;
       }else{
           x++;
       }
   }
   return false;
};
70. 完全平方数
JavaScript
var numSquares = function (n) {
    // 组合还是排列，都行，计算的是个数
    // 外物品，算组合
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;
    // 现在是外容量内物品，不考虑顺序，只排列
    for (let i = 1; i * i <= n; i++) {
        for (let j = i * i; j <= n; j++) {
            dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
        }
    }
    return dp[n];
};
71. 移动零
JavaScript
var moveZeroes = function(nums) {
    let l = r = 0;
    while(r < nums.length){
        if(nums[r] !== 0){
            const temp = nums[r];
            nums[r] = nums[l];
            nums[l] = temp;
            l++;
        }
        r++;
    }
    return nums;
};
72. 寻找重复数
JavaScript
var findDuplicate = function(nums) {
    let slow = 0, fast = 0;
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);
    slow = 0;
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
};

73. 二叉树的序列化与反序列化
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function (root) {
    return rserialize(root, '');
};

var deserialize = function (data) {
    const dataArray = data.split(",");
    return rdeserialize(dataArray);
};

const rserialize = (root, str) => {
    if (root === null) {
        str += "None,";
    } else {
        str += root.val + '' + ",";
        str = rserialize(root.left, str);
        str = rserialize(root.right, str);
    }
    return str;
}

const rdeserialize = (dataList) => {
    if (dataList[0] === "None") {
        dataList.shift();
        return null;
    }

    const root = new TreeNode(parseInt(dataList[0]));
    dataList.shift();
    root.left = rdeserialize(dataList);
    root.right = rdeserialize(dataList);

    return root;
}

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
74.  最长递增子序列
JavaScript
const lengthOfLIS = (nums) => {
    let dp = Array(nums.length).fill(1);
    let result = 1;
    //dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度
    //位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        result = Math.max(result, dp[i]);
    }

    return result;
};
75. 删除无效的括号
JavaScript
var removeInvalidParentheses = function (s) {
    function isValid(s) {
        let cnt = 0;
        for (const c of s) {
            if (c === '(') cnt++;
            if (c === ')') cnt--;
            if (cnt < 0) {
                return false;
            }
        }
        return cnt === 0;
    }
    let set = new Set([s]);
    while (true) {
        const valid = [...set].filter((item) => isValid(item));
        if (valid.length > 0) {
            return valid;
        }
        let nextSet = new Set();
        for (const str of set) {
            for (let i = 0; i < str.length; i++){
                if (str[i] === '(' || str[i] === ')') {
                    nextSet.add(str.slice(0, i) + str.slice(i + 1));
                }
            }
        }
        set = nextSet;
    }
}
76. 买卖股票的最佳时机含冷冻期
JavaScript
var maxProfit = function (prices) {
    let dp = new Array(4).fill(0);
    dp[0] = -prices[0];
    for (let i = 1; i < prices.length; i++) {
        const [t0, t2] = [dp[0], dp[2]];
        // 本轮有票：之前存的票、本轮买票
        dp[0] = Math.max(dp[0], dp[1] - prices[i], dp[3] - prices[i]);
        // 非冷冻期：上一轮没卖票
        dp[1] = Math.max(dp[1], dp[3])
        // 本轮：卖票
        dp[2] = t0 + prices[i];
        // 冷冻期：上一轮卖票了
        dp[3] = t2;
    }
    return Math.max(...dp);
77. 戳气球
JavaScript
var maxCoins = function (nums) {
    let n = nums.length;
    let points = [1, ...nums, 1];
    // base case 已经都被初始化为 0
    let dp = Array.from(Array(n + 2), () => Array(n + 2).fill(0));
    // 开始状态转移
    for (let i = n + 1; i >= 0; i--) {
        for (let j = i + 1; j <= n + 1; j++) {
            // 最后戳破的气球是哪个？
            // dp[i][j] 表示 (i,j)之间被戳破的气球总和
            for (let k = i + 1; k <= j - 1; k++) {
                dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[j] * points[k]);
            }
        }
    }
    return dp[0][n + 1];
};
78. 零钱兑换
JavaScript
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    // 完全背包 外层物品 内层背包正序 不考虑顺序
    for (let coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i - coin] + 1, dp[i])
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
}
79. 打家劫舍 III
JavaScript
var rob = function (root) {
    const dfs = (node) => {
        if (node === null) {
            return [0, 0];
        }
        const l = dfs(node.left);
        const r = dfs(node.right);
        const selected = node.val + l[1] + r[1];
        const notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        return [selected, notSelected];
    }

    const rootStatus = dfs(root);
    return Math.max(rootStatus[0], rootStatus[1]);
};

80. 比特位计数
JavaScript
var countBits = function(n) {
    const getNum = (n)=>{
        let sum = 0;
        while(n){
            if(n % 2 == 1){
                sum += 1;
            }
            n = n >> 1;
        }
        return sum;
    }
    let res = []
    for(let i = 0;i <= n;i++){
        res.push(getNum(i))
    }
    return res;
};
81. 前 K 个高频元素
JavaScript
let topKFrequent = function(nums, k) {
    let map = new Map(), arr = [...new Set(nums)]
    nums.map((num) => {
        if(map.has(num)) map.set(num, map.get(num)+1)
        else map.set(num, 1)
    })
    // 如果元素数量小于等于 k
    if(map.size <= k) {
        return [...map.keys()]
    }
    return bucketSort(map, k)
};

// 桶排序
let bucketSort = (map, k) => {
    let arr = [], res = []
    map.forEach((value, key) => {
        // 利用映射关系（出现频率作为下标）将数据分配到各个桶中
        if(!arr[value]) {
            arr[value] = [key]
        } else {
            arr[value].push(key)
        }
    })
    // 倒序遍历获取出现频率最大的前k个数
    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){
        if(arr[i]) {
            res.push(...arr[i])
        }
     }
    return res
}
82. 字符串解码
JavaScript
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function (s) {
    const reg = /[a-zA-Z]+|[0-9]+|\[|\]/g;
    const stack = [];
    while (reg.lastIndex < s.length) {
        let token = reg.exec(s)[0];
        if (token !== ']') {
            // 数字，字母，左括号通通入栈
            stack.push(token);
        } else {
            // 遇到右括号就开始出栈
            let str = '';
            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来
            while (stack[stack.length - 1] !== '[') {
                str = stack.pop() + str;
            }
            // 丢掉左括号
            stack.pop();
            // 左括号前面的一定是模式重复的次数
            const num = +stack.pop();
            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分
            stack.push(str.repeat(num));
        }
    }
    return stack.join('');
};

var decodeString = function (s) {
    function expandString(input) {
        // const regex = /(\d+)\(([^()]+)\)/g;
         const regex = /(\d+)\[([^\[\]]+)\]/g;
        let result = input;
        while (regex.test(result)) {
            result = result.replace(regex, (_, count, str) => str.repeat(count));
        }
        return result;
    }
    return expandString(s);
};

var decodeString = function (s) {
    let numStack = [];
    let strStack = [];
    let res = '';
    let num = 0;
    for (let i = 0; i < s.length; i++){
        const ch = s[i];
        if (!isNaN(ch)) {
            num = num * 10 + Number(ch);
        } else if (ch == '[') {
            strStack.push(res);
            res = '';
            numStack.push(num);
            num = 0;
        } else if (ch === ']') {
            const peek = numStack.pop();
            res = strStack.pop() + res.repeat(peek);
        } else {
            res += ch;
        }
    }
    return res;
};
83. 根据身高重建队列
JavaScript
var reconstructQueue = function (people) {
    let queue = [];
    people.sort((a, b) => {
        if (a[0] === b[0]) {
            return a[1] - b[1]//升序
        } else {
            return b[0] - a[0]//降序
        }
    })
    // 优先给身高高的人排序，后续插入节点，不会影响前面人身高的判断
    for (let i = 0; i < people.length; i++) {
        queue.splice(people[i][1], 0, people[i]);
    }
    return queue;
};
84. 分割等和子集
JavaScript
var canPartition = function (nums) {
    const sum = nums.reduce((pre, cur) => pre + cur, 0)
    if (sum % 2) {
        return false;
    }
    const target = sum / 2;
    let dp = new Array(target + 1).fill(0);
    dp[0] = 0;
    for (let num of nums) {
        //确保后面的结果不会影响到前面，所以倒序
        for (let i = target; i >= num; i--) {
            // 容量为i的背包，最多能装多重的物品
            dp[i] = Math.max(dp[i], dp[i - num] + num)
        }
    }
    return dp[target] === target
};
85. 路径总和 III
JavaScript
const pathSum = (root, targetSum) => {
    let map = new Map();
    let res = 0;
    const dfs = (root, sum) => {
        if (root) {
            map.set(sum, (map.get(sum) || 0) + 1);
            let val = sum + root.val;
            res += map.get(val - targetSum) || 0;
            dfs(root.left, val);
            dfs(root.right, val);
            map.set(sum, map.get(sum) - 1);
        } else {
            return 0;
        }
    }
    dfs(root, 0);
    return res;
}
86. 找到字符串中所有字母异位词
JavaScript
var findAnagrams = function (s, p) {
    let res = [], map = {}, need = {}, pLen = p.length, len = 0, val = 0;
    for (let ch of p) {
        if (!need[ch]) {
            need[ch] = map[ch] = 0;
            len++;
        }
        need[ch]++;
    }
    for (let i = 0; i < s.length; i++) {
        // [j + 1,i] => j 是本次舍去的字符，i 是本次加入的字符
        const j = i - pLen;
        if (s[i] in need && ++map[s[i]] === need[s[i]]) val++;
        if (s[j] in need && map[s[j]]-- === need[s[j]]) val--;
        if (val === len) res.push(j + 1);
    }
    return res;

}

87. 找到所有数组中消失的数字
JavaScript
var findDisappearedNumbers = function (nums) {
    const n = nums.length;
    let visited = new Array(n).fill(0);
    for (let num of nums) {
        if (!visited[num - 1]) {
            visited[num - 1] = 1;
        }
    }
    return visited.map((item, inx) => {
        if(item === 0) return inx + 1;
    }).filter(item => item !== undefined);
};
88. 汉明距离
JavaScript
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
   let z = x ^ y;
   let sum = 0;
   while(z){
       if(z % 2){
           sum += 1;
       }
       z = Math.floor(z / 2);
   }
   return sum;
};
89. 目标和
JavaScript
const findTargetSumWays = (nums, target) => {
    const sum = nums.reduce((pre, cur) => pre + cur);
    let res;
    if ((sum + target) % 2) {
        return 0;
    }
    if (Math.abs(target) > sum) {
        return 0;
    } else {
        res = (sum + target) / 2;
    }
    let dp = new Array(res + 1).fill(0);
    dp[0] = 1;
    for (let num of nums) {
        for (let i = res; i >= num; i--) {
            dp[i] += dp[i - num];
        }
    }
    return dp[res];

};
90.  把二叉搜索树转换为累加树
JavaScript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function (root) {
    // let pre = 0;
    // let cur = root;
    // let stack = [];
    // while (cur || stack.length ) {
    //     while (cur) {
    //         stack.push(cur);
    //         cur = cur.right;
    //     }
    //     cur = stack.pop();
    //     cur.val += pre;
    //     pre = cur.val;
    //     cur = cur.left;
    // }
    // return root;
    let pre = 0;
    const Traverse = (node) => {
        if (node) {
            Traverse(node.right);
            node.val += pre;
            pre = node.val;
            Traverse(node.left);
        }
    }
    Traverse(root);
    return root;
};
91.  二叉树的直径
JavaScript
var diameterOfBinaryTree = function (root) {
    let res = 0;
    function getDepth(root) {
        if (!root) return 0;
        let l = getDepth(root.left);
        let r = getDepth(root.right);
        res = Math.max(res, l + r);
        return Math.max(l, r) + 1;
    }
    getDepth(root);
    return res;
};
92. 和为 K 的子数组
JavaScript
var subarraySum = function (nums, k) {
    const map = new Map([[0, 1]]);
    let sum = 0, count = 0;
    for (let i = 0; i < nums.length; i++) {
        sum += nums[i];
        count += map.get(sum - k) || 0
        map.set(sum, (map.get(sum) || 0) + 1)
    }
    return count;
};

93. 最短无序连续子数组
JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function (nums) {
    const n = nums.length;
    // 从左边找最大值索引，从右边找最小值索引
    let right = -1, max = -Infinity;
    let left = -1,min = +Infinity;
    for(let i = 0;i < n;i++){
        if(nums[i] >= max){
            max = nums[i];
        }else{
            right = i;
        }
        if(nums[n - 1 - i] <= min){
            min = nums[n - 1 - i];
        }else{
            left = n - 1 - i;
        }
    }
    return right == -1 ? 0 : right - left + 1;
};

94. 合并二叉树
JavaScript
var mergeTrees = function (root1, root2) {
    if (root1 && root2) {
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
    } else {
        return root1 ? root1 : root2;
    }
};
95. 任务调度器
JavaScript
var leastInterval = function (tasks, n) {
    const len = tasks.length;
    const map = new Map();
    for (let task of tasks) {
        map.set(task, (map.get(task) || 0) + 1);
    }
    // maxNum 最大频数， maxCount 最大频数的个数
    let maxNum = 0, maxCount = 1;
    for (let [key, count] of map) {
        if (count === maxNum) {
            maxCount += 1
        } else if (count > maxNum) {
            maxNum = count;
            maxCount = 1;
        }
    }
    return Math.max((n + 1) * (maxNum - 1) + maxCount, len)
    // ( n + 1) * (最大数 - 1) + 最大数出现的频数 数组长度之间 取最大值

};
96. 回文子串
JavaScript
const countSubstrings = (s) => {
    let numOfPalindromicStr = 0;
    const strLen = s.length;
    let dp = Array.from(Array(strLen), () => Array(strLen).fill(false));

    for (let i = strLen - 1; i >= 0; i--) {
        for (let j = i; j < strLen; j++) {
            if (s[i] === s[j]) {
                //a,aa这种必为回文子串
                if (j - i < 2) {
                    dp[i][j] = true;
                } else {
                    // abba,如果bb是回文子串，则abba也是，同理。
                    dp[i][j] = dp[i + 1][j - 1];
                }
                numOfPalindromicStr += dp[i][j] ? 1 : 0;
            }
        }
    }

    return numOfPalindromicStr;
};
var countSubstrings = function(s) {
    const n = s.length;
    let ans = 0;
    for (let i = 0; i < 2 * n - 1; ++i) {
        let l = Math.floor(i / 2), r = i / 2 + i % 2;
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            --l;
            ++r;
            ++ans;
        }
    }
    return ans;
};
97.  每日温度
JavaScript
/**
 * @param {number[]} temperatures
 * @return {number[]}
 */
var dailyTemperatures = function (temperatures) {
    let dp = new Array(temperatures.length).fill(0);
    let stack = []
    for (let i = temperatures.length - 1; i >= 0; i--) {
       while (stack.length && temperatures[i] >= temperatures[stack[stack.length - 1]]) {
            stack.pop();
        }
        if(stack.length){
            dp[i] = stack[stack.length - 1] - i;
        }else{
            dp[i] = 0;
        }
        stack.push(i)
    }
    return dp;
};
98. 最小栈
JavaScript
class MinStack{
    stack = []
    minStack = [Infinity]
    push(val) {
        this.stack.push(val);
        const minVal = Math.min(this.minStack[this.minStack.length - 1], val);
        this.minStack.push(minVal);
    }
    pop(){
        this.minStack.pop();
        this.stack.pop();
    }
    top() {
        return this.stack[this.stack.length - 1]
    }
    getMin() {
        return this.minStack[this.minStack.length - 1]
    }
}
